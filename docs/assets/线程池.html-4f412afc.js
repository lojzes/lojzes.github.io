import{_ as s,X as e,Y as p,Z as n,a1 as t,$ as o,a2 as c,C as i}from"./framework-0b23a550.js";const l="/assets/1-34872bf3.png",u="/assets/2-077b6344.png",r={},d={class:"hint-container tip"},k=n("p",{class:"hint-container-title"},"参考",-1),v={href:"https://cloud.tencent.com/developer/article/1832455",target:"_blank",rel:"noopener noreferrer"},m=c(`<h2 id="线程池的优点" tabindex="-1"><a class="header-anchor" href="#线程池的优点" aria-hidden="true">#</a> 线程池的优点</h2><ul><li>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li></ul><h2 id="threadpoolexecutor-重要参数" tabindex="-1"><a class="header-anchor" href="#threadpoolexecutor-重要参数" aria-hidden="true">#</a> ThreadPoolExecutor 重要参数</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
    <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
    <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
    <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
    <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>
    <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
    <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="核心参数解释" tabindex="-1"><a class="header-anchor" href="#核心参数解释" aria-hidden="true">#</a> 核心参数解释</h3><ul><li>1、corePoolSize</li></ul><p>​ 核心池的大小。在创建了线程池之后，默认情况下，线程池中没有任何线程，而是等待有任务到来才创建线程去执行任务。默认情况下，在创建了线程池之后，线程池钟的线程数为0，当有任务到来后就会创建一个线程去执行任务</p><ul><li><p>2、maximumPoolSize</p><p>池中允许的最大线程数，这个参数表示了线程池中最多能创建的线程数量，当任务数量比 corePoolSize 大时，任务添加到workQueue，当 workQueue 满了，将继续创建线程以处理任务，maximumPoolSize 表示的就是 wordQueue 满了，线程池中最多可以创建的线程数量</p></li><li><p>3、keepAliveTime</p></li></ul><p>​ 只有当线程池中的线程数大于corePoolSize时，这个参数才会起作用。当线程数大于 corePoolSize 时，终止前多余的空闲线程等待新任务的最长时间</p><ul><li><p>4、unit</p><p>keepAliveTime时间单位</p></li><li><p>5、workQueue</p></li></ul><p>​ 存储还没来得及执行的任务</p><ul><li>6、threadFactory</li></ul><p>​ 执行程序创建新线程时使用的工厂</p><ul><li><p>7、handler(拒绝策略)</p><p>由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序</p></li></ul><h3 id="参数之间的关系" tabindex="-1"><a class="header-anchor" href="#参数之间的关系" aria-hidden="true">#</a> 参数之间的关系</h3><p>1、池中线程数小于 corePoolSize，新任务都不排队而是直接添加新线程</p><p>2、池中线程数大于等于 corePoolSize，workQueue未满，首选将新任务加入workQueue而不是添加新线程</p><p>3、池中线程数大于等于 corePoolSize，workQueue已满，但是线程数小于maximumPoolSize，添加新的线程来处理被添加的任务</p><p>4、池中线程数大于大于 corePoolSize，workQueue已满，并且线程数大于等于maximumPoolSize，新任务被拒绝，使用handler处理被拒绝的任务</p><h3 id="拒绝策略" tabindex="-1"><a class="header-anchor" href="#拒绝策略" aria-hidden="true">#</a> 拒绝策略</h3><p>决绝策略的父接口是 RejectedExecutionHandler，JDK本身在 ThreadPoolExecutor里给用户提供了四种拒绝策略，看一下： 1、AbortPolicy</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//直接抛出一个RejectedExecutionException，这也是JDK默认的拒绝策略</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RejectedExecutionException</span><span class="token punctuation">(</span><span class="token string">&quot;Task &quot;</span> <span class="token operator">+</span> r<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                            <span class="token string">&quot; rejected from &quot;</span> <span class="token operator">+</span>e<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、CallerRunsPolicy</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>   <span class="token comment">// 尝试直接运行被拒绝的任务，如果线程池已经被关闭了，任务就被丢弃了</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                     r<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                      <span class="token punctuation">}</span>
                   <span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、DiscardOldestPolicy</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//移除最晚的那个没有被处理的任务，然后执行被拒绝的任务。同样，如果线程池已经被关闭了，任务就被丢弃了</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>e<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                             e<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                             e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
                         <span class="token punctuation">}</span>
                     <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4、DiscardPolicy</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//不能执行的任务将被删除</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                     <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="任务类型" tabindex="-1"><a class="header-anchor" href="#任务类型" aria-hidden="true">#</a> 任务类型</h2><h3 id="cpu-密集型" tabindex="-1"><a class="header-anchor" href="#cpu-密集型" aria-hidden="true">#</a> CPU 密集型</h3><p>主要靠CPU进行计算类的任务</p><h3 id="io-密集型" tabindex="-1"><a class="header-anchor" href="#io-密集型" aria-hidden="true">#</a> IO 密集型</h3><p>主要设计IO类型的任务，例如从mysql中查询数据、读取网络中的数据、读取硬盘上的数据</p><h2 id="线程数量与任务类型的关系" tabindex="-1"><a class="header-anchor" href="#线程数量与任务类型的关系" aria-hidden="true">#</a> 线程数量与任务类型的关系</h2><h3 id="与cpu任务类型的关系" tabindex="-1"><a class="header-anchor" href="#与cpu任务类型的关系" aria-hidden="true">#</a> 与CPU任务类型的关系</h3><p>一般情况下,<em><strong>CPU核心数 == 最大同时执行线程数</strong></em>.在这种情况下(设CPU核心数为n),大量客户端会发送请求到服务器,但是服务器最多只能同时执行n个线程.</p><p>设线程池工作队列长度为m,且m&gt;&gt;n,则此时会导致CPU频繁切换线程来执行(如果CPU使用的是FCFS,则不会频繁切换,如使用的是其他CPU调度算法,如时间片轮转法,最短时间优先,则可能会导致频繁的线程切换).</p><p>所以这种情况下,无需设置过大的线程池工作队列,(<em><strong>工作队列长度 = CPU核心数 || CPU核心数+1)</strong></em> 即可.</p><h3 id="与io任务类型的关系" tabindex="-1"><a class="header-anchor" href="#与io任务类型的关系" aria-hidden="true">#</a> 与IO任务类型的关系</h3><p>1个线程对应1个方法栈,线程的生命周期与方法栈相同.</p><p>比如某个线程的方法栈对应的入站顺序为:controller()-&gt;service()-&gt;DAO(),由于DAO长时间的I/O操作,导致该线程一直处于工作队列,但它又不占用CPU,则此时有1个CPU是处于空闲状态的.</p><p>所以,这种情况下,应该加大线程池工作队列的长度(如果CPU调度算法使用的是FCFS,则无法切换),尽量不让CPU空闲下来,提高CPU利用率,线程数可以设置为：<em><strong>线程数 == 2n+1</strong></em> ,n为CPU核心数.</p><h2 id="线程池大小-线程数量到底设置多少" tabindex="-1"><a class="header-anchor" href="#线程池大小-线程数量到底设置多少" aria-hidden="true">#</a> 线程池大小 + 线程数量到底设置多少？</h2><p>可能很多人都看到过一个线程数设置的理论：</p><pre><code>CPU 密集型的程序 - 核心数 + 1
I/O 密集型的程序 - 核心数 * 2
</code></pre><p>不会吧，不会吧，真的有人按照这个理论规划线程数？</p><p>测试环境：AMD Ryzen 5 3600, 6 - Core, 12 - Threads</p><p>AMD 3600，6核心12线程（超线程），我们可以简单的认为它就是12核心CPU。那么我这个CPU就可以同时做12件事，互不打扰。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CPUUtilizationTest</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token comment">//每次空循环 1亿 次后，sleep 50ms，模拟 I/O等待、切换</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100_000_000l</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
       <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>线程数和CPU利用率的小总结</p><p>上面的例子，只是辅助，为了更好的理解线程数/程序行为/CPU状态的关系，来简单总结一下：</p><ul><li>一个极端的线程（不停执行“计算”型操作时），就可以把单个核心的利用率跑满，多核心CPU最多只能同时执行等于核心数的“极端”线程数 如果每个线程都这么“极端”，且同时执行的线程数超过核心数，会导致不必要的切换，造成负载过高，只会让执行更慢</li><li>I/O 等暂停类操作时，CPU处于空闲状态，操作系统调度CPU执行其他线程，可以提高CPU利用率，同时执行更多的线程</li><li>I/O 事件的频率频率越高，或者等待/暂停时间越长，CPU的空闲时间也就更长，利用率越低，操作系统可以调度CPU执行更多的线程</li></ul><p>线程数规划的公式</p><p>前面的铺垫，都是为了帮助理解，现在来看看书本上的定义。《Java 并发编程实战》介绍了一个线程数计算的公式：</p><p><img src="`+l+'" alt="" loading="lazy"></p><p><img src="'+u+'" alt="" loading="lazy"></p>',56);function h(b,P){const a=i("ExternalLinkIcon");return e(),p("div",null,[n("div",d,[k,n("p",null,[n("a",v,[t("线程池大小 + 线程数量到底设置多少？"),o(a)])])]),m])}const x=s(r,[["render",h],["__file","线程池.html.vue"]]);export{x as default};

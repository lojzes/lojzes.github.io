import{_ as c,X as t,Y as o,Z as e,a1 as s,$ as r,a2 as d,C as n}from"./framework-0b23a550.js";const i="/assets/spi-01-0c3ad643.png",p={},h={class:"hint-container info"},l=e("p",{class:"hint-container-title"},"参考",-1),_={href:"https://pdai.tech/md/java/advanced/java-advanced-spi.html",target:"_blank",rel:"noopener noreferrer"},v=d('<h2 id="什么是spi" tabindex="-1"><a class="header-anchor" href="#什么是spi" aria-hidden="true">#</a> 什么是spi</h2><p>SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心</p><p>SPI整体机制图如下：</p><p><img src="'+i+'" alt="" loading="lazy"></p><p>当服务的提供者提供了一种接口的实现之后，需要在<code>classpath</code>下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个<code>jar</code>包（一般都是以<code>jar</code>包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p><h2 id="spi机制的缺陷" tabindex="-1"><a class="header-anchor" href="#spi机制的缺陷" aria-hidden="true">#</a> SPI机制的缺陷</h2><p>通过上面的解析，可以发现，我们使用SPI机制的缺陷：</p><p>不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</p><p>获取某个实现类的方式不够灵活，只能通过 <code>Iterator</code> 形式获取，不能根据某个参数来获取对应的实现类。</p><p>多个并发多线程使用 <code>ServiceLoader</code> 类的实例是不安全的。</p>',10);function m(f,I){const a=n("ExternalLinkIcon");return t(),o("div",null,[e("div",h,[l,e("p",null,[e("a",_,[s("https://pdai.tech/md/java/advanced/java-advanced-spi.html"),r(a)])])]),v])}const u=c(p,[["render",m],["__file","spi.html.vue"]]);export{u as default};

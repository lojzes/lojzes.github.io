import{_ as p,X as a,Y as e,a2 as h}from"./framework-0b23a550.js";const r="/assets/1-16c4af1c.png",d="/assets/2-215a6cee.png",i={},n=h(`<div class="hint-container tip"><p class="hint-container-title">参考</p></div><h2 id="流量架构-流量预研" tabindex="-1"><a class="header-anchor" href="#流量架构-流量预研" aria-hidden="true">#</a> 流量架构（流量预研）</h2><p>流量架构包含的主要内容：</p><p>1 按照未来一段时间的用户规模，做系统的流量（吞吐量）预估。</p><p>2 按照流量预估值和系统各层组件的性能基线值，做各层的组件的部署架构规划，确保系统的高性能、 高可用。</p><p>所以，最终的流量架构，就是系统在不同用户量、不同场景下（如平时、战时）的分层规划、组件规 划。</p><h2 id="流量架构的类型" tabindex="-1"><a class="header-anchor" href="#流量架构的类型" aria-hidden="true">#</a> 流量架构的类型</h2><h3 id="老系统的流量架构" tabindex="-1"><a class="header-anchor" href="#老系统的流量架构" aria-hidden="true">#</a> 老系统的流量架构</h3><p>如果是老系统，做流量架构的时候，可以参考现有的监控数据，服务能力，流量指标 。对着老的架构版</p><p>本，进行偏离指标的计算，折算成冗余系数，完成流量架构的工作：</p><p>（1）做出系统在不同用户量、不同场景（高峰、平峰、低峰）下的流量（吞吐量）预估，含未来一段 时期如两年。</p><p>（2）做出系统在不同用户量、不同场景下的各层组件的部署架构。</p><h3 id="新系统的流量架构" tabindex="-1"><a class="header-anchor" href="#新系统的流量架构" aria-hidden="true">#</a> 新系统的流量架构</h3><p>接下来我们重点说一下新系统，也是在实际工作中遇到最多的情况。</p><p>有的朋友可能说：我们公司的项目就是啥都没有，三无产品，没有业务监控、没有中间件日志， 也没有日活数据，那怎么评估预期指标。</p><p>新项目是还没有上线，在上线前希望先进行一轮压测，评估项目性能是否能支撑当前的用户，这个时候 性能预期指标更为重要。</p><p>如果是新系统，线上并没有任何的历史监控数据和日志数据，所以之前介绍的方法就不再适用，这个时 候需要使用另外一种方法来评估性能指标，那就是“二八定律”。</p><p>对新系统来说，完成流量架构的工作：</p><p>（1）根据二八定律，做出系统在不同用户量、不同场景下的流量（吞吐量）预估，含未来一段时期如 两年。</p><p>（2）做出系统在不同用户量、不同场景下的各层组件的部署架构。</p><h2 id="亿级用户量场景下的流量预估" tabindex="-1"><a class="header-anchor" href="#亿级用户量场景下的流量预估" aria-hidden="true">#</a> 亿级用户量场景下的流量预估</h2><p>根据二八定律，做出系统在不同用户量、不同场景下的流量（吞吐量）预估，含未来一段时期如两年。</p><p>二八定律</p><h3 id="什么是二八定律" tabindex="-1"><a class="header-anchor" href="#什么是二八定律" aria-hidden="true">#</a> 什么是二八定律？</h3><p>先来看一下定义。 二八定律又名80/20定律、帕累托法则（Pareto‘s principle）、巴莱特定律、 朱伦法则（Juran’s Principle）、关键少数法则（Vital FeRule）、不重要多数法则（Trivial Many Rule）最省力的法则、不平衡原则等，被广泛应用于社会学及企业管理学等。</p><p>二八定律是19世纪末20世纪初意大利经济学家<code>帕累托</code>发现的。<u>他认为，在任何一种事物中，最重要的 只占其中一小部分，约20%，其余80%尽管是多数，却是次要的</u>。</p><h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景：</h2><h3 id="软件测试" tabindex="-1"><a class="header-anchor" href="#软件测试" aria-hidden="true">#</a> 软件测试</h3><p>软件测试理论中，常提到2-8原则</p><p>80%的测试成本花在20%的软件模块中</p><p>所谓2-8原则，即80%的bug多发生在软件的20%的模块。所以，在回归测试的时候，这20%的高发地带 是关注的重点！</p><p>80%的错误是由20%的模块引起的</p><p>站在用户角度，并非研发实现的角度，正确地选择重要模块作为测试重点，从而不偏离方向。 80%的测试时间花在20%的软件模块中</p><p>软件测试执行过程中需要将时间倾斜在重要模块的测试用例中，从而使测试更加有效，发现bug</p><h3 id="经济学场景" tabindex="-1"><a class="header-anchor" href="#经济学场景" aria-hidden="true">#</a> 经济学场景</h3><p>从经济学上看，世界上80%的财富，都集中的20%的人手里</p><h2 id="互联网行为场景" tabindex="-1"><a class="header-anchor" href="#互联网行为场景" aria-hidden="true">#</a> 互联网行为场景</h2><p>一个网站有成千上万的用户，但是<u>80%的用户请求是发生在20%的时间内</u>，比如大家去网上购物，基本 也都集中在中午休息或晚上下班后。</p><p>二八定律的核心原则是关注重要部分，忽略次要部分。<u>系统性能如果能支撑发生在20%时间内的高并发 请求，必然也能支持非高峰期的访问</u>。</p><h2 id="二八定律来计算预期指标" tabindex="-1"><a class="header-anchor" href="#二八定律来计算预期指标" aria-hidden="true">#</a> 二八定律来计算预期指标</h2><p>通过用户量来预估QPS</p><p>首先先预估系统的<code>每日总请求数</code>，这个没有固定的方法，如果没有任何历史数据参考，一般是通过用户 量或者其他关联系统来评估</p><p>术语说明： <code>QPS = req/sec = 请求数/秒</code></p><blockquote><p>说明：对于单次接口调用的请求， QPS=TPS</p></blockquote><h3 id="【通过用户量来推算pv】" tabindex="-1"><a class="header-anchor" href="#【通过用户量来推算pv】" aria-hidden="true">#</a> 【通过用户量来推算PV】</h3><p>公式：<code>( 总用户数 * 20% ) * 每天的大致点击次数（淘宝经验30-50次）= pv数</code></p><p>问：用户数是1000万，pv量是多少？</p><p>答：1000万 * 20% *30= 6000万 【PV推算QPS的公式】</p><p>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)</p><p>问：每天6000万 PV ，多少QPS？</p><p>答：(6000万 * 0.8 ) / (86400 * 0.2 ) = 4800W/17280(QPS) =2700</p><h2 id="【乘上冗余系数】" tabindex="-1"><a class="header-anchor" href="#【乘上冗余系数】" aria-hidden="true">#</a> 【乘上冗余系数】</h2><p>评估出来指标后，为了更加保险一些，最好再乘以一个冗余系数（偏离系数），提高预期指标，防止人 为评估造成预期指标偏低的情况。</p><p>这个冗余系数一般定为2-5之间（行业经验），上面计算出来的tps指标为2700，如果再乘以一个冗余系 数4，那么最终tps指标就定为10800。</p><p>2700 (QPS) * 4 =10800 (QPS)</p><p>总结一下，二八定律的算法为<u> 80%的请求 / 20%的时间 * 冗余系数</u></p><h2 id="冗余系数的迭代" tabindex="-1"><a class="header-anchor" href="#冗余系数的迭代" aria-hidden="true">#</a> 冗余系数的迭代</h2><p>同时，将来项目上线后，可以通过对项目接口的峰值监控，来对比之前评估的算法结果，调整冗余系 数，最终随着不断的数据积累，将会形成一套本项目的性能模型。</p><h2 id="十万级用户量的压力预估" tabindex="-1"><a class="header-anchor" href="#十万级用户量的压力预估" aria-hidden="true">#</a> 十万级用户量的压力预估</h2><p>假设这个网站预估的用户数是10万，那么根据28法则，每天会来访问这个网站的用户占到20%，也就 是2万用户每天会过来访问。</p><p>【通过用户量来推算PV】 公式：( 总用户数 * 20% ) / 每天的大致点击次数（淘宝经验30-50次）= pv数</p><p>问：用户数是10万，pv量是多少？ 答：10万 * 20% * 30= 60万</p><p>通常假设平均每个用户每次过来会有30次的点击，那么总共就有60万的点击（PV）。</p><h2 id="【pv推算qps的公式】" tabindex="-1"><a class="header-anchor" href="#【pv推算qps的公式】" aria-hidden="true">#</a> 【PV推算QPS的公式】</h2><p>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)</p><p>答：60W * 0.8 / 5 * 3600 = 27 (QPS)</p><p>问：5小时内会有48万点击 ，多少QPS？</p><p>答： 48W * 0.8 / 5 * 3600 * 0.2 = 107 (QPS) * 冗余系统 = 107 * 4 = 428 (QPS)</p><p>【 乘上冗余系统 】</p><p>27 (QPS) * 4 =108 (QPS)</p><h2 id="百万级用户量的压力预估" tabindex="-1"><a class="header-anchor" href="#百万级用户量的压力预估" aria-hidden="true">#</a> 百万级用户量的压力预估</h2><p>个假设这个网站预估的用户数是100万，那么根据28法则，每天会来访问这个网站的用户占到20%，也 就是2万用户每天会过来访问。</p><p>【通过用户量来推算PV】 公式：( 总用户数 * 20% ) / 每天的大致点击次数（淘宝经验30-50次）= pv数</p><p>问：用户数是100万，pv量是多少？ 答：100万 * 20% * 30= 600万</p><p>通常假设平均每个用户每次过来会有30次的点击，那么总共就有600万的点击（PV）。</p><p>【PV推算QPS的公式】 公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)</p><p>问：5小时内会有48万点击 ，多少QPS？</p><p>答：600W * 0.8 / 5 * 3600 = 270 (QPS)</p><pre><code> 48W / (5 * 3600) 约等于 24 * 0.2 *3600=4.8 约等于 5个小时
</code></pre><p>【乘上冗余系统 】</p><p>270 (QPS) * 4 =1080 (QPS)</p><h2 id="千万级用户量的压力预估" tabindex="-1"><a class="header-anchor" href="#千万级用户量的压力预估" aria-hidden="true">#</a> 千万级用户量的压力预估</h2><p>这个假设这个网站预估的用户数是1000万，那么根据28法则，每天会来访问这个网站的用户占到 20%，也就是200万用户每天会过来访问。</p><p>【通过用户量来推算PV】</p><p>公式：( 总用户数 * 20% ) / 每天的大致点击次数（淘宝经验30-50次）= pv数</p><p>问：用户数是1000万，pv量是多少？</p><p>答：1000万 * 20% * 30= 6000万</p><p>通常假设平均每个用户每次过来会有30次的点击，那么总共就有6000万的点击（PV）。</p><p>【PV推算QPS的公式】</p><p>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS) 问：5小时内会有48万点击 ，多少QPS？</p><p>答：6000 W * 0.8 / 5 * 3600 = 2700 (QPS)</p><p>【加上冗余系统 】</p><p>2700 (QPS) * 4 =10800 (QPS)</p><h2 id="亿级用户量的压力预估" tabindex="-1"><a class="header-anchor" href="#亿级用户量的压力预估" aria-hidden="true">#</a> 亿级用户量的压力预估</h2><p>这个假设这个网站预估的用户数是10000万，那么根据28法则，每天会来访问这个网站的用户占到 20%，也就是2000万用户每天会过来访问。</p><p>【通过用户量来推算PV】</p><p>公式：( 总用户数 * 20% ) / 每天的大致点击次数（淘宝经验30-50次）= pv数</p><p>问：用户数是1000万，pv量是多少？</p><p>答：10000万 * 20% * 30= 60000万</p><p>通常假设平均每个用户每次过来会有30次的点击，那么总共就有60000万的点击（PV）。</p><p>【PV推算QPS的公式】</p><p>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)</p><p>问：5小时内会有48万点击 ，多少QPS？</p><p>答：60000 W * 0.8 / 5 * 3600 = 27000 (QPS)</p><p>【加上冗余系统 】</p><p>27000 (QPS) * 4 =108000 (QPS)</p><h2 id="实际与理论的差距" tabindex="-1"><a class="header-anchor" href="#实际与理论的差距" aria-hidden="true">#</a> 实际与理论的差距</h2><p>那么将来项目上线后，接口的访问量真的和计算的一模一样吗？</p><p>这个肯定不会，大家一定得知道一个原则，性能测试从来都不是一门非常精确的技术。</p><p>二八定律也并不是100%适用于所有业务场景。在没有任何历史数据参考的背景下，二八定律相对来说 是一种相对来说靠谱的算法，最起码有一定的理论依据，比拍脑袋猜的值靠谱多了。</p><h2 id="tomcat" tabindex="-1"><a class="header-anchor" href="#tomcat" aria-hidden="true">#</a> Tomcat</h2><p>tomcat 默认配置的最大请求数是<code>150</code>，也就是说同时支持<code>150</code>个并发。具体能承载多少并发，需要看硬 件的配置，CPU 越多性能越高，分配给JVM的内存越多性能也就越高，但也会加重GC的负担。当</p><p>某个应用拥有 <code>250</code> 个以上并发的时候，应考虑应用服务器的集群。</p><p>一般来说，虽然tomcat的io线程最多控制在400以内，如果每个请求要300ms，一个线程3qps，</p><p>那么一个tomcat到达1000qps，还是可以的。</p><p>所以，<u>tomcat参考的并发能力为 1000qps</u></p><h2 id="nginx的并发能力" tabindex="-1"><a class="header-anchor" href="#nginx的并发能力" aria-hidden="true">#</a> Nginx的并发能力</h2><p>看到这里，这个框架的弱点仍然是Nginx结点的并发问题和单点故障。</p><p>对于Nginx的抗并发能力，官方给出的是5w并发量，即轻轻松松处理5w的并发访问。</p><p>对比tomcat，之所以有这么大抗并发，主要原因有两个：</p><p>一是Nginx只做请求和响应的转发而没有业务逻辑处理，大部分的时间花在与其他计算的I/O上；</p><p>二是Nginx的I/O采用的是单线程或少线程、异步非阻塞的模式（Tomcat是一个连接一个线程，同步阻 塞的模式），避免了打开I/O通道等待数据传输的过程（仅仅是在数据传到了，再来接收即可），极大 的缩短了线程调度和I/O处理的时间。</p><h2 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> MySQL</h2><p>MySQL数据库查询能力</p><p>主键查询：千万级别数据 = 1~10 ms ， 4核心 8线程 为 1000qps* 8=8000qps</p><p>唯一索引查询：千万级别数据 = 10~100 ms ， 4核心 8线程 为 100qps* 8=800qps</p><p>非唯一索引查询：千万级别数据 = 100~1000 ms ， 4核心 8线程 为 10qps* 8=80qps</p><p>无索引：百万条数据 = 1000 ms+</p><p>综合来说，mysql的并发能力，大概在1500qps左右</p><h2 id="springcloud-gateway" tabindex="-1"><a class="header-anchor" href="#springcloud-gateway" aria-hidden="true">#</a> Springcloud Gateway</h2><p>单节点可以按照 预估。 一次8核8G压测结果： 并发数：300； netty工作线程数（reactor.netty.ioWorkerCount）：8（默认） 样本数据：返回1.5k大小 服务端响应时间：10ms左右 测试时长：5分钟 JVM内存：2G</p><p>5000 ~ 10000 QPS</p><h2 id="_10w用户-各层的部署架构" tabindex="-1"><a class="header-anchor" href="#_10w用户-各层的部署架构" aria-hidden="true">#</a> 10W用户 各层的部署架构</h2><p><img src="`+r+'" alt="" loading="lazy"></p><h2 id="_100w用户的各层的部署架构" tabindex="-1"><a class="header-anchor" href="#_100w用户的各层的部署架构" aria-hidden="true">#</a> 100W用户的各层的部署架构</h2><p>1080qps</p><p>1000W用户的各层的部署架构</p><p>10800qps</p><p>10000W用户的各层的部署架构</p><p>108000qps</p><p><img src="'+d+'" alt="" loading="lazy"></p>',141),t=[n];function c(s,o){return a(),e("div",null,t)}const l=p(i,[["render",c],["__file","gbf.html.vue"]]);export{l as default};

import{_ as o,X as r,Y as l,Z as t,a1 as e,$ as a,a2 as s,C as i}from"./framework-0b23a550.js";const d="/assets/acid-0bd61517.png",c="/assets/acid-2-de1d4cb2.png",p="/assets/dirty-753c5b62.png",h="/assets/lost-to-modify-2177acdd.png",g="/assets/unrepeat-read-5b57be83.png",u="/assets/phantom-read-010c7748.png",m={},y=s(`<div class="hint-container tip"><p class="hint-container-title">参考</p></div><h2 id="mysql-事务" tabindex="-1"><a class="header-anchor" href="#mysql-事务" aria-hidden="true">#</a> MySQL 事务</h2><h3 id="何谓事务" tabindex="-1"><a class="header-anchor" href="#何谓事务" aria-hidden="true">#</a> 何谓事务？</h3><p>我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：</p><ul><li>数据库中途突然因为某些原因挂掉了。</li><li>客户端突然因为网络原因连接不上数据库了。</li><li>并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。</li><li>......</li></ul><p>上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。</p><p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p><ol><li>将小明的余额减少 1000 元</li><li>将小红的余额增加 1000 元。</li></ol><p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p><h3 id="何谓数据库事务" tabindex="-1"><a class="header-anchor" href="#何谓数据库事务" aria-hidden="true">#</a> 何谓数据库事务？</h3><p>大多数情况下，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p><p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p><p><strong>那数据库事务有什么作用呢？</strong></p><p>简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment"># 开启一个事务</span>
<span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token comment"># 多条 SQL 语句</span>
SQL1<span class="token punctuation">,</span>SQL2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">## 提交事务</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p><p><img src="`+d+'" alt="ACID" loading="lazy"></p><ol><li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol>',19),A=t("strong",null,"只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！",-1),k={href:"https://time.geekbang.org/opencourse/intro/100064201",target:"_blank",rel:"noopener noreferrer"},b=s('<p><img src="'+c+'" alt="" loading="lazy"></p><h3 id="并发事务带来了哪些问题" tabindex="-1"><a class="header-anchor" href="#并发事务带来了哪些问题" aria-hidden="true">#</a> 并发事务带来了哪些问题?</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><h4 id="脏读-dirty-read" tabindex="-1"><a class="header-anchor" href="#脏读-dirty-read" aria-hidden="true">#</a> 脏读（Dirty read）</h4><p><u>一个事务读取了另一个事务未提交的数据</u></p><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</p><p><img src="'+p+'" alt="" loading="lazy"></p><h4 id="丢失修改-lost-to-modify" tabindex="-1"><a class="header-anchor" href="#丢失修改-lost-to-modify" aria-hidden="true">#</a> 丢失修改（Lost to modify）</h4><p><u>两个事务修改了相同的数据</u></p><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p><p><img src="'+h+'" alt="" loading="lazy"></p><h4 id="不可重复读-unrepeatable-read" tabindex="-1"><a class="header-anchor" href="#不可重复读-unrepeatable-read" aria-hidden="true">#</a> 不可重复读（Unrepeatable read）</h4><p><u>一个事务多次读取同一个数据，却返回不同的结果</u></p><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p><p><img src="'+g+'" alt="" loading="lazy"></p><h4 id="幻读-phantom-read" tabindex="-1"><a class="header-anchor" href="#幻读-phantom-read" aria-hidden="true">#</a> 幻读（Phantom read）</h4><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><p><img src="'+u+'" alt="" loading="lazy"></p><h3 id="不可重复读和幻读有什么区别" tabindex="-1"><a class="header-anchor" href="#不可重复读和幻读有什么区别" aria-hidden="true">#</a> 不可重复读和幻读有什么区别？</h3><ul><li><u>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</u></li><li><u>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</u></li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h3 id="并发事务的控制方式有哪些" tabindex="-1"><a class="header-anchor" href="#并发事务的控制方式有哪些" aria-hidden="true">#</a> 并发事务的控制方式有哪些？</h3><p><code>MySQL </code>中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。<u>锁可以看作是悲观控制的模式</u>，多版本并发控制（<code>MVCC，Multiversion concurrency control</code>）可以看作是<u>乐观控制的模式</u>。</p><p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，<code>MySQL</code> 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><ul><li><u>共享锁（S 锁）：又称读锁</u> ，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><u>排他锁（X 锁）：又称写锁/独占锁</u>，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li></ul><p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁(table-level locking)</strong> 和 <strong>行级锁(row-level locking)</strong> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</p><p><strong>MVCC</strong> 是多版本并发控制方法，即<u>对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本</u>。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p><p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li><code>undo log : undo log </code>用于记录某行数据的多个版本的数据。</li><li><code>read view</code> 和 隐藏字段 : 用来判断当前版本数据的可见性。</li></ul>',34),E={href:"https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html",target:"_blank",rel:"noopener noreferrer"},v=s(`<h3 id="sql-标准定义了哪些事务隔离级别" tabindex="-1"><a class="header-anchor" href="#sql-标准定义了哪些事务隔离级别" aria-hidden="true">#</a> SQL 标准定义了哪些事务隔离级别?</h3><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><hr><table><thead><tr><th style="text-align:center;">隔离级别</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻读</th></tr></thead><tbody><tr><td style="text-align:center;">READ-UNCOMMITTED</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">READ-COMMITTED</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">REPEATABLE-READ</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td></tr><tr><td style="text-align:center;">SERIALIZABLE</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td></tr></tbody></table><h3 id="mysql-的隔离级别是基于锁实现的吗" tabindex="-1"><a class="header-anchor" href="#mysql-的隔离级别是基于锁实现的吗" aria-hidden="true">#</a> MySQL 的隔离级别是基于锁实现的吗？</h3><p>MySQL 的<u>隔离级别基于锁和 MVCC 机制共同实现的</u>。</p><p><code>SERIALIZABLE</code> 隔离级别是通过锁来实现的，</p><p><code>READ-COMMITTED</code> 和 <code>REPEATABLE-READ </code>隔离级别是基于 MVCC 实现的。不过，</p><p><code>SERIALIZABLE</code> 之外的其他隔离级别可能也需要用到锁机制，就比如 <code>REPEATABLE-READ</code> 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h3 id="mysql-的默认隔离级别是什么" tabindex="-1"><a class="header-anchor" href="#mysql-的默认隔离级别是什么" aria-hidden="true">#</a> MySQL 的默认隔离级别是什么?</h3><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">-----------------+</span>
<span class="token operator">|</span> @<span class="token variable">@tx_isolation</span>  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-----------------+</span>
<span class="token operator">|</span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-----------------+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,13),L={href:"https://javaguide.cn/database/mysql/transaction-isolation-level.html",target:"_blank",rel:"noopener noreferrer"};function _(x,C){const n=i("ExternalLinkIcon");return r(),l("div",null,[y,t("p",null,[e("🌈 这里要额外补充一点："),A,e(" 想必大家也和我一样，被 ACID 这个概念被误导了很久! 我也是看周志明老师的公开课"),t("a",k,[e("《周志明的软件架构课》"),a(n)]),e("才搞清楚的（多看好书！！！）。")]),b,t("p",null,[e("关于 InnoDB 对 MVCC 的具体实现可以看这篇文章："),t("a",E,[e("InnoDB 存储引擎对 MVCC 的实现"),a(n)]),e(" 。")]),v,t("p",null,[e("关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章："),t("a",L,[e("MySQL 事务隔离级别详解"),a(n)]),e("。")])])}const S=o(m,[["render",_],["__file","mysql-transaction.html.vue"]]);export{S as default};

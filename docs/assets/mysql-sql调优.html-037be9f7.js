import{_ as a,X as e,Y as o,Z as s,a1 as p,$ as c,a2 as t,C as d}from"./framework-0b23a550.js";const l="/assets/4-a6504ad1.png",r="/assets/5-9c5d6346.png",i="/assets/6-74f2865a.png",u={},k={class:"hint-container tip"},h=s("p",{class:"hint-container-title"},"参考",-1),m={href:"https://dbaplus.cn/news-155-4717-1.html",target:"_blank",rel:"noopener noreferrer"},b=t('<p>mysql内部逻辑图</p><p><img src="'+l+`" alt=" mysql内部逻辑图" loading="lazy"></p><p>1）连接器：主要负责跟客户端建立连接、获取权限、维持和管理连接。</p><p>2）查询缓存：优先在缓存中进行查询，如果查到了则直接返回，如果缓存中查询不到，在去数据库中查询。</p><p>MySQL缓存是默认关闭的，也就是说不推荐使用缓存，并且在MySQL8.0 版本已经将查询缓存的整块功能删掉了。这主要是它的使用场景限制造成的：</p><pre><code>先说下缓存中数据存储格式：key（sql语句）- value（数据值），
所以如果SQL语句（key）只要存在一点不同之处就会直接进行数据库查询了；

由于表中的数据不是一成不变的，大多数是经常变化的，而当数据库中的数据变化了，
那么相应的与此表相关的缓存数据就需要移除掉。
</code></pre><p>3）解析器/分析器：分析器的工作主要是对要执行的SQL语句进行词法解析、语法解析，最终得到抽象语法树，然后再使用预处理器对抽象语法树进行语义校验，判断抽象语法树中的表是否存在，如果存在的话，在接着判断select投影列字段是否在表中存在等。</p><p>4）优化器：主要将SQL经过词法解析、语法解析后得到的语法树，通过数据字典和统计信息的内容，再经过一系列运算 ，最终得出一个执行计划，包括选择使用哪个索引。</p><p>在分析是否走索引查询时，是通过进行动态数据采样统计分析出来；只要是统计分析出来的，那就可能会存在分析错误的情况，所以在SQL执行不走索引时，也要考虑到这方面的因素。</p><p>5）执行器：根据一系列的执行计划去调用存储引擎提供的API接口去调用操作数据，完成SQL的执行。</p><h2 id="sql语句的优化" tabindex="-1"><a class="header-anchor" href="#sql语句的优化" aria-hidden="true">#</a> SQL语句的优化</h2><h3 id="尽量避免使用子查询" tabindex="-1"><a class="header-anchor" href="#尽量避免使用子查询" aria-hidden="true">#</a> 尽量避免使用子查询</h3><p>例：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> id <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> t2 <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;chackca&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其子查询在<code>Mysql5.5</code>版本里，内部执行计划是这样：<u>先查外表再匹配内表，而不是先查内表t2，当外表的数据很大时，查询速度会非常慢</u>。</p><p>在<code>MariaDB10/Mysql5.6</code>版本里，采用join关联方式对其进行了优化，这条SQL语句会<u>自动转换为</u>：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> t1<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">JOIN</span> t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>id <span class="token operator">=</span> t2<span class="token punctuation">.</span>id
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但请注意的是：<u>优化只针对<code>SELECT</code>有效，对<code>UPDATE/DELETE</code>子查询无效，固生产环境应避免使用子查询</u></p><p>由于<code>MySQL</code>的优化器对于子查询的处理能力比较弱，所以不建议使用子查询，可以改写成<code>Inner Join</code>，之所以 <code>join</code> 连接效率更高，是因为 MySQL<u>不需要在内存中创建临时表</u></p><h3 id="用in来替换or" tabindex="-1"><a class="header-anchor" href="#用in来替换or" aria-hidden="true">#</a> 用IN来替换OR</h3><pre><code>低效查询
</code></pre><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">OR</span> id <span class="token operator">=</span> <span class="token number">20</span> <span class="token operator">OR</span> id <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><pre><code>高效查询
</code></pre><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t <span class="token keyword">WHERE</span> id <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另外，MySQL对于<code>IN</code>做了相应的优化，即将<code>IN</code>中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> id <span class="token keyword">from</span> table_name <span class="token keyword">where</span> num <span class="token operator">in</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对于<u>连续的数值，能用 between 就不要用 in 了；再或者使用连接来替换。</u></p><h2 id="读取适当的记录limit-m-n-而不要读多余的记录" tabindex="-1"><a class="header-anchor" href="#读取适当的记录limit-m-n-而不要读多余的记录" aria-hidden="true">#</a> 读取适当的记录LIMIT M,N，而不要读多余的记录</h2><pre><code>limit N : 返回 N 条记录
offset M : 跳过 M 条记录, 默认 M=0, 单独使用似乎不起作用
limit N,M : 相当于 limit M offset N , 从第 N 条记录开始, 返回 M 条记录 
</code></pre><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> id<span class="token punctuation">,</span>name <span class="token keyword">from</span> t <span class="token keyword">limit</span> <span class="token number">866613</span><span class="token punctuation">,</span> <span class="token number">20</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用上述<code>sql</code>语句做分页的时候，可能有人会发现，随着<u>表数据量的增加，直接使用limit分页查询会越来越慢</u>。</p><p>对于 <code>limit m, n </code>的分页查询，越往后面翻页（即m越大的情况下）SQL的耗时会越来越长，对于这种应该先取出主键id，然后通过主键id跟原表进行Join关联查询。因为MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。</p><p>优化的方法如下：可以取前一页的最大行数的id（将上次遍历到的最末尾的数据ID传给数据库，然后直接定位到该ID处，再往后面遍历数据），然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。sql可以采用如下的写法：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> id<span class="token punctuation">,</span>name <span class="token keyword">from</span> table_name <span class="token keyword">where</span> id<span class="token operator">&gt;</span> <span class="token number">866612</span> <span class="token keyword">limit</span> <span class="token number">20</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="禁止不必要的order-by-排序" tabindex="-1"><a class="header-anchor" href="#禁止不必要的order-by-排序" aria-hidden="true">#</a> 禁止不必要的Order By 排序</h3><pre><code>如果我们对结果没有排序的要求，就尽量少用排序；

如果排序字段没有用到索引，也尽量少用排序；
</code></pre><p>另外，分组统计查询时可以禁止其默认排序</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> goods_id<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> t <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> goods_id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>默认情况下，Mysql会对所有的<code>GROUP BT col1,col2…</code>的字段进行排序，也就是说上述会对 goods_id进行排序，如果想要避免排序结果的消耗，可以指定<code>ORDER BY NULL</code>禁止排序：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> goods_id<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> t <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> goods_id <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token boolean">NULL</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="总和查询可以禁止排重用union-all" tabindex="-1"><a class="header-anchor" href="#总和查询可以禁止排重用union-all" aria-hidden="true">#</a> 总和查询可以禁止排重用union all</h3><p><code>union</code>和<code>union all</code>的差异主要是<u>前者</u>需要将结<u>果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟</u>。</p><p>当然，<code>union all</code> 的前提条件是两个结果集没有重复数据。所以一般是我们明确知道不会出现重复数据的时候才建议使用 <code>union all </code>提高速度。</p><h3 id="避免随机取记录" tabindex="-1"><a class="header-anchor" href="#避免随机取记录" aria-hidden="true">#</a> 避免随机取记录</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> RAND<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">LIMIT</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t1 <span class="token keyword">WHERE</span> id <span class="token operator">&gt;=</span> CEIL<span class="token punctuation">(</span>RAND<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token keyword">LIMIT</span> <span class="token number">4</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>以上两个语句都无法用到索引</p><h3 id="将多次插入换成批量insert插入" tabindex="-1"><a class="header-anchor" href="#将多次插入换成批量insert插入" aria-hidden="true">#</a> 将多次插入换成批量Insert插入</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t<span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;aaa&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t<span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;bbb&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t<span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;ccc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       —<span class="token operator">&gt;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> t<span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;aaa&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;bbb&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;ccc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="只返回必要的列-用具体的字段列表代替-select-语句" tabindex="-1"><a class="header-anchor" href="#只返回必要的列-用具体的字段列表代替-select-语句" aria-hidden="true">#</a> 只返回必要的列，用具体的字段列表代替 select * 语句</h3><p><code>SELECT * </code>会增加很多不必要的消耗（<code>cpu、io、内存、网络带宽</code>）；增加了使用覆盖索引的可能性；当表结构发生改变时，前者也需要经常更新。所以要求直接在<code>select</code>后面接上字段名。</p><p><code>MySQL</code>数据库是按照行的方式存储，而数据存取操作都是以一个页大小进行<code>IO</code>操作的，每个IO单元中存储了多行，每行都是存储了该行的所有字段。所以无论取一个字段还是多个字段，实际上数据库在表中需要访问的数据量其实是一样的。</p><p>但是如果查询的字段都在索引中，也就是覆盖索引，那么可以直接从索引中获取对应的内容直接返回，不需要进行回表，减少<code>IO</code>操作。除此之外，当存在 <code>order by </code>操作的时候，<code>select</code> 子句中的字段多少会在很大程度上影响到我们的排序效率。</p><h3 id="区分in和exists" tabindex="-1"><a class="header-anchor" href="#区分in和exists" aria-hidden="true">#</a> 区分in和exists</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 表A <span class="token keyword">where</span> id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> 表B<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的语句相当于：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 表A <span class="token keyword">where</span> <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 表B <span class="token keyword">where</span> 表B<span class="token punctuation">.</span>id<span class="token operator">=</span>表A<span class="token punctuation">.</span>id<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>区分<code>in</code>和<code>exists</code>主要是造成了<code>驱动顺序</code>的改变（这是性能变化的关键），如果是<code>exists</code>， 那么<code>以外层表为驱动表</code>，<code>先被访问</code>，如果是<code>IN</code>，那么<code>先执行子查询</code>。所以<code>IN</code>适合于<code>外表大而内表小</code>的情况； <code>EXISTS</code>适合于<code>外表小而内表大</code>的情况。</p><p>另外，<code>in</code>查询在某些情况下有可能会查询返回错误的结果，因此， 通常是<u>建议在确定且有限的集合时，可以使用<code>in</code>。如 <code>IN （0，1，2）</code></u>。</p><h3 id="优化group-by语句" tabindex="-1"><a class="header-anchor" href="#优化group-by语句" aria-hidden="true">#</a> 优化Group By语句</h3><p>如果对<code>group by</code>语句的结果没有排序要求，要在语句后面加 <code>order by null</code>（<code>group</code> 默认会排序）；</p><p>尽量让<code>group by</code>过程用上表的索引，确认方法是<code>explain</code>结果里没有<code>Using temporary 和 Using filesort</code>；</p><p>如果<code>group by</code>需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大<code>tmp_table_size</code>参数，来避免用到磁盘临时表；</p><pre><code>如果数据量实在太大，使用SQL_BIG_RESULT这个提示，来告诉优化器直接使用排序算法（直接用磁盘临时表）得到group by的结果。
</code></pre><p>使用<code>where</code>子句替换<code>Having子</code>句：避免使用<code>having</code>子句，<code>having</code>只会在检索出所有记录之后才会对结果集进行过滤，这个处理需要排序分组，如果能通过<code>where</code>子句提前过滤查询的数目，就可以减少这方面的开销。</p><pre><code>低效
</code></pre><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> JOB<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>SAL<span class="token punctuation">)</span> <span class="token keyword">FROM</span> EMP <span class="token keyword">GROUP</span> <span class="token keyword">by</span> 
JOB <span class="token keyword">HAVING</span> JOB <span class="token operator">=</span> ‘PRESIDENT’ <span class="token operator">OR</span> JOB <span class="token operator">=</span> ‘MANAGER’
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><pre><code>高效
</code></pre><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> JOB<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>SAL<span class="token punctuation">)</span> <span class="token keyword">FROM</span> EMP <span class="token keyword">WHERE</span> 
JOB <span class="token operator">=</span> ‘PRESIDENT’ <span class="token operator">OR</span> JOB <span class="token operator">=</span> ‘MANAGER’ <span class="token keyword">GROUP</span> <span class="token keyword">by</span> JOB
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="尽量使用数字型字段" tabindex="-1"><a class="header-anchor" href="#尽量使用数字型字段" aria-hidden="true">#</a> 尽量使用数字型字段</h3><p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能。 引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><h3 id="优化join语句" tabindex="-1"><a class="header-anchor" href="#优化join语句" aria-hidden="true">#</a> 优化Join语句</h3><p>当我们执行两个表的<code>Join</code>的时候，就会有一个比较的过程，逐条比较两个表的语句是比较慢的， 因此可以把两个表中数据依次读进一个内存块中，在Mysql中执行：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> ‘join_buffer_size’
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以看到·在内存中的缓存池大小，其大小将会影响join语句的性能。在执行<code>join</code>的时候， 数据库会选择一个表把他要返回以及需要进行和其他表进行比较的数据放进<code>join_buffer</code>。</p><p><u>什么是驱动表，什么是被驱动表，</u>这两个概念在查询中有时容易让人搞混，有下面几种情况，大家需要了解。</p><p>1）当连接查询没有where条件时</p><pre><code>left join 前面的表是驱动表，后面的表是被驱动表

right join 后面的表是驱动表，前面的表是被驱动表

inner join / join 会自动选择表数据比较少的作为驱动表

straight_join(≈join) 直接选择左边的表作为驱动表
（语义上与join类似，但去除了join自动选择小表作为驱动表的特性）
</code></pre><p>2）当连接查询有where条件时，带where条件的表是驱动表，否则是被驱动表</p><p>假设有表如右边：t1与t2表完全一样，a字段有索引，b无索引，t1有100条数据，t2有1000条数据</p><p>若被驱动表有索引，那么其执行算法为：Index Nested-Loop Join（NLJ），示例如下：</p><p>①执行语句：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>a<span class="token operator">=</span>t2<span class="token punctuation">.</span>a<span class="token punctuation">)</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于被驱动表<code>t2.a</code>是有索引的，其执行逻辑如下：</p><pre><code>从表t1中读入一行数据 R

从数据行R中，取出a字段到表t2里去查找

取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分

重复执行步骤1到3，直到表t1的末尾循环结束

如果一条\`join\`语句的\`Extra\`字段什么都没写的话，就表示使用的是NLJ算法
</code></pre><p><img src="`+r+`" alt="" loading="lazy"></p><p>若被驱动表无索引，那么其执行算法为：Block Nested-Loop Join（BLJ）（Block 块，每次都会取一块数据到内存以减少I/O的开销），示例如下：</p><p>②执行语句：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1 straight_join t2 <span class="token keyword">on</span> <span class="token punctuation">(</span>t1<span class="token punctuation">.</span>a<span class="token operator">=</span>t2<span class="token punctuation">.</span>b<span class="token punctuation">)</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于被驱动表t2.b是没有索引的，其执行逻辑如下：</p><pre><code>把驱动表t1的数据读入线程内存join_buffer（无序数组）中，
由于我们这个语句中写的是select *，因此是把整个表t1放入了内存；

顺序遍历表t2，把表t2中的每一行取出来，跟join_buffer中的数据做对比，满足join条件的，作为结果集的一部分返回。
</code></pre><h3 id="尽可能减少join语句中的nestedloop的循环次数-永远用小结果集驱动大的结果集" tabindex="-1"><a class="header-anchor" href="#尽可能减少join语句中的nestedloop的循环次数-永远用小结果集驱动大的结果集" aria-hidden="true">#</a> 尽可能减少Join语句中的NestedLoop的循环次数：“永远用小结果集驱动大的结果集”</h3><p>用小结果集驱动大结果集，将筛选结果小的表（在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”）首先连接，再去连接结果集比较大的表，尽量减少join语句中的Nested Loop的循环总次数</p><p>优先优化<code>Nested Loop</code>的内层循环（也就是最外层的Join连接），因为内层循环是循环中执行次数最多的，每次循环提升很小的性能都能在整个循环中提升很大的性能；</p><p>对被驱动表的<code>join</code>字段上建立索引；</p><p>当被驱动表的<code>join</code>字段上无法建立索引的时候，设置足够的<code>Join Buffer Size。</code></p><p>尽量用<code>inner join</code>(因为其会自动选择小表去驱动大表).</p><p>避免 <code>LEFT JOIN </code>(一般我们使用<code>Left Join</code>的场景是大表驱动小表)和NULL，那么如何优化<code>Left Join</code>呢？</p><p>条件中尽量能够过滤一些行将驱动表变得小一点，用小表去驱动大表</p><p>右表的条件列一定要加上索引（<code>主键、唯一索引、前缀索引</code>等），最好能够使<code>type</code>达到<code>range</code>及以上<code>（ref,eq_ref,const,system）</code></p><p>适当地在表里面添加冗余信息来减少<code>join</code>的次数</p><p>使用更快的固态硬盘</p><p>性能优化，<code>left join</code> 是由左边决定的，左边一定都有，所以右边是我们的关键点，建立索引要建在右边。 当然如果索引是在左边的，我们可以考虑使用右连接，如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> atable <span class="token keyword">left</span> <span class="token keyword">join</span> btable <span class="token keyword">on</span> atable<span class="token punctuation">.</span>aid<span class="token operator">=</span>btable<span class="token punctuation">.</span>bid<span class="token punctuation">;</span>
<span class="token comment">-- 最好在bid上建索引</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">提示</p><p>Join左连接在右边建立索引； 组合索引则尽量将数据量大的放在左边，在左边建立索引。</p></div><h2 id="索引的优化-如何避免索引失效" tabindex="-1"><a class="header-anchor" href="#索引的优化-如何避免索引失效" aria-hidden="true">#</a> 索引的优化/如何避免索引失效</h2><h3 id="最佳左前缀法则" tabindex="-1"><a class="header-anchor" href="#最佳左前缀法则" aria-hidden="true">#</a> 最佳左前缀法则</h3><p>如果索引了多列，要遵守最左前缀法则，指的是查询从索引的最左前列开始并且不跳过索引中的列。 <code>Mysql</code>查询优化器会对查询的字段进行改进，判断查询的字段以哪种形式组合能使得查询更快， 所有比如创建的是<code>(a,b)</code>索引，查询的是<code>(b,a)</code>，查询优化器会修改成<code>(a,b)</code>后使用索引查询。</p><h2 id="不在索引列上做任何操作" tabindex="-1"><a class="header-anchor" href="#不在索引列上做任何操作" aria-hidden="true">#</a> 不在索引列上做任何操作</h2><p>1）计算：对索引进行表达式计算会导致索引失效，如 <code>where id + 1 = 10</code>，可以转换成 <code>where id = 10 -1</code>，这样就可以走索引</p><p>2）函数：<code>select * from t_user where length(name)=6;</code> 此语句对字段使用到了函数，会导致索引失效</p><p>从 <code>MySQL 8.0</code> 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引， 也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">alter</span> <span class="token keyword">table</span> t_user <span class="token keyword">add</span> <span class="token keyword">key</span> idx_name_length <span class="token punctuation">(</span><span class="token punctuation">(</span>length<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（自动/手动）类型转换</p><p>（<u>字符串类型必须带&#39;&#39;引号才能使索引生效</u>）字段是varchar，用整型进行查询时，无法走索引， 如</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> phone <span class="token operator">=</span> <span class="token number">13030303030</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>Mysql</code> 在执行上述语句时，会把字段转换为数字再进行比较，所以上面那条语句就相当于：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> CAST<span class="token punctuation">(</span>phone <span class="token keyword">AS</span> signed <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">13030303030</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>CAST</code> 函数是作用在了 <code>phone</code> 字段，而 <code>phone</code> 字段是索引，也就是对索引使用了函数！所以索引失效</p><p>字段是<code>int</code>，用<code>string</code>进行查询时，<code>mysql</code>会自动转化，可以走索引，如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">&#39;1&#39;</span>；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>MySQL</code> 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。以上这条语句相当于：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id <span class="token operator">=</span> CAST<span class="token punctuation">(</span>“<span class="token number">1</span>” <span class="token keyword">AS</span> signed <span class="token keyword">int</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的。</p><h3 id="存储引擎不能使用索引中范围条件右边的列。" tabindex="-1"><a class="header-anchor" href="#存储引擎不能使用索引中范围条件右边的列。" aria-hidden="true">#</a> 存储引擎不能使用索引中范围条件右边的列。</h3><p>如这样的<code>sql</code>:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> username<span class="token operator">=</span><span class="token string">&#39;123&#39;</span> <span class="token operator">and</span> age<span class="token operator">&gt;</span><span class="token number">20</span> <span class="token operator">and</span> phone<span class="token operator">=</span><span class="token string">&#39;1390012345&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中<code>username, age, phone</code>都有索引，<u>只有<code>username</code>和<code>age</code>会生效，<code>phone</code>的索引没有用到</u>。</p><h3 id="尽量使用覆盖索引-只访问索引的查询-索引列和查询列一致" tabindex="-1"><a class="header-anchor" href="#尽量使用覆盖索引-只访问索引的查询-索引列和查询列一致" aria-hidden="true">#</a> 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致））</h3><p>如<code>select age from user，减少select *</code></p><h3 id="mysql在使用负向查询条件-、-、not-in、not-exists、not-like-的时候无法使用索引会导致全表扫描。" tabindex="-1"><a class="header-anchor" href="#mysql在使用负向查询条件-、-、not-in、not-exists、not-like-的时候无法使用索引会导致全表扫描。" aria-hidden="true">#</a> mysql在使用负向查询条件(!=、&lt;&gt;、not in、not exists、not like)的时候无法使用索引会导致全表扫描。</h3><p>你可以想象一下，对于一棵B+树，根节点是40，如果你的条件是等于20，就去左面查，你的条件等于50，就去右面查，但是你的条件是不等于66，索引应该咋办？还不是遍历一遍才知道。</p><h3 id="is-null-is-not-null-也无法使用索引-在实际中尽量不要使用null-避免在-where-子句中对字段进行-null-值判断-不过在mysql的高版本已经做了优化-允许使用索引" tabindex="-1"><a class="header-anchor" href="#is-null-is-not-null-也无法使用索引-在实际中尽量不要使用null-避免在-where-子句中对字段进行-null-值判断-不过在mysql的高版本已经做了优化-允许使用索引" aria-hidden="true">#</a> is null, is not null 也无法使用索引，在实际中尽量不要使用null（避免在 where 子句中对字段进行 null 值判断） 不过在mysql的高版本已经做了优化，允许使用索引</h3><p>对于<code>null</code>的判断会导致引擎放弃使用索引而进行全表扫描。</p><h3 id="like-以通配符开头-abc-时-mysql索引失效会变成全表扫描的操作。" tabindex="-1"><a class="header-anchor" href="#like-以通配符开头-abc-时-mysql索引失效会变成全表扫描的操作。" aria-hidden="true">#</a> like 以通配符开头(%abc..)时，mysql索引失效会变成全表扫描的操作。</h3><p>所以最好用右边<code>like ‘abc%’</code>。如果两边都要用，可以用</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> username <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> username <span class="token operator">like</span> <span class="token string">&#39;%abc%&#39;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中username是必须是索引列，才可让索引生效</p><p>假如i<code>ndex(a,b,c)</code>,<code> where a=3 and b like ‘abc%’ and c=4</code>，<code>a能用，b能用，c不能用</code>，类似于不能使用范围条件右边的列的索引</p><p>对于一棵B+树索引来讲，如果根节点是字符def，假如查询条件的通配符在后面，例如abc%，则其知道应该搜索左子树，假如传入为efg%，则应该搜索右子树，如果通配符在前面%abc，则数据库不知道应该走哪一面，就都扫描一遍了。</p><h3 id="少用or-在-where-子句中-如果在-or-前的条件列是索引列-而在-or-后的条件列不是索引列-那么索引会失效。" tabindex="-1"><a class="header-anchor" href="#少用or-在-where-子句中-如果在-or-前的条件列是索引列-而在-or-后的条件列不是索引列-那么索引会失效。" aria-hidden="true">#</a> 少用or，在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">or</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>
 <span class="token comment">-- id有索引，name没有，此时没法走索引</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p><p>必须要or前后的字段都有索引，查询才能使用上索引（分别使用，最后合并结果<code>type = index_merge</code>）</p><p><img src="`+i+`" alt="" loading="lazy"></p><h3 id="在组合-联合索引中-将有区分度的索引放在前面" tabindex="-1"><a class="header-anchor" href="#在组合-联合索引中-将有区分度的索引放在前面" aria-hidden="true">#</a> 在组合/联合索引中，将有区分度的索引放在前面</h3><p>如果没有区分度，例如用性别，相当于把整个大表分成两部分，查找数据还是需要遍历半个表才能找到，使得索引失去了意义。</p><h3 id="使用前缀索引" tabindex="-1"><a class="header-anchor" href="#使用前缀索引" aria-hidden="true">#</a> 使用前缀索引</h3><p><code>短索引</code>不仅可以提高查询性能而且可以节省磁盘空间和I/O操作，减少索引文件的维护开销，但缺点是不能用于 <code>ORDER BY</code> 和 <code>GROUP BY </code>操作，也不能用于覆盖索引。</p><p>比如有一个<code>varchar(255)</code>的列，如果该列在前10个或20个字符内，可以做到既使前缀索引的区分度接近全列索引， 那么就不要对整个列进行索引。为了减少<code>key_len</code>，可以考虑创建前缀索引，即指定一个前缀长度，可以使用 <code>count(distinct leftIndex(列名, 索引长度))/count(*) </code>来计算前缀索引的区分度。</p><h3 id="sql-性能优化-explain-中的-type-至少要达到-range-级别-要求是-ref-级别-如果可以是-consts-最好。" tabindex="-1"><a class="header-anchor" href="#sql-性能优化-explain-中的-type-至少要达到-range-级别-要求是-ref-级别-如果可以是-consts-最好。" aria-hidden="true">#</a> SQL 性能优化 explain 中的 type：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。</h3><pre><code>consts：单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
ref：使用普通的索引
range：对索引进行范围检索
</code></pre><p>当 type=index 时，索引物理文件全扫，速度非常慢。</p>`,152);function v(y,g){const n=d("ExternalLinkIcon");return e(),o("div",null,[s("div",k,[h,s("p",null,[s("a",m,[p("掌握这12个SQL优化方法，你基本上就无敌了"),c(n)])])]),b])}const q=a(u,[["render",v],["__file","mysql-sql调优.html.vue"]]);export{q as default};

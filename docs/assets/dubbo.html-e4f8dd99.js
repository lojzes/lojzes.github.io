import{_ as t,X as o,Y as i,Z as a,a1 as e,$ as s,a2 as p,C as r}from"./framework-0b23a550.js";const l="/assets/1-3f9951b0.png",c="/assets/2-fd78dfd7.png",u={},d={class:"hint-container tip"},b=a("p",{class:"hint-container-title"},"参考",-1),h={href:"https://www.cnblogs.com/yougewe/p/12734558.html",target:"_blank",rel:"noopener noreferrer"},k={href:"https://blog.51cto.com/u_15127568/4356830",target:"_blank",rel:"noopener noreferrer"},v={href:"https://juejin.cn/post/6844904127076499463",target:"_blank",rel:"noopener noreferrer"},g=p(`<h2 id="负载均衡" tabindex="-1"><a class="header-anchor" href="#负载均衡" aria-hidden="true">#</a> 负载均衡</h2><p><code>Dubbo</code>官方为我们提供了四种负载均衡策略，分别是<code>随机策略、轮询策略、最少活跃调用数策略</code>和<code>一致性 Hash策略</code>。如果我们不指定负载均衡策略，默认情况下为<code>随机策略</code>。</p><ul><li><p>RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的默认负载均衡策略。</p></li><li><p>RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。</p></li><li><p>LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机。活跃数指调用前后计数差。使慢的 Provider 收到更少请求，因为越慢的 Provider 的调用前后计数差会越大。</p></li><li><p>ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。</p></li></ul><h2 id="如何配置dubbo负载均衡策略" tabindex="-1"><a class="header-anchor" href="#如何配置dubbo负载均衡策略" aria-hidden="true">#</a> 如何配置dubbo负载均衡策略？</h2><p>有多种级别的配置：服务端服务/方法级别、客户端服务/方法级别; 具体配置如下:</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token comment">&lt;!-- 服务端服务级别 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>...<span class="token punctuation">&quot;</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>roundrobin<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token comment">&lt;!-- 客户端服务级别 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>...<span class="token punctuation">&quot;</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>roundrobin<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token comment">&lt;!-- 服务端方法级别 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>service</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>...<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>hello<span class="token punctuation">&quot;</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>roundrobin<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">dubbo:</span>service</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 客户端方法级别 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>reference</span> <span class="token attr-name">interface</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>...<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">dubbo:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>hello<span class="token punctuation">&quot;</span></span> <span class="token attr-name">loadbalance</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>roundrobin<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">dubbo:</span>reference</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="dubbo-核心功能有哪些" tabindex="-1"><a class="header-anchor" href="#dubbo-核心功能有哪些" aria-hidden="true">#</a> Dubbo 核心功能有哪些？</h2><ul><li>Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。</li><li>Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li>Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ul><h2 id="dubbo-核心组件有哪些" tabindex="-1"><a class="header-anchor" href="#dubbo-核心组件有哪些" aria-hidden="true">#</a> Dubbo 核心组件有哪些？</h2><p><img src="`+l+`" alt="" loading="lazy"></p><pre><code>Provider：暴露服务的服务提供方
Consumer：调用远程服务消费方
Registry：服务注册与发现注册中心
Monitor：监控中心和访问调用统计
Container：服务运行容器
</code></pre><h2 id="dubbo-服务器注册与发现的流程" tabindex="-1"><a class="header-anchor" href="#dubbo-服务器注册与发现的流程" aria-hidden="true">#</a> Dubbo 服务器注册与发现的流程？</h2><ul><li>服务容器 Container 负责启动，加载，运行服务提供者。</li><li>服务提供者 Provider 在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者 Consumer 在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心 Registry 返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者 Consumer，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者 Consumer 和提供者 Provider，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 Monitor。</li></ul><h2 id="dubbo-的整体架构设计有哪些分层" tabindex="-1"><a class="header-anchor" href="#dubbo-的整体架构设计有哪些分层" aria-hidden="true">#</a> Dubbo 的整体架构设计有哪些分层?</h2><p><img src="`+c+`" alt="" loading="lazy"></p><ul><li>接口服务层（Service）：该层与业务逻辑相关，根据 provider 和 consumer 的业务设计对应的接口和实现</li><li>配置层（Config）：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心</li><li>服务代理层（Proxy）：服务接口透明代理，生成服务的客户端 Stub 和 服务端的 Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li><li>服务注册层（Registry）：封装服务地址的注册和发现，以服务 URL 为中心，扩展接口为 RegistryFactory、Registry、RegistryService</li><li>路由层（Cluster）：封装多个提供者的路由和负载均衡，并桥接注册中心，以Invoker 为中心，扩展接口为 Cluster、Directory、Router 和 LoadBlancce</li><li>监控层（Monitor）：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory、Monitor 和 MonitorService</li><li>远程调用层（Protocal）：封装 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocal、Invoker 和 Exporter</li><li>信息交换层（Exchange）：封装请求响应模式，同步转异步。以 Request 和Response 为中心，扩展接口为 Exchanger、ExchangeChannel、ExchangeClient 和 ExchangeServer</li><li>网络 传输 层（Transport）：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel、Transporter、Client、Server 和 Codec</li><li>数据序列化层（Serialize）：可复用的一些工具，扩展接口为 Serialization、ObjectInput、ObjectOutput 和 ThreadPool</li></ul><h2 id="dubbo-和-spring-cloud-有什么关系" tabindex="-1"><a class="header-anchor" href="#dubbo-和-spring-cloud-有什么关系" aria-hidden="true">#</a> Dubbo 和 Spring Cloud 有什么关系？</h2><p>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。</p><p>而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spring、Spring Boot 的优势之上，</p><p>两个框架在开始目标就不一致，Dubbo 定位服务治理、Spring Cloud 是打造一个生态。</p><h2 id="dubbo-和-spring-cloud-有什么哪些区别" tabindex="-1"><a class="header-anchor" href="#dubbo-和-spring-cloud-有什么哪些区别" aria-hidden="true">#</a> Dubbo 和 Spring Cloud 有什么哪些区别？</h2><p>Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于 TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。</p><p>Spring Cloud 是基于 Http 协议 Rest 接口调用远程过程的通信，相对来说 Http 请求会有更大的报文，占的带宽也会更多。但是 REST 相比</p><p>RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重</p><p>通信速度还是方便灵活性，具体情况具体考虑。</p><h2 id="dubbo-有哪些注册中心" tabindex="-1"><a class="header-anchor" href="#dubbo-有哪些注册中心" aria-hidden="true">#</a> Dubbo 有哪些注册中心？</h2><ul><li>Multicast 注册中心：Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现,基于网络中组播传输实现。</li><li>Zookeeper 注册中心：基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 watch 机制实现数据变更。</li><li>Redis 注册中心：基于 Redis 实现，采用 key/map 存储，key 存储服务名和类型，map 中 key 存储服务 url，value 服务过期时间。基于 Redis 的发布/订阅模式通知数据变更。</li><li>Simple 注册中心。 推荐使用 Zookeeper 作为注册中心</li></ul><h2 id="dubbo-的注册中心集群挂掉-发布者和订阅者之间还能通信么" tabindex="-1"><a class="header-anchor" href="#dubbo-的注册中心集群挂掉-发布者和订阅者之间还能通信么" aria-hidden="true">#</a> Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？</h2><p>可以通讯。启动 Dubbo 时，消费者会从 Zookeeper 拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。</p><h2 id="dubbo集群提供了哪些负载均衡策略" tabindex="-1"><a class="header-anchor" href="#dubbo集群提供了哪些负载均衡策略" aria-hidden="true">#</a> Dubbo集群提供了哪些负载均衡策略？</h2><ul><li>Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。</li><li>RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题。</li><li>LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求。</li><li>ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。</li></ul><p>默认为 Random 随机调用。</p><h2 id="dubbo的集群容错方案有哪些" tabindex="-1"><a class="header-anchor" href="#dubbo的集群容错方案有哪些" aria-hidden="true">#</a> Dubbo的集群容错方案有哪些？</h2><ul><li>Failover Cluster：失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。</li><li>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li>Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li>Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2″ 来设置最大并行数。</li><li>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li></ul><p>默认的容错方案是 Failover Cluster。</p><h2 id="dubbo-配置文件是如何加载到-spring-中的" tabindex="-1"><a class="header-anchor" href="#dubbo-配置文件是如何加载到-spring-中的" aria-hidden="true">#</a> Dubbo 配置文件是如何加载到 Spring 中的？</h2><p>Spring 容器在启动的时候，会读取到 Spring 默认的一些 schema 以及 Dubbo 自定义的 schema，每个 schema 都会对应一个自己的 NamespaceHandler，NamespaceHandler 里面通过 BeanDefinitionParser 来解析配置信息并转化为需要加载的 bean 对象！</p><h2 id="dubbo-超时设置有哪些方式" tabindex="-1"><a class="header-anchor" href="#dubbo-超时设置有哪些方式" aria-hidden="true">#</a> Dubbo 超时设置有哪些方式？</h2><h3 id="dubbo-超时设置有两种方式" tabindex="-1"><a class="header-anchor" href="#dubbo-超时设置有两种方式" aria-hidden="true">#</a> Dubbo 超时设置有两种方式：</h3><p>服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。</p><p>服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。</p><h3 id="服务调用超时会怎么样" tabindex="-1"><a class="header-anchor" href="#服务调用超时会怎么样" aria-hidden="true">#</a> 服务调用超时会怎么样？</h3><p>dubbo 在调用服务不成功时，默认是会重试两次。</p><h2 id="通信协议" tabindex="-1"><a class="header-anchor" href="#通信协议" aria-hidden="true">#</a> 通信协议</h2><h3 id="dubbo-使用的是什么通信框架" tabindex="-1"><a class="header-anchor" href="#dubbo-使用的是什么通信框架" aria-hidden="true">#</a> Dubbo 使用的是什么通信框架?</h3><pre><code>默认使用 Netty 作为通讯框架。
</code></pre><h3 id="dubbo-支持哪些协议-它们的优缺点有哪些" tabindex="-1"><a class="header-anchor" href="#dubbo-支持哪些协议-它们的优缺点有哪些" aria-hidden="true">#</a> Dubbo 支持哪些协议，它们的优缺点有哪些？</h3><ul><li><p>Dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步 Hessian 序列化。Dubbo推荐使用dubbo协议。</p></li><li><p>RMI： 采用 JDK 标准的 RMI 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 Java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接 TCP 协议传输，同步传输，适用常规的远程服务调用和 RMI 互操作。在依赖低版本的 Common-Collections 包，Java 序列化存在安全漏洞。</p></li><li><p>WebService：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用。</p></li><li><p>HTTP： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用。</p></li><li><p>Hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。</p></li><li><p>Memcache：基于 Memcache实现的 RPC 协议。</p></li><li><p>Redis：基于 Redis 实现的RPC协议。</p></li></ul><h2 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h2><h3 id="dubbo-用到哪些设计模式" tabindex="-1"><a class="header-anchor" href="#dubbo-用到哪些设计模式" aria-hidden="true">#</a> Dubbo 用到哪些设计模式？</h3><p>Dubbo 框架在初始化和通信过程中使用了多种设计模式，可灵活控制类加载、权限控制等功能。</p><p>工厂模式</p><pre><code>Provider 在 export 服务时，会调用 ServiceConfig 的 export 方法。ServiceConfig中有个字段：
</code></pre><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Protocol</span> protocol <span class="token operator">=</span>
<span class="token class-name">ExtensionLoader</span><span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span><span class="token class-name">Protocol</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span>getAdaptiveExtensi
<span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>装饰器模式</p><p>Dubbo 在启动和调用阶段都大量使用了装饰器模式。以 Provider 提供的调用链为例，具体的调用链代码是在 ProtocolFilterWrapper 的 buildInvokerChain 完成的，具体是将注解中含有 group=provider 的 Filter 实现，按照 order 排序，最后的调用顺序是：</p><p>EchoFilter -&gt; ClassLoaderFilter -&gt; GenericFilter -&gt; ContextFilter -&gt; ExecuteLimitFilter -&gt; TraceFilter -&gt; TimeoutFilter -&gt; MonitorFilter -&gt; ExceptionFilter</p><p>更确切地说，这里是装饰器和责任链模式的混合使用。例如，EchoFilter 的作用是判断是否是回声测试请求，是的话直接返回内容，这是一种责任链的体现。而像ClassLoaderFilter 则只是在主功能上添加了功能，更改当前线程的 ClassLoader，这是典型的装饰器模式。</p><p>观察者模式</p><p>Dubbo 的 Provider 启动时，需要与注册中心交互，先注册自己的服务，再订阅自己的服务，订阅时，采用了观察者模式，开启一个 listener。注册中心会每 5 秒定时检查是否有服务更新，如果有更新，向该服务的提供者发送一个 notify 消息，provider 接受到 notify 消息后，运行 NotifyListener 的 notify 方法，执行监听器方法。</p><p>动态代理模式</p><p>Dubbo 扩展 JDK SPI 的类 ExtensionLoader 的 Adaptive 实现是典型的动态代理实现。Dubbo 需要灵活地控制实现类，即在调用阶段动态地根据参数决定调用哪个实现类，所以采用先生成代理类的方法，能够做到灵活的调用。生成代理类的代码是 ExtensionLoader 的 createAdaptiveExtensionClassCode 方法。代理类主要逻辑是，获取 URL 参数中指定参数的值作为获取实现类的 key。</p><h2 id="运维管理" tabindex="-1"><a class="header-anchor" href="#运维管理" aria-hidden="true">#</a> 运维管理</h2><h3 id="服务上线怎么兼容旧版本" tabindex="-1"><a class="header-anchor" href="#服务上线怎么兼容旧版本" aria-hidden="true">#</a> 服务上线怎么兼容旧版本？</h3><p>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。</p><h3 id="dubbo-telnet-命令能做什么" tabindex="-1"><a class="header-anchor" href="#dubbo-telnet-命令能做什么" aria-hidden="true">#</a> Dubbo telnet 命令能做什么？</h3><pre><code>dubbo 服务发布之后，我们可以利用 telnet 命令进行调试、管理。Dubbo2.0.5 以上版本服务提供端口支持 telnet 命令
</code></pre><h3 id="dubbo-支持服务降级吗" tabindex="-1"><a class="header-anchor" href="#dubbo-支持服务降级吗" aria-hidden="true">#</a> Dubbo 支持服务降级吗？</h3><p>以通过 dubbo:reference 中设置 mock=“return null”。mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑</p><h3 id="dubbo-如何优雅停机" tabindex="-1"><a class="header-anchor" href="#dubbo-如何优雅停机" aria-hidden="true">#</a> Dubbo 如何优雅停机？</h3><p>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</p><h2 id="spi" tabindex="-1"><a class="header-anchor" href="#spi" aria-hidden="true">#</a> SPI</h2><h3 id="dubbo-spi-和-java-spi-区别" tabindex="-1"><a class="header-anchor" href="#dubbo-spi-和-java-spi-区别" aria-hidden="true">#</a> Dubbo SPI 和 Java SPI 区别？</h3><p>JDK SPI：</p><p>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了</p><p>DUBBO SPI：</p><p>1、对 Dubbo 进行扩展，不需要改动 Dubbo 的源码</p><p>2、延迟加载，可以一次只加载自己想要加载的扩展实现。</p><p>3、增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</p><p>4、Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。</p><h2 id="dubbo-可以对结果进行缓存吗" tabindex="-1"><a class="header-anchor" href="#dubbo-可以对结果进行缓存吗" aria-hidden="true">#</a> Dubbo 可以对结果进行缓存吗？</h2><p>为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作量<code>&lt;dubbo:reference cache=“true” /&gt;</code> 其实比普通的配置文件就多了一个标签 cache=“true”</p><h2 id="dubbo-支持哪些序列化方式" tabindex="-1"><a class="header-anchor" href="#dubbo-支持哪些序列化方式" aria-hidden="true">#</a> Dubbo 支持哪些序列化方式？</h2><p>默认使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。</p><h2 id="dubbo-在安全方面有哪些措施" tabindex="-1"><a class="header-anchor" href="#dubbo-在安全方面有哪些措施" aria-hidden="true">#</a> Dubbo 在安全方面有哪些措施？</h2><p>Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。 Dubbo 还提供服务黑白名单，来控制服务所允许的调用方。</p><h2 id="服务调用是阻塞的吗" tabindex="-1"><a class="header-anchor" href="#服务调用是阻塞的吗" aria-hidden="true">#</a> 服务调用是阻塞的吗？</h2><p>默认是阻塞的，可以异步调用，没有返回值的可以这么做。Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</p><h2 id="服务提供者能实现失效踢出是什么原理" tabindex="-1"><a class="header-anchor" href="#服务提供者能实现失效踢出是什么原理" aria-hidden="true">#</a> 服务提供者能实现失效踢出是什么原理？</h2><p>服务失效踢出基于 zookeeper 的临时节点原理。</p><h2 id="dubbo-使用过程中都遇到了些什么问题" tabindex="-1"><a class="header-anchor" href="#dubbo-使用过程中都遇到了些什么问题" aria-hidden="true">#</a> Dubbo 使用过程中都遇到了些什么问题？</h2><p>在注册中心找不到对应的服务,检查 service 实现类是否添加了@service 注解无法连接到注册中心,检查配置文件中的对应的测试 ip 是否正确</p><h2 id="rpc和soa、soap、rest的区别" tabindex="-1"><a class="header-anchor" href="#rpc和soa、soap、rest的区别" aria-hidden="true">#</a> RPC和SOA、SOAP、REST的区别</h2><p>1、REST</p><p>可以看着是HTTP协议的一种直接应用，默认基于JSON作为传输格式,使用简单,学习成本低效率高,但是安全性较低。</p><p>2、SOAP</p><p>SOAP是一种数据交换协议规范,是一种轻量的、简单的、基于XML的协议的规范。而SOAP可以看着是一个重量级的协议，基于XML、SOAP在安全方面是通过使用XML-Security和XML-Signature两个规范组成了WS-Security来实现安全控制的,当前已经得到了各个厂商的支持 。</p><p>它有什么优点？简单总结为：易用、灵活、跨语言、跨平台。</p><p>3、SOA</p><p>面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。</p><p>SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。</p><p>4、REST 和 SOAP、RPC 有何区别呢?</p><p>没什么太大区别，他们的本质都是提供可支持分布式的基础服务，最大的区别在于他们各自的的特点所带来的不同应用场景 。</p>`,103);function m(f,x){const n=r("ExternalLinkIcon");return o(),i("div",null,[a("div",d,[b,a("p",null,[a("a",h,[e("dubbo 负载均衡策略解析"),s(n)])]),a("p",null,[a("a",k,[e("dubbo的负载均衡以及配置方式补充"),s(n)])]),a("p",null,[a("a",v,[e("Dubbo面试题"),s(n)])])]),g])}const D=t(u,[["render",m],["__file","dubbo.html.vue"]]);export{D as default};

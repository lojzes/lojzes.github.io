import{_ as n,X as r,Y as a,Z as e,a1 as t,$ as s,a2 as c,C as p}from"./framework-0b23a550.js";const o={},l={class:"hint-container tip"},d=e("p",{class:"hint-container-title"},"参考",-1),h={href:"https://github.com/lyyitit/java-design-patterns",target:"_blank",rel:"noopener noreferrer"},u=c('<h2 id="设计原则" tabindex="-1"><a class="header-anchor" href="#设计原则" aria-hidden="true">#</a> 设计原则</h2><h3 id="单一原-single-responsibility-principle-简称srp" tabindex="-1"><a class="header-anchor" href="#单一原-single-responsibility-principle-简称srp" aria-hidden="true">#</a> 单一原(Single Responsibility Principle，简称SRP）</h3><p>核心思想：应该有且仅有一个原因引起类的变更问题描述：假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。好处：类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。需注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“责”和“变化原因”都是不可以度量的，因项目和环境而异。</p><h3 id="接口隔离原则-interface-segregation-principle" tabindex="-1"><a class="header-anchor" href="#接口隔离原则-interface-segregation-principle" aria-hidden="true">#</a> 接口隔离原则（Interface Segregation Principle）</h3><p>使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="依赖倒转原则-dependence-inversion-principle" tabindex="-1"><a class="header-anchor" href="#依赖倒转原则-dependence-inversion-principle" aria-hidden="true">#</a> 依赖倒转原则（Dependence Inversion Principle）</h3><p>这个原则是开闭原则的基础，具体内容：针对对接口编程，依赖于抽象而不依赖于具体。使用接口和抽象类的目的是制定好规范，而不涉及具体的操作，由具体的子类或实现类去实现。</p><h3 id="开闭原则-open-close-principle" tabindex="-1"><a class="header-anchor" href="#开闭原则-open-close-principle" aria-hidden="true">#</a> 开闭原则（Open Close Principle）</h3><p><u>对扩展开放，对修改关闭</u>。在程序需要进行拓展的时候，不要（或者尽量修改少的代码）去修改原有的代码，要通过扩展的方法来实现功能变化。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p><h3 id="里氏代换原则-liskov-substitution-principle" tabindex="-1"><a class="header-anchor" href="#里氏代换原则-liskov-substitution-principle" aria-hidden="true">#</a> 里氏代换原则（Liskov Substitution Principle）</h3><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 在使用继承时，尽量不重写父类非抽象的方法。 继承关系增强了类之间耦合关系，在适当的情况下可以使用聚合、组合、依赖来解决。</p><h3 id="迪米特法则-最少知道原则-demeter-principle" tabindex="-1"><a class="header-anchor" href="#迪米特法则-最少知道原则-demeter-principle" aria-hidden="true">#</a> 迪米特法则，最少知道原则（Demeter Principle）</h3><p>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 只与直接朋友通讯。 直接朋友：类之间的耦合关系称之为朋友关系，耦合的关系很多，如聚合、组合、依赖等。其中，成员变量、方法参数、返回类型称之为直接朋友。而出现在局部变量中的类（我只要结果，不需要知道完成的过程，此过程要封装，此处指提供一个public 方法即可）不是直接朋友</p><h3 id="合成复用原则-composite-reuse-principle" tabindex="-1"><a class="header-anchor" href="#合成复用原则-composite-reuse-principle" aria-hidden="true">#</a> 合成复用原则（Composite Reuse Principle）</h3><p>量使用合成/聚合的方式，而不是使用继承。</p>',15);function _(f,b){const i=p("ExternalLinkIcon");return r(),a("div",null,[e("div",l,[d,e("p",null,[e("a",h,[t("源码"),s(i)])])]),u])}const x=n(o,[["render",_],["__file","基础.html.vue"]]);export{x as default};

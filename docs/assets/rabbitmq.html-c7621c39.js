import{_ as t,X as p,Y as i,Z as n,a1 as a,$ as e,a2 as o,C as c}from"./framework-b6ea3384.js";const r="/assets/3-14410411.png",l="/assets/4-4e752bad.png",u="/assets/5-9d691951.png",d="/assets/1-ff46086d.png",k="/assets/2-f96bb390.png",h={},b={class:"hint-container tip"},m=n("p",{class:"hint-container-title"},"参考",-1),v={href:"https://cloud.tencent.com/developer/article/1816305",target:"_blank",rel:"noopener noreferrer"},f={href:"https://blog.csdn.net/a745233700/article/details/115060109",target:"_blank",rel:"noopener noreferrer"},g={href:"https://juejin.cn/post/6844904125935665160",target:"_blank",rel:"noopener noreferrer"},x={href:"https://www.tizi365.com/topic/35.html",target:"_blank",rel:"noopener noreferrer"},Q={href:"https://zhuanlan.zhihu.com/p/554869322",target:"_blank",rel:"noopener noreferrer"},M={href:"https://juejin.cn/post/6844903906074427400",target:"_blank",rel:"noopener noreferrer"},_=o(`<h2 id="rabbitmq是什么" tabindex="-1"><a class="header-anchor" href="#rabbitmq是什么" aria-hidden="true">#</a> RabbitMQ是什么？</h2><p>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的。</p><h2 id="mq-的优点" tabindex="-1"><a class="header-anchor" href="#mq-的优点" aria-hidden="true">#</a> mq 的优点</h2><ul><li>异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。</li><li>应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。</li><li>流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。</li><li>日志处理 - 解决大量日志传输。</li><li>消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。</li></ul><h2 id="mq-的缺点" tabindex="-1"><a class="header-anchor" href="#mq-的缺点" aria-hidden="true">#</a> mq 的缺点</h2><ul><li>系统可用性降低</li></ul><p>本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了。因此，系统可用性会降低；</p><ul><li>系统复杂度提高</li></ul><p>加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。</p><ul><li>一致性问题</li></ul><p>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</p><pre><code>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技
术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。
但是关键时刻，用，还是得用的。
</code></pre><h2 id="mq-的选型" tabindex="-1"><a class="header-anchor" href="#mq-的选型" aria-hidden="true">#</a> mq 的选型</h2><p>各种对比之后，有如下建议：</p><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p><p>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。 如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p><h2 id="说说broker服务节点、queue队列、exchange交换器" tabindex="-1"><a class="header-anchor" href="#说说broker服务节点、queue队列、exchange交换器" aria-hidden="true">#</a> 说说Broker服务节点、Queue队列、Exchange交换器？</h2><pre><code>Broker可以看做RabbitMQ的服务节点。一般请下一个Broker可以看做一个RabbitMQ服务器。
Queue:RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消
息会被平摊（轮询）给多个消费者进行处理。
Exchange:生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，
或返回给生产者或直接丢弃。
</code></pre><h2 id="重要概念" tabindex="-1"><a class="header-anchor" href="#重要概念" aria-hidden="true">#</a> 重要概念</h2><p>RabbitMQ作为一个消息中间件，其中设计思路基本都来源于AMQP协议，主要有如下几个重要的概念：</p><pre><code>Server：接收客户端的连接，实现AMQP实体服务。
Connection：连接，应用程序与Server的网络连接，TCP连接。
Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。
Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。
    Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。
Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，
    同一个虚拟主机里面不能有相同名称的Exchange或Queue。
Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，
    或者返回给生产者，或者直接丢弃。
RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种
Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。
RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，
   这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”。
Queue：消息队列，用来保存消息，供消费者消费。
</code></pre><h2 id="exchange交换机类型" tabindex="-1"><a class="header-anchor" href="#exchange交换机类型" aria-hidden="true">#</a> Exchange交换机类型</h2><p>生产者发送消息，并不是直接发送到队列的，而是发送到Exchange交换机，再由交换机分发到相应队列，没有匹配到队列则丢弃消息。根据Exchange的类型不同，可灵活实现常见的消息模式。</p><p>Exchange交换机共有四种类型： direct fanout topic headers</p><h3 id="direct" tabindex="-1"><a class="header-anchor" href="#direct" aria-hidden="true">#</a> direct</h3><p>Direct，完全匹配型交换机，此种类型交换机，通过RoutingKey路由键将交换机和队列进行绑定， 消息被发送到exchange时，需要根据消息的RoutingKey，来进行匹配，只将消息发送到完全匹配到此RoutingKey的队列。</p><p><img src="`+r+`" alt="" loading="lazy"></p><h3 id="fanout" tabindex="-1"><a class="header-anchor" href="#fanout" aria-hidden="true">#</a> fanout</h3><p>Fanout，扇出类型交换机，此种交换机，会将消息分发给所有绑定了此交换机的队列，此时RoutingKey参数无效。</p><h3 id="topic" tabindex="-1"><a class="header-anchor" href="#topic" aria-hidden="true">#</a> topic</h3><p>Topic，主题类型交换机，此种交换机与Direct类似，也是需要通过routingkey路由键进行匹配分发，区别在于Topic可以进行模糊匹配，Direct是完全匹配。 Topic中，将routingkey通过&quot;.&quot;来分为多个部分，通过如下功能字符来进行匹配：</p><pre><code>&quot;*&quot;：代表一个部分
&quot;#&quot;：代表一个或多
</code></pre><p><img src="`+l+'" alt="" loading="lazy"></p><h3 id="headers" tabindex="-1"><a class="header-anchor" href="#headers" aria-hidden="true">#</a> headers</h3><p>Headers，headers信息类型交换机，此类型交换机不通过routingkey路由键来分发消息，而是通过消息内容中的headers属性来进行匹配。headers类型交换器性能差，在实际中并不常用。</p><p>虽然不常用，但也可以了解一下其，此种交换机不通过routingkey，但是通过headers进行绑定，也就是在声明binding绑定关系时，需要传入需要匹配的header的key/value键值对。</p><p><img src="'+u+`" alt="" loading="lazy"></p><h2 id="mq-有哪些常见问题-如何解决这些问题" tabindex="-1"><a class="header-anchor" href="#mq-有哪些常见问题-如何解决这些问题" aria-hidden="true">#</a> MQ 有哪些常见问题？如何解决这些问题？</h2><p>MQ 的常见问题有：</p><pre><code>消息的顺序问题
消息的重复问题
消息的丢失问题
</code></pre><h2 id="消息的顺序问题" tabindex="-1"><a class="header-anchor" href="#消息的顺序问题" aria-hidden="true">#</a> 消息的顺序问题</h2><p>RabbitMQ的消息顺序问题，需要分三个环节看待，发送消息的顺序、队列中消息的顺序、消费消息的顺序。</p><h3 id="发送消息的顺序" tabindex="-1"><a class="header-anchor" href="#发送消息的顺序" aria-hidden="true">#</a> 发送消息的顺序</h3><p>消息发送端的顺序，大部分业务不做要求，谁先发消息无所谓，如果遇到业务一定要发送消息也确保顺序，那意味着，只能全局加锁一个个的操作， 一个个的发消息，不能并发发送消息。队列中消息的顺序</p><p>RabbitMQ中，消息最终会保存在队列中，在同一个队列中，消息是顺序的，先进先出原则，这个由Rabbitmq保证，通常也不需要开发关心。</p><pre><code>提示：不同队列中的消息顺序，是没有保证的，例如：进地铁站的时候，排了三个队伍，不同队伍之间的，
不能确保谁先进站。
</code></pre><h3 id="消费消息的顺序" tabindex="-1"><a class="header-anchor" href="#消费消息的顺序" aria-hidden="true">#</a> 消费消息的顺序</h3><p>我们说如何保证消息顺序性，通常说的就是消费者消费消息的顺序，在多个消费者消费同一个消息队列的场景，通常是无法保证消息顺序的， 开篇的示意图已经说明，虽然消息队列的消息是顺序的，但是多个消费者并发消费消息，获取的消息的速度、执行业务逻辑的速度快慢、 执行异常等等原因都会导致消息顺序不一致。</p><p>例如：消息A、B、C按顺序进入队列，消费者A1拿到消息A、消费者B1拿到消息B, 结果消费者B执行速度快，就跑完了，又或者消费者A1挂了，都会导致消息顺序不一致。</p><p>解决消费顺序的问题，通常就是一个队列只有一个消费者 这样就可以一个个消息按顺序处理，缺点就是并发能力下降了，无法并发消费消息，这是个取舍问题。</p><pre><code>提示：如果业务又要顺序消费，又要增加并发，通常思路就是开启多个队列，业务根据规则将消息分发到不同的队列，
通过增加队列的数量来提高并发度，例如：电商订单场景，只需要保证同一个用户的订单消息的顺序性就行，不同用
户之间没有关系，所以只要让同一个用户的订单消息进入同一个队列就行，其他用户的订单消息，可以进入不同的队列。
</code></pre><h2 id="消息的重复问题" tabindex="-1"><a class="header-anchor" href="#消息的重复问题" aria-hidden="true">#</a> 消息的重复问题</h2><p>在保证MQ消息不重复的情况下，消费者消费消息成功后，在给MQ发送消息确认的时候出现了网络异常(或者是服务中断)， MQ没有接收到确认，此时MQ不会将发送的消息删除，为了保证消息被消费，当消费者网络稳定后，MQ就会继续给消费者投递之前的消息。 这时候消费者就接收到了两条一样的消息。</p><h3 id="如何解决消息重复消费的问题" tabindex="-1"><a class="header-anchor" href="#如何解决消息重复消费的问题" aria-hidden="true">#</a> 如何解决消息重复消费的问题</h3><p>为了保证消息不被重复消费，首先要保证每个消息是唯一的，所以可以给每一个消息携带一个全局唯一的id，流程如下：</p><pre><code>消费者监听到消息后获取id，先去查询这个id是否存中如果不存在，则正常消费消息，并把消息的id存入 
数据库或者redis中（下面的编码示例使用redis）如果存在则丢弃此消息
</code></pre><h2 id="消息的丢失问题" tabindex="-1"><a class="header-anchor" href="#消息的丢失问题" aria-hidden="true">#</a> 消息的丢失问题</h2><h3 id="rabbitmq-消息丢失场景有哪些" tabindex="-1"><a class="header-anchor" href="#rabbitmq-消息丢失场景有哪些" aria-hidden="true">#</a> RabbitMQ 消息丢失场景有哪些？</h3><p>消息投递和消费</p><p><img src="`+d+'" alt="" loading="lazy"></p><p>左中右，每部分都会导致消息丢失情况,下面就详细聊聊每个阶段消息是如何丢的：</p><h3 id="生产者生产消息到rabbitmq-server-消息丢失场景" tabindex="-1"><a class="header-anchor" href="#生产者生产消息到rabbitmq-server-消息丢失场景" aria-hidden="true">#</a> 生产者生产消息到RabbitMQ Server 消息丢失场景</h3><ul><li><p>1） 外界环境问题导致：发生网络丢包、网络故障等造成RabbitMQ Server端收不到消息，因为生产环境的网络是很复杂的， 网络抖动，丢包现象很常见，下面会讲到针对这个问题是如何解决的。</p></li><li><p>2） 代码层面，配置层面，考虑不全导致消息丢失</p><p>事例1: 一般情况下，生产者使用Confirm模式投递消息，如果方案不够严谨，比如RabbitMQ Server 接收消息失败后会发送nack消息通知生产者， 生产者监听消息失败或者没做任何事情，消息存在丢失风险；</p><p>事例2: 生产者发送消息到exchange后，发送的路由和queue没有绑定，消息会存在丢失情况，下面会讲到具体的例子，保证意外情况的发生， 即使发生，也在可控范围内。</p></li></ul><h3 id="rabbitmq-server中存储的消息丢失或可靠性不足" tabindex="-1"><a class="header-anchor" href="#rabbitmq-server中存储的消息丢失或可靠性不足" aria-hidden="true">#</a> RabbitMQ Server中存储的消息丢失或可靠性不足</h3><ul><li>1）消息未完全持久化，当机器重启后，消息会全部丢失，甚至Queue也不见了 假如：你仅仅持久化了Message,而Exchange,Queue没有持久化，这个持久化是无效的。 记得之前公司有一哥们忘记持久化Queue导致机器重启后，Queue不见了，自然Message也丢失了。</li><li>2）单节点模式问题，如果某个节点挂了，消息就不能用了,业务可能瘫痪，只能等待 如果做了消息持久化方案，消息会持久化硬盘，机器重启后消息不会丢失；但是还有一个极端情况，这台服务器磁盘突然坏了（公司遇到过磁盘问题还是很多的），消息持久化不了，非高可用状态，这个模式生产环境慎重考虑。</li><li>3）普通集群模式：某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（建立在消息持久化） 虽然这个模式进步了一点点，多个节点，但是消息还是不能保证可靠，为什么呢？</li></ul><p>因为RabbitMQ 集群模式有点特殊，队列的内容仅仅存在某一个节点上面，不会存在所有节点上面，所有节点仅仅存放消息结构和元数据（可以理解为索引，这也是为了提高性能，如果每次把所有内容同步到所有节点是有开销代价的）。 下面自己画了一张图介绍普通集群丢失消息情况：</p><p><img src="'+k+`" alt="" loading="lazy"></p><p>这里有三个节点，通常情况下一个磁盘节点，两个内存节点，首先先说明下， Queue1 内容仅仅存在节点note1上面，在创建队列的时候已经固定了，note2,note3 仅仅存放的是元数据，这个一定要清楚，Producer发送消息到note2，note2 会同步元数据到其他节点，内容会同步note1。 那我们想下，图中的Q1问题，note1挂了，这个节点的Queues全部暂时不可用，节点恢复后可用。 我们说下图片中备注2中的问题，Producer发送消息到note2，note2在同步note1前note1挂了，此时你的心情是怎么样的。。。后面会讲具体的策略</p><ul><li>4）镜像模式：可以解决上面的问题，但是还是有意外情况发生 比如：持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？下面会详细介绍</li></ul><h3 id="rabbitmq-server到消费者消息丢失" tabindex="-1"><a class="header-anchor" href="#rabbitmq-server到消费者消息丢失" aria-hidden="true">#</a> RabbitMQ Server到消费者消息丢失</h3><p>消费端接收到相关消息之后，消费端还没来得及处理消息，消费端机器就宕机了，此时消息如果处理不当会有丢失风险， 后面会讲到如何处理这个情况，消费端也有ack机制</p><h2 id="如何避免消息丢失" tabindex="-1"><a class="header-anchor" href="#如何避免消息丢失" aria-hidden="true">#</a> 如何避免消息丢失？</h2><pre><code>1.生产者生产消息到RabbitMQ Server 可靠性保证
2.RabbitMQ Server中存储的消息如何保证
3.RabbitMQ Server到消费者消息如何不丢
</code></pre><h3 id="生产者生产消息到rabbitmq-server可靠性保证" tabindex="-1"><a class="header-anchor" href="#生产者生产消息到rabbitmq-server可靠性保证" aria-hidden="true">#</a> 生产者生产消息到RabbitMQ Server可靠性保证</h3><p>通常有一种方案可以解决：就是 AMQP协议提供的一个事务机制</p><p>RabbitMQ客户端中Channel 接口提供了几个事务机制相关的方法：</p><pre><code>channel.txSelect
channel.txCommit
channel.txRollback
</code></pre><p>在生产者发送消息之前，通过channel.txSelect开启一个事务，接着发送消息， 如果消息投递server失败，进行事务回滚channel.txRollback，然后重新发送， 如果server收到消息，就提交事务channel.txCommit 但是，很少有人这么干，因为这是同步操作，一条消息发送之后会使发送端阻塞，以等待RabbitMQ Server的回应，之后才能继续发送下一条消息，生产者生产消息的吞吐量和性能都会大大降低。</p><p>幸运的是RabbitMQ提供了一个改进方案，即发送方确认机制（publisher confirm） 首先生产者通过调用channel.confirmSelect方法将信道设置为confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一deliveryTag和multiple参数），这就使得生产者知晓消息已经正确到达了目的地了。</p><p>其实Confirm模式有三种方式实现：</p><ul><li>串行confirm模式：producer每发送一条消息后，调用waitForConfirms()方法，等待broker端confirm，如果服务器端返回false或者在超时时间内未返回，客户端进行消息重传。</li><li>批量confirm模式：producer每发送一批消息后，调用waitForConfirms()方法，等待broker端confirm。</li><li>异步confirm模式：提供一个回调方法，broker confirm了一条或者多条消息后producer端会回调这个方法。</li></ul><p>我们分别来看看这三种confirm模式</p><h3 id="串行confirm" tabindex="-1"><a class="header-anchor" href="#串行confirm" aria-hidden="true">#</a> 串行confirm</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">50</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>
           exchange<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span>
           mandatory<span class="token punctuation">,</span> immediate<span class="token punctuation">,</span>
           messageProperties<span class="token punctuation">,</span>
           message<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">waitForConfirms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发送成功&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">//发送失败这里可进行消息重新投递的逻辑</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发送失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="批量confirm" tabindex="-1"><a class="header-anchor" href="#批量confirm" aria-hidden="true">#</a> 批量confirm</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">50</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>
            exchange<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span>
            mandatory<span class="token punctuation">,</span> immediate<span class="token punctuation">,</span>
            messageProperties<span class="token punctuation">,</span>
            message<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">waitForConfirms</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发送成功&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;发送失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码是简单版本的，生产环境绝对不是循环发送的，而是根据业务情况， 各个客户端程序需要定期(每x秒)或定量(每x条)或者两者结合来publish消息，然后等待服务器端confirm。相比普通confirm模式，批量可以极大提升confirm效率。 但是有没有发现什么问题？</p><pre><code>问题1: 批量发送的逻辑复杂化了。
问题2: 一旦出现confirm返回false或者超时的情况时，客户端需要将这一批次的消息全部重发，
这会带来明显的重复消息数量，并且当消息经常丢失时，批量confirm性能应该是不升反降的。
</code></pre><h3 id="异步confirm" tabindex="-1"><a class="header-anchor" href="#异步confirm" aria-hidden="true">#</a> 异步confirm</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Channel</span> channel <span class="token operator">=</span> channelManager<span class="token punctuation">.</span><span class="token function">getPublisherChannel</span><span class="token punctuation">(</span>namespaceName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ProxiedConfirmListener</span> confirmListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxiedConfirmListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//监听类</span>
confirmListener<span class="token punctuation">.</span><span class="token function">setChannelManager</span><span class="token punctuation">(</span>channelManager<span class="token punctuation">)</span><span class="token punctuation">;</span>
confirmListener<span class="token punctuation">.</span><span class="token function">setChannel</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
confirmListener<span class="token punctuation">.</span><span class="token function">setNamespace</span><span class="token punctuation">(</span>namespaceName<span class="token punctuation">)</span><span class="token punctuation">;</span>
confirmListener<span class="token punctuation">.</span><span class="token function">addSuccessCallbacks</span><span class="token punctuation">(</span>successCallbacks<span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">addConfirmListener</span><span class="token punctuation">(</span>confirmListener<span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">confirmSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启confirm模式</span>
<span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span> messageProperties <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    messageProperties <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">AMQP<span class="token punctuation">.</span>BasicProperties</span><span class="token punctuation">)</span> message<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
confirmListener<span class="token punctuation">.</span><span class="token function">toConfirm</span><span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">getNextPublishSeqNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rawMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">50</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span>
            exchange<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span>
            mandatory<span class="token punctuation">,</span> immediate<span class="token punctuation">,</span>
            messageProperties<span class="token punctuation">,</span>
            message<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>异步模式需要自己多写一部分复杂的代码实现，异步监听类，监听server端的通知消息，异步的好处性能会大幅度提升，发送完毕之后，可以继续发送其他消息。 MQServer通知生产端ConfirmListener监听类：用户可以继承接口实现自己的实现类，处理消息确认机制，此处继承类代码省略，就是上面 ProxiedConfirmListener 类</p>`,93);function y(q,R){const s=c("ExternalLinkIcon");return p(),i("div",null,[n("div",b,[m,n("p",null,[a("参考 "),n("a",v,[a("https://cloud.tencent.com/developer/article/1816305"),e(s)])]),n("p",null,[n("a",f,[a("https://blog.csdn.net/a745233700/article/details/115060109"),e(s)])]),n("p",null,[n("a",g,[a("https://juejin.cn/post/6844904125935665160"),e(s)])]),n("p",null,[n("a",x,[a("RabbitMQ 如何保证消息顺序"),e(s)])]),n("p",null,[n("a",Q,[a("RabbitMQ消息重复消费场景及解决方案"),e(s)])]),n("p",null,[n("a",M,[a("解决RabbitMQ消息丢失问题和保证消息可靠性（一）"),e(s)])])]),_])}const P=t(h,[["render",y],["__file","rabbitmq.html.vue"]]);export{P as default};

import{_ as t,X as o,Y as p,Z as n,a1 as s,$ as e,a2 as i,C as c}from"./framework-b6ea3384.js";const r="/assets/life-1-a0f69fcb.png",l="/assets/life-2-1f0a2b7b.png",u="/assets/life-3-f33ec6e2.png",d="/assets/life-4-d6967413.png",b="/assets/life-5-0a6e4f86.png",k="/assets/life-6-87b44ebf.png",h={},m={class:"hint-container tip"},g=n("p",{class:"hint-container-title"},"参考",-1),v={href:"https://segmentfault.com/a/1190000040365130",target:"_blank",rel:"noopener noreferrer"},B={href:"https://juejin.cn/post/7075168883744718856",target:"_blank",rel:"noopener noreferrer"},f=i(`<p>Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p><h2 id="spring-中的-bean-的作用域有哪些" tabindex="-1"><a class="header-anchor" href="#spring-中的-bean-的作用域有哪些" aria-hidden="true">#</a> Spring 中的 bean 的作用域有哪些?</h2><ul><li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li>session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li><li>global-session： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ul><p>对于普通的 Java 对象来说，它们的生命周期就是：</p><ul><li>实例化</li><li>该对象不再被使用时通过垃圾回收机制进行回收</li></ul><p>而对于 Spring Bean 的生命周期来说：</p><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><h3 id="bean-创建流程入口" tabindex="-1"><a class="header-anchor" href="#bean-创建流程入口" aria-hidden="true">#</a> Bean 创建流程入口</h3><p>AbstractApplicationContext#refresh() 方法的 finishBeanFactoryInitialization(beanFactory)</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">doCreateBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">RootBeanDefinition</span> mbd<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeanCreationException</span> <span class="token punctuation">{</span>
    <span class="token class-name">BeanWrapper</span> instanceWrapper <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        instanceWrapper <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BeanWrapper</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanInstanceCache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>instanceWrapper <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 实例化阶段</span>
        instanceWrapper <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createBeanInstance</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token class-name">Object</span> exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span>

    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 属性赋值阶段</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 初始化阶段</span>
        exposedObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var18<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至于销毁，是在容器关闭时调用的，详见 ConfigurableApplicationContext#close()</p><p>是不是很清爽了？至于 BeanPostProcessor、BeanFactoryPostProcessor 以及其他的类,只不过是对主流程四个步骤的一系列扩展点而已。</p><h2 id="spring-bean-的生命周期的扩展点" tabindex="-1"><a class="header-anchor" href="#spring-bean-的生命周期的扩展点" aria-hidden="true">#</a> Spring Bean 的生命周期的扩展点</h2><p>Spring Bean 的生命周期的扩展点超级多，不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p><h3 id="bean-自身的方法" tabindex="-1"><a class="header-anchor" href="#bean-自身的方法" aria-hidden="true">#</a> Bean 自身的方法</h3><p>比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等， 也就对应着上文说的实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁四个阶段。</p><h3 id="容器级的方法-beanpostprocessor-一系列接口" tabindex="-1"><a class="header-anchor" href="#容器级的方法-beanpostprocessor-一系列接口" aria-hidden="true">#</a> 容器级的方法（BeanPostProcessor 一系列接口）</h3><p>主要是后处理器方法，比如下图的 InstantiationAwareBeanPostProcessor、BeanPostProcessor 接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用。</p><p><img src="`+r+'" alt="" loading="lazy"></p><h3 id="instantiationawarebeanpostprocessor-源码分析" tabindex="-1"><a class="header-anchor" href="#instantiationawarebeanpostprocessor-源码分析" aria-hidden="true">#</a> InstantiationAwareBeanPostProcessor 源码分析</h3><p>InstantiationAwareBeanPostProcessor 是继承了 BeanPostProcessor</p><p><img src="'+l+'" alt="" loading="lazy"></p><h3 id="工厂后处理器方法-beanfactoryprocessor-一系列接口" tabindex="-1"><a class="header-anchor" href="#工厂后处理器方法-beanfactoryprocessor-一系列接口" aria-hidden="true">#</a> 工厂后处理器方法（BeanFactoryProcessor 一系列接口）</h3><p>包括 <code>AspectJWeavingEnabler</code> 、<code>CustomAutowireConfigurer</code> 、<code>ConfigurationClassPostProcessor</code> 等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能。</p><p>我们知道 <code>Spring IoC</code> 容器初始化的关键环节就在 <code>org.springframework.context.support.AbstractApplicationContext#refresh </code>方法中 ，容器创建的主体流程都在这个方法里面，这个方法是真的重要！！！</p><p>对于工厂后处理器方法这里看 <code>invokeBeanFactoryPostProcessors(beanFactory)</code>; 方法，这个方法处理的是 <code>BeanFactoryPostProcessor</code> 接口的 Bean。调用方法如下：</p><p><img src="'+u+'" alt="" loading="lazy"></p><h2 id="bean-级生命周期方法" tabindex="-1"><a class="header-anchor" href="#bean-级生命周期方法" aria-hidden="true">#</a> Bean 级生命周期方法</h2><p>可以理解为 Bean 类直接实现接口的方法，比如 BeanNameAware、BeanFactoryAware、ApplicationContextAware、InitializingBean、DisposableBean 等方法，这些方法只对当前 Bean 生效。</p><h3 id="aware-类型的接口" tabindex="-1"><a class="header-anchor" href="#aware-类型的接口" aria-hidden="true">#</a> Aware 类型的接口</h3><p><code>Aware</code> 类型的接口的作用就是让我们能够拿到 Spring 容器中的一些资源。基本都能够见名知意，<code>Aware</code> 之前的名字就是可以拿到什么资源，例如 <code>BeanNameAware</code> 可以拿到 BeanName，以此类推。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>调用时机需要注意：所有的 Aware 方法都是在<u>初始化阶段之前调用</u>的。</p></div><p>Aware 接口众多，这里同样通过分类的方式帮助大家记忆。Aware 接口具体可以分为两组，至于为什么这么分，详见下面的源码分析。如下排列顺序同样也是 Aware 接口的执行顺序，能够见名知意的接口不再解释。</p><p>Aware Group1</p><ul><li>BeanNameAware</li><li>BeanClassLoaderAware</li><li>BeanFactoryAware</li></ul><p>Aware Group2</p><ul><li>EnvironmentAware</li><li>EmbeddedValueResolverAware 这个知道的人可能不多，实现该接口能够获取 Spring EL 解析器，用户的自定义注解需要支持 SPEL 表达式的时候可以使用，非常方便。</li><li>ApplicationContextAware(ResourceLoaderAware/ApplicationEventPublisherAware/MessageSourceAware) 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的 ApplicationContext 对象，因为 ApplicationContext 是一个复合接口，如下：</li></ul><p><img src="'+d+'" alt="" loading="lazy"></p><p>调用时机</p><p><img src="'+b+'" alt="" loading="lazy"></p><p>可以看到并不是所有的 Aware 接口都使用同样的方式调用。Bean××Aware 都是在代码中直接调用的，而 ApplicationContext 相关的 Aware 都是通过 BeanPostProcessor#postProcessBeforeInitialization() 实现的。感兴趣的可以自己看一下 ApplicationContextAwareProcessor 这个类的源码，就是判断当前创建的 Bean 是否实现了相关的 Aware 方法，如果实现了会调用回调方法将资源传递给 Bean。</p><p>BeanPostProcessor 的调用时机也能在这里体现，包围住 invokeInitMethods 方法，也就说明了在初始化阶段的前后执行。</p><p>关于 Aware 接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了。</p><h2 id="生命周期接口" tabindex="-1"><a class="header-anchor" href="#生命周期接口" aria-hidden="true">#</a> 生命周期接口</h2><p>至于剩下的两个生命周期接口就很简单了，实例化和属性赋值都是 Spring 帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段。</p><p>1️⃣ InitializingBean 对应生命周期的初始化阶段，在上面源码的 invokeInitMethods(beanName, wrappedBean, mbd);方法中调用。</p><p>有一点需要注意，因为 Aware 方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用 Aware 接口获取的资源，这也是我们自定义扩展 Spring 的常用方式。 除了实现 InitializingBean 接口之外还能通过注解或者 xml 配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</p><p>2️⃣ DisposableBean 类似于 InitializingBean，对应生命周期的销毁阶段，以ConfigurableApplicationContext#close()方法作为入口，实现是通过循环取所有实现了 DisposableBean 接口的 Bean 然后调用其 destroy() 方法。</p><h2 id="spring-bean-生命周期流程图" tabindex="-1"><a class="header-anchor" href="#spring-bean-生命周期流程图" aria-hidden="true">#</a> Spring Bean 生命周期流程图</h2><p><img src="'+k+`" alt="" loading="lazy"></p><h2 id="常用接口说明" tabindex="-1"><a class="header-anchor" href="#常用接口说明" aria-hidden="true">#</a> 常用接口说明</h2><p>1️⃣ BeanNameAware</p><p>该接口只有一个方法 setBeanName(String name)，用来获取 bean 的 id 或者 name。</p><p>2️⃣ BeanFactoryAware</p><p>该接口只有一个方法 setBeanFactory(BeanFactory beanFactory)，用来获取当前环境中的 BeanFactory。</p><p>3️⃣ ApplicationContextAware</p><p>该接口只有一个方法 setApplicationContext(ApplicationContext applicationContext)，用来获取当前环境中的 ApplicationContext。</p><p>4️⃣ InitializingBean</p><p>该接口只有一个方法 afterPropertiesSet()，在属性注入完成后调用。</p><p>5️⃣ DisposableBean</p><p>该接口只有一个方法 destroy()，在容器销毁的时候调用，在用户指定的 destroy-method 之前调用。</p><p>6️⃣ BeanPostProcessor</p><p>该接口有两个方法：</p><pre><code>postProcessBeforeInitialization(Object bean, String beanName)：在初始化之前调用此方法
postProcessAfterInitialization(Object bean, String beanName)：在初始化之后调用此方法
</code></pre><p>通过方法签名我们可以知道，我们可以通过 beanName 来筛选出我们需要进行个性化定制的 bean。</p><p>7️⃣ InstantiationAwareBeanPostProcessor</p><p>该类是 BeanPostProcessor 的子接口，常用的有如下三个方法：</p><pre><code>postProcessBeforeInstantiation(Class beanClass, String beanName)：在bean实例化之前调用
postProcessProperties(PropertyValues pvs, Object bean, String beanName)：在bean实例化之后、设置属性前调用
postProcessAfterInstantiation(Class beanClass, String beanName)：在bean实例化之后调用
</code></pre>`,68);function w(A,P){const a=c("ExternalLinkIcon");return o(),p("div",null,[n("div",m,[g,n("p",null,[n("a",v,[s("https://segmentfault.com/a/1190000040365130"),e(a)])]),n("p",null,[n("a",B,[s("https://juejin.cn/post/7075168883744718856"),e(a)])])]),f])}const _=t(h,[["render",w],["__file","bean生命周期.html.vue"]]);export{_ as default};

import{_ as o,X as d,Y as c,Z as a,a1 as r,$ as t,a2 as k,C as i}from"./framework-0b23a550.js";const n={},h={class:"hint-container tip"},p=a("p",{class:"hint-container-title"},"参考",-1),s={href:"https://worktile.com/kb/ask/38439.html",target:"_blank",rel:"noopener noreferrer"},b=k('<p><code>kafka</code>和<code>rabbitmq</code>主要有语言区别、结构区别、吞吐量的区别以及在集群负载均衡方面的区别。 <code>kafka</code>适合产生大量数据的互联网服务的数据收集业务；而<code>rabbitmq</code>适合用在实时的，对可靠性要求比较高的消息传递上，适合企业级的消息发送订阅。</p><h2 id="kafka和rabbitmq的区别" tabindex="-1"><a class="header-anchor" href="#kafka和rabbitmq的区别" aria-hidden="true">#</a> kafka和rabbitmq的区别</h2><h3 id="语言区别" tabindex="-1"><a class="header-anchor" href="#语言区别" aria-hidden="true">#</a> 语言区别</h3><p><code>kafka</code>是采用<code>Scala</code>语言开发；而<code>rabbitmq</code>是由内在高并发的<code>erlanng</code>语言开发。</p><h3 id="结构区别" tabindex="-1"><a class="header-anchor" href="#结构区别" aria-hidden="true">#</a> 结构区别</h3><p><code>kafka</code>采用<code>mq</code>结构，<code>broker</code>有<code>part</code>分区的概念；而<code>rabbitmq</code>采用<code>AMQP（高级消息队列协议）</code>，是一个进程间传递异步消息的网络协议，它的的<code>broker</code>由<code>Exchange,Binding,queue</code>组成。</p><h3 id="吞吐量的区别" tabindex="-1"><a class="header-anchor" href="#吞吐量的区别" aria-hidden="true">#</a> 吞吐量的区别</h3><p>kafka具有高的吞吐量，内部采用消息的批量处理，zero-copy机制，数据的存储和获取是本地磁盘顺序批量操作，具有O(1)的复杂度，消息处理的效率很高；而rabbitMQ在吞吐量方面稍逊于kafka，<u>支持对消息的可靠的传递，支持事务，不支持批量的操作</u>，且基于存储的可靠性的要求存储可以采用内存或者硬盘。</p><h3 id="在集群负载均衡方面的区别" tabindex="-1"><a class="header-anchor" href="#在集群负载均衡方面的区别" aria-hidden="true">#</a> 在集群负载均衡方面的区别</h3><p><code>kafka</code>采用<code>zookeeper对集群中的broker、consumer进行管理</code>；<code>rabbitMQ</code>的负载均衡需要单独的<code>loadbalancer</code>进行支持。</p><h3 id="kafka和rabbitmq适合的场景" tabindex="-1"><a class="header-anchor" href="#kafka和rabbitmq适合的场景" aria-hidden="true">#</a> kafka和rabbitmq适合的场景</h3><p>（1）kafka适合的场景</p><p>kafka是Linkedin于2010年12月份开源的消息发布订阅系统，其主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于<u>日志收集和传输</u>。0.8版本开始<u>支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务</u>。</p><p>（2）rabbitmq适合的场景</p><p><code>rabbitmq</code>是基于<code>AMQP</code>协议来实现的开源消息队列系统。<code>AMQP</code>的主要特征是<u>面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全</u>。<code>AMQP</code>协议更多用在企业系统内，<u>对数据一致性、稳定性和可靠性要求很高的场景</u>，<u>对性能和吞吐量的要求还在其次</u>。因此，rabbitmq 适合用在实时的对可靠性要求比较高的消息传递上，适合企业级的消息发送订阅。</p><h2 id="kafka的具体应用场景有哪些" tabindex="-1"><a class="header-anchor" href="#kafka的具体应用场景有哪些" aria-hidden="true">#</a> Kafka的具体应用场景有哪些</h2><p>1.应用于消息系统</p><p>kafka更好的替换传统的消息系统，消息系统被用于各种场景，与大多数消息系统比较kafka有更好的吞吐量内置分区，副本和故障转移，这有利于处理大规模的消息。</p><p>2.应用于网站活动追踪</p><p>kafka原本的使用场景是用户的活动追踪，网站的活动（网页游览，搜索或其他用户的操作信息）发布到不同的话题中心，这些消息可实时处理实时监测也可加载到Hadoop或离线处理数据仓库。</p><p>3.应用于日志聚合</p><p>许多人使用Kafka作为日志聚合解决方案的替代品。日志聚合通常从服务器中收集物理日志文件，并将它们放在中央位置（可能是文件服务器或HDFS）进行处理。Kafka抽象出文件的细节，并将日志或事件数据更清晰地抽象为消息流。这允许更低延迟的处理并更容易支持多个数据源和分布式数据消费。</p><p>4.应用于事件采集</p><p>事件采集是一种应用程序的设计风格，其中状态的变化根据时间的顺序记录下来，kafka支持这种非常大的存储日志数据的场景。</p><p>5.应用于提交日志</p><p>kafka可以作为一种分布式的外部日志，可帮助节点之间复制数据，并作为失败的节点来恢复数据重新同步，kafka的日志压缩功能很好的支持这种用法，这种用法类似于Apacha BookKeeper项目。</p>',26);function f(l,u){const e=i("ExternalLinkIcon");return d(),c("div",null,[a("div",h,[p,a("p",null,[a("a",s,[r("kafka和rabbitmq什么区别，各自适合什么场景"),t(e)])])]),b])}const _=o(n,[["render",f],["__file","kafka.html.vue"]]);export{_ as default};

import{_ as s,X as n,Y as o,Z as e,a1 as l,$ as c,a2 as r,C as p}from"./framework-0b23a550.js";const i="/assets/1-612aa380.png",t={},d={class:"hint-container tip"},u=e("p",{class:"hint-container-title"},"参考",-1),b={href:"https://www.cnblogs.com/darryallen/p/15236550.html",target:"_blank",rel:"noopener noreferrer"},h=r('<h2 id="mysql-主从复制原理" tabindex="-1"><a class="header-anchor" href="#mysql-主从复制原理" aria-hidden="true">#</a> Mysql 主从复制原理</h2><p><code>Mysql</code> 的主从复制和 <code>MySQL</code> 的读写分离两者联系紧密，先要部署主从复制，然后在此基础上进行数据的读写分离。</p><h3 id="mysql-支持的复制类型" tabindex="-1"><a class="header-anchor" href="#mysql-支持的复制类型" aria-hidden="true">#</a> <code>MySQL</code> 支持的复制类型</h3><ul><li>基于语句的复制<code>（STATEMENT）</code>。在主服务器上执行的 <code>SQL</code> 语句，在从服务器上执行同样的语句。<code>MySQL</code> 默认采用基于语句的复制，效率比较高。</li><li>基于行的复制<code>（ROW）</code>。把改变的内容复制过去，而不是把命令在从服务器上执行一遍。</li><li>混合类型的复制<code>（MIXED）</code>。默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。</li></ul><h3 id="mysql主从复制的工作过程" tabindex="-1"><a class="header-anchor" href="#mysql主从复制的工作过程" aria-hidden="true">#</a> <code>MySQL</code>主从复制的工作过程</h3><p><img src="'+i+`" alt="" loading="lazy"></p><h2 id="mysql支持的复制类型" tabindex="-1"><a class="header-anchor" href="#mysql支持的复制类型" aria-hidden="true">#</a> MySQL支持的复制类型</h2><ul><li>STATEMENT∶基于语句的复制。在服务器上执行SQL语句，在从服务器上执行同样的语句，mysgl默认采用基于语句的复制，执行效率高。</li></ul><blockquote><p>虽然效率较高但是高并发情况下可能精确度不够</p></blockquote><ul><li>ROW∶基于行的复制。把改变的内容复制过去，而不是把命令在从服务器上执行一遍</li></ul><blockquote><p>虽然拥有很高的精确度，但是读写效率较低</p></blockquote><ul><li>MIXED∶混合类型的复制。默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制</li></ul><blockquote><p>结合前两种类型的优点，比较实用</p></blockquote><h3 id="主从复制的工作原理" tabindex="-1"><a class="header-anchor" href="#主从复制的工作原理" aria-hidden="true">#</a> 主从复制的工作原理</h3><p>（1）Master节点将数据的改变记录成二进制日志（Binary log），当Master上的数据发生改变时，则将其改变写入二进制日志中。</p><p>（2）Slave节点会在一定时间间隔内对Master的二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/O线程请求Master的二进制事件。</p><p>（3）同时Master节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至Slave节点本地的中继日志（Relay log）中，Slave节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，即解析成sql语句逐一执行，使得其数据和Master节点的保持一致，最后I/O线程和SQL线程将进入睡眠状态，等待下一次被唤醒。</p><p>也就是说：</p><blockquote><p>在每个事务更新数据完成之前，Master在二进制日志(Binary log)记录这些改变。写入二进制日志完成后，Master通知存储引擎提交事务。 Slave将Master复制到其中继日志(Relay log) 。首先slave开始一个工作线程(I/O)，I/0线程在Master上打开一个普通的连接，然后开始Binlog dump process。Binlog dump process 从Master的二进制日志中读取事件，如果已经跟上 Master ,它会睡眠并等待Master产生新的事件，I/O线程将这些事件写入中继日志（缓存中）。 SQL slave thread (SQL从线程)处理该过程的最后一步，SQL线程从中继日志读取事件，并重放其中的事件而更新 Slave 数据，使其与Master 中的数据一致，只要该线程与I/O 线程保持一致，执行结束后I/O线程和SQL线程都会进行睡眠状态等待下一次操作的执行</p></blockquote><blockquote><p>注： 中继日志通常位于OS缓存中，所以中继日志的开销很小。 复制过程有一个很重要的限制，即复制在Slave上是串行化的，也就是说Master上的并行更新操作不能在Slave上并行操作。</p></blockquote><h2 id="mysql主从复制延迟及解决思路" tabindex="-1"><a class="header-anchor" href="#mysql主从复制延迟及解决思路" aria-hidden="true">#</a> MySQL主从复制延迟及解决思路</h2><p>（1）master服务器高并发，形成大量事务</p><p>（2）网络波动，延迟</p><p>（3）主从硬件设备差异过大导致（如cpu主频、内存io、硬盘io）</p><p>（4）本来就不是同步复制、而是异步复制</p><p>解决方案：</p><p>（1）从库优化Mysql参数。比如增大<code>Innodb_buffer_pool_size</code>，该参数定义了<code>InnoDB</code>存储引擎的表数据和索引数据的最大内存缓冲区大小，让更多操作在<code>Mysql</code>内存中完成，减少磁盘操作。</p><blockquote><p>一般设置 buffer pool 大小为总内存的 3/4 至 4/5 约等于总内存的80%。</p></blockquote><p>（2）从库使用高性能主机。包括<code>cpu</code>强悍、内存加大。避免使用虚拟云主机，使用物理主机，这样提升了<code>i/o</code>方面性。</p><p>（3）从库使用<code>SSD</code>磁盘（固态硬盘）</p><p>（4）网络优化，避免跨机房实现同步（减小网络延迟）</p><h3 id="mysql-优化" tabindex="-1"><a class="header-anchor" href="#mysql-优化" aria-hidden="true">#</a> mysql 优化</h3><p>查询速度慢的问题：</p><p>用于缓存 索引 和 数据的内存大小, 这个当然是越多越好, 数据读写在内存中非常快, 减少了对磁盘的读写。 当数据提交或满足检查点条件后才一次性将内存数据刷新到磁盘中。然而内存还有操作系统或数据库其他进程使用, 一般设置 buffer pool 大小为总内存的 3/4 至 4/5。</p><p>并提出：较优设置：假设系统内存 = 128 GB, buffer pool 大小预计100GB(128GB*80%)</p><p>查询cpu 个数</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cat</span> /proc/cpuinfo <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">&quot;processor&quot;</span> <span class="token operator">|</span><span class="token function">wc</span> <span class="token parameter variable">-l</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>
<span class="token comment">#默认值,或者逻辑CPU数量</span>
<span class="token variable"><span class="token variable">\`</span>innodb_buffer_pool_instances <span class="token operator">=</span> <span class="token number">8</span> <span class="token variable">\`</span></span> 

<span class="token comment">#默认值</span>
<span class="token variable"><span class="token variable">\`</span>innodb_buffer_pool_chunk_size <span class="token operator">=</span> 128MB<span class="token variable">\`</span></span>  

<span class="token comment"># N*8*128MG = N GB ,N 刚好为正整数。设 N=100使得 buffer pool 为总内存的 3/4 至 4/5。</span>
<span class="token variable"><span class="token variable">\`</span>innodb_buffer_pool_size <span class="token operator">=</span> <span class="token number">100</span> GB <span class="token variable">\`</span></span>  

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,38);function m(v,k){const a=p("ExternalLinkIcon");return n(),o("div",null,[e("div",d,[u,e("p",null,[e("a",b,[l("mysql主从复制与读写分离"),c(a)])])]),h])}const f=s(t,[["render",m],["__file","mysql主从复制.html.vue"]]);export{f as default};

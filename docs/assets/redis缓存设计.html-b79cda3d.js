import{_ as a,X as s,Y as n,Z as e,a1 as r,$ as d,a2 as l,C as t}from"./framework-b6ea3384.js";const c="/assets/cache-aside-4ec61ee5.png",h={},p={class:"hint-container tip"},o=e("p",{class:"hint-container-title"},"参考",-1),u={href:"https://xiaolincoding.com/redis/base/redis_interview.html#%E8%AE%A4%E8%AF%86-redis",target:"_blank",rel:"noopener noreferrer"},k=l('<h2 id="如何避免缓存雪崩、缓存击穿、缓存穿透" tabindex="-1"><a class="header-anchor" href="#如何避免缓存雪崩、缓存击穿、缓存穿透" aria-hidden="true">#</a> 如何避免缓存雪崩、缓存击穿、缓存穿透？</h2><h3 id="如何避免缓存雪崩" tabindex="-1"><a class="header-anchor" href="#如何避免缓存雪崩" aria-hidden="true">#</a> 如何避免缓存雪崩？</h3><div class="hint-container info"><p class="hint-container-title">缓存雪崩</p><p>当大量缓存数据在同一时间过期（失效）时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩</p></div><p>对于缓存雪崩问题，我们可以采用两种方案解决。</p><ul><li>将缓存失效时间随机打散： 我们可以在原有的失效时间基础上增加一个随机值（比如 1 到 10 分钟）这样每个缓存的过期时间都不重复了，也就降低了缓存集体失效的概率。</li><li>设置缓存不过期： 我们可以通过后台服务来更新缓存数据，从而避免因为缓存失效造成的缓存雪崩，也可以在一定程度上避免缓存并发问题。</li></ul><h3 id="如何避免缓存击穿" tabindex="-1"><a class="header-anchor" href="#如何避免缓存击穿" aria-hidden="true">#</a> 如何避免缓存击穿？</h3><div class="hint-container info"><p class="hint-container-title">缓存击穿</p><p>如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿</p></div><p>可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。 应对缓存击穿可以采取前面说到两种方案：</p><ul><li>互斥锁方案（Redis 中使用 setNX 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li></ul><h3 id="如何避免缓存穿透" tabindex="-1"><a class="header-anchor" href="#如何避免缓存穿透" aria-hidden="true">#</a> 如何避免缓存穿透？</h3><div class="hint-container info"><p class="hint-container-title">缓存穿透</p><p>当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p><p>当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题</p></div><p>缓存穿透的发生一般有这两种情况：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li></ul><p>应对缓存穿透的方案，常见的方案有三种。</p><ul><li>非法请求的限制：当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</li><li>设置空值或者默认值：当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</li><li>使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</li></ul><h2 id="缓存更新策略" tabindex="-1"><a class="header-anchor" href="#缓存更新策略" aria-hidden="true">#</a> 缓存更新策略</h2><p>常见的缓存更新策略共有3种：</p><ul><li>Cache Aside（旁路缓存）策略；</li><li>Read/Write Through（读穿 / 写穿）策略；</li><li>Write Back（写回）策略；</li></ul><p>实际开发中，Redis 和 MySQL 的更新策略用的是 Cache Aside，另外两种策略应用不了。</p><h3 id="cache-aside-旁路缓存-策略" tabindex="-1"><a class="header-anchor" href="#cache-aside-旁路缓存-策略" aria-hidden="true">#</a> Cache Aside（旁路缓存）策略</h3><p>Cache Aside（旁路缓存）策略是最常用的，应用程序直接与「数据库、缓存」交互，并负责对缓存的维护，该策略又可以细分为「读策略」和「写策略」。</p><img src="'+c+`"><p>写策略的步骤：</p><ul><li>先更新数据库中的数据，再删除缓存中的数据。</li></ul><p>读策略的步骤：</p><ul><li>如果读取的数据命中了缓存，则直接返回数据；</li><li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。</li></ul><p>//TODO 后续补上</p><h2 id="redis-的大-key-如何处理" tabindex="-1"><a class="header-anchor" href="#redis-的大-key-如何处理" aria-hidden="true">#</a> Redis 的大 key 如何处理？</h2><div class="hint-container info"><p class="hint-container-title">什么是 Redis 大 key</p><p>大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。</p><p>一般而言，下面这两种情况被称为大 key：</p><pre><code>String 类型的值大于 10 KB；
Hash、List、Set、ZSet 类型的元素的个数超过 5000个；
</code></pre></div><h3 id="大-key-会造成什么问题" tabindex="-1"><a class="header-anchor" href="#大-key-会造成什么问题" aria-hidden="true">#</a> 大 key 会造成什么问题？</h3><p>大 key 会带来以下四种影响：</p><ul><li>客户端超时阻塞。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li>引发网络阻塞。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li>阻塞工作线程。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li>内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li></ul><h3 id="如何找到大-key" tabindex="-1"><a class="header-anchor" href="#如何找到大-key" aria-hidden="true">#</a> 如何找到大 key ？</h3><p>1、redis-cli --bigkeys 查找大key</p><p>可以通过 redis-cli --bigkeys 命令查找大 key：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>redis-cli <span class="token parameter variable">-h</span> <span class="token number">127.0</span>.0.1 <span class="token parameter variable">-p6379</span> <span class="token parameter variable">-a</span> <span class="token string">&quot;password&quot;</span> -- bigkeys
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、使用 SCAN 命令查找大 key</p><p>3、使用 RdbTools 工具查找大 key</p><h2 id="redis-事务支持回滚吗" tabindex="-1"><a class="header-anchor" href="#redis-事务支持回滚吗" aria-hidden="true">#</a> Redis 事务支持回滚吗？</h2><p>Redis 中并没有提供回滚机制，虽然 Redis 提供了 DISCARD 命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。</p>`,40);function _(y,b){const i=t("ExternalLinkIcon");return s(),n("div",null,[e("div",p,[o,e("p",null,[e("a",u,[r('"Redis 常见面试题"'),d(i)])])]),k])}const v=a(h,[["render",_],["__file","redis缓存设计.html.vue"]]);export{v as default};

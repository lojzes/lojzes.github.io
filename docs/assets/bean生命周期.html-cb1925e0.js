import{_ as o,X as c,Y as t,Z as e,a1 as a,$ as s,a2 as p,C as i}from"./framework-0b23a550.js";const r="/assets/life-1-a0f69fcb.png",d="/assets/life-2-1f0a2b7b.png",l="/assets/life-3-f33ec6e2.png",u="/assets/life-4-d6967413.png",b="/assets/life-5-0a6e4f86.png",k="/assets/life-6-87b44ebf.png",h={},m={class:"hint-container tip"},g=e("p",{class:"hint-container-title"},"参考",-1),v={href:"https://segmentfault.com/a/1190000040365130",target:"_blank",rel:"noopener noreferrer"},B={href:"https://juejin.cn/post/7075168883744718856",target:"_blank",rel:"noopener noreferrer"},f=p(`<p><code>Spring Bean</code> 的生命周期主要指的是 <code>singleton bean</code>，对于 <code>prototype</code> 的 <code>bean</code> ,<code>Spring</code> 在创建好交给使用者之后则不会再管理后续的生命周期。</p><h2 id="spring-中的-bean-的作用域有哪些" tabindex="-1"><a class="header-anchor" href="#spring-中的-bean-的作用域有哪些" aria-hidden="true">#</a> Spring 中的 bean 的作用域有哪些?</h2><ul><li><code>singleton</code> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li><li><code>prototype</code> : 每次请求都会创建一个新的 bean 实例。</li><li><code>request </code>: 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li><li><code>session</code> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li><li><code>global-session</code>： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。 <code>Portlet</code> 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ul><p>对于普通的 Java 对象来说，它们的生命周期就是：</p><ul><li>实例化</li><li>该对象不再被使用时通过垃圾回收机制进行回收</li></ul><p>而对于 Spring Bean 的生命周期来说：</p><ul><li>实例化 <code>Instantiation</code></li><li>属性赋值 <code>Populate</code></li><li>初始化 <code>Initialization</code></li><li>销毁 <code>Destruction</code></li></ul><h3 id="bean-创建流程入口" tabindex="-1"><a class="header-anchor" href="#bean-创建流程入口" aria-hidden="true">#</a> Bean 创建流程入口</h3><p>AbstractApplicationContext#refresh() 方法的 finishBeanFactoryInitialization(beanFactory)</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">doCreateBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">RootBeanDefinition</span> mbd<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeanCreationException</span> <span class="token punctuation">{</span>
    <span class="token class-name">BeanWrapper</span> instanceWrapper <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        instanceWrapper <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BeanWrapper</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanInstanceCache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>instanceWrapper <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 实例化阶段</span>
        instanceWrapper <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createBeanInstance</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token class-name">Object</span> exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span>

    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 属性赋值阶段</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 初始化阶段</span>
        exposedObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var18<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至于销毁，是在容器关闭时调用的，详见 <code>ConfigurableApplicationContext#close()</code></p><p>是不是很清爽了？至于 <code>BeanPostProcessor、BeanFactoryPostProcessor</code> 以及其他的类,只不过是对主流程四个步骤的一系列扩展点而已。</p><h2 id="spring-bean-的生命周期的扩展点" tabindex="-1"><a class="header-anchor" href="#spring-bean-的生命周期的扩展点" aria-hidden="true">#</a> Spring Bean 的生命周期的扩展点</h2><p><code>Spring Bean</code> 的生命周期的扩展点超级多，不可能全部列出来，只说核心的扩展点。 这也就是为什么 <code>Spring</code> 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合， 用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p><h3 id="bean-自身的方法" tabindex="-1"><a class="header-anchor" href="#bean-自身的方法" aria-hidden="true">#</a> Bean 自身的方法</h3><p>比如<code>构造函数</code>、<code>getter/setter</code> 以及 <code>init-method</code> 和 <code>destory-method</code> 所指定的方法等， 也就对应着上文说的<code>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</code>四个阶段。</p><h3 id="容器级的方法-beanpostprocessor-一系列接口" tabindex="-1"><a class="header-anchor" href="#容器级的方法-beanpostprocessor-一系列接口" aria-hidden="true">#</a> 容器级的方法（BeanPostProcessor 一系列接口）</h3><p>主要是后处理器方法，比如下图的 <code>InstantiationAwareBeanPostProcessor</code>、<code>BeanPostProcessor</code> 接口方法。这些接口的实现类是独立于 <code>Bean</code> 的，并且会注册到 <code>Spring</code> 容器中。在 <code>Spring</code> 容器创建任何 <code>Bean</code> 的时候，这些后处理器都会发生作用。</p><p><img src="`+r+'" alt="" loading="lazy"></p><h3 id="instantiationawarebeanpostprocessor-源码分析" tabindex="-1"><a class="header-anchor" href="#instantiationawarebeanpostprocessor-源码分析" aria-hidden="true">#</a> InstantiationAwareBeanPostProcessor 源码分析</h3><p><code>InstantiationAwareBeanPostProcessor </code>是继承了 <code>BeanPostProcessor</code></p><p><img src="'+d+'" alt="" loading="lazy"></p><h3 id="工厂后处理器方法-beanfactoryprocessor-一系列接口" tabindex="-1"><a class="header-anchor" href="#工厂后处理器方法-beanfactoryprocessor-一系列接口" aria-hidden="true">#</a> 工厂后处理器方法（BeanFactoryProcessor 一系列接口）</h3><p>包括 <code>AspectJWeavingEnabler</code> 、<code>CustomAutowireConfigurer</code> 、<code>ConfigurationClassPostProcessor</code> 等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能。</p><p>我们知道 <code>Spring IoC</code> 容器初始化的关键环节就在 <code>org.springframework.context.support.AbstractApplicationContext#refresh </code>方法中 ，容器创建的主体流程都在这个方法里面，这个方法是真的重要！！！</p><p>对于工厂后处理器方法这里看 <code>invokeBeanFactoryPostProcessors(beanFactory)</code>; 方法，这个方法处理的是 <code>BeanFactoryPostProcessor</code> 接口的 Bean。调用方法如下：</p><p><img src="'+l+'" alt="" loading="lazy"></p><h2 id="bean-级生命周期方法" tabindex="-1"><a class="header-anchor" href="#bean-级生命周期方法" aria-hidden="true">#</a> Bean 级生命周期方法</h2><p>可以理解为 <code>Bean</code> 类直接实现接口的方法，比如 <code>BeanNameAware、BeanFactoryAware、ApplicationContextAware、InitializingBean、DisposableBean</code> 等方法，这些方法只对当前 <code>Bean</code> 生效。</p><h3 id="aware-类型的接口" tabindex="-1"><a class="header-anchor" href="#aware-类型的接口" aria-hidden="true">#</a> Aware 类型的接口</h3><p><code>Aware</code> 类型的接口的作用就是让我们能够拿到 <code>Spring</code> 容器中的一些资源。基本都能够见名知意，<code>Aware</code> 之前的名字就是可以拿到什么资源，例如 <code>BeanNameAware</code> 可以拿到 BeanName，以此类推。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>调用时机需要注意：所有的 Aware 方法都是在<u>初始化阶段之前调用</u>的。</p></div><p><code>Aware</code> 接口众多，这里同样通过分类的方式帮助大家记忆。<code>Aware</code> 接口具体可以分为两组， 至于为什么这么分，详见下面的源码分析。如下排列顺序同样也是 Aware 接口的执行顺序，能够见名知意的接口不再解释。</p><p><code>Aware Group1</code></p><ul><li><code>BeanNameAware</code></li><li><code>BeanClassLoaderAware</code></li><li><code>BeanFactoryAware</code></li></ul><p><code>Aware Group2</code></p><ul><li><code>EnvironmentAware</code></li><li><code>EmbeddedValueResolverAware</code> 这个知道的人可能不多，实现该接口能够获取 <code>Spring EL </code>解析器，用户的自定义注解需要支持 <code>SPEL</code> 表达式的时候可以使用，非常方便。</li><li><code>ApplicationContextAware(ResourceLoaderAware/ApplicationEventPublisherAware/MessageSourceAware)</code> 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的 <code>ApplicationContext</code> 对象，因为 ApplicationContext 是一个复合接口，如下：</li></ul><p><img src="'+u+'" alt="" loading="lazy"></p><p>调用时机</p><p><img src="'+b+'" alt="" loading="lazy"></p><p>可以看到并不是所有的 <code>Aware</code> 接口都使用同样的方式调用。<code>Bean××Aware</code> 都是在代码中直接调用的， 而 <code>ApplicationContext</code> 相关的 <code>Aware</code> 都是通过 <code>BeanPostProcessor#postProcessBeforeInitialization()</code> 实现的。 感兴趣的可以自己看一下 <code>ApplicationContextAwareProcessor</code> 这个类的源码，就是判断当前创建的 <code>Bean</code> 是否实现了相关的 <code>Aware</code> 方法，如果实现了会调用回调方法将资源传递给 <code>Bean</code>。</p><p><code>BeanPostProcessor</code> 的调用时机也能在这里体现，包围住 <code>invokeInitMethods</code> 方法，也就说明了在初始化阶段的前后执行。</p><p>关于 <code>Aware</code> 接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了。</p><h2 id="生命周期接口" tabindex="-1"><a class="header-anchor" href="#生命周期接口" aria-hidden="true">#</a> 生命周期接口</h2><p>至于剩下的两个生命周期接口就很简单了，实例化和属性赋值都是 <code>Spring</code> 帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段。</p><p>1️⃣ <code>InitializingBean</code> 对应生命周期的初始化阶段，在上面源码的 <code>invokeInitMethods(beanName, wrappedBean, mbd);</code>方法中调用。</p><p>有一点需要注意，因为 <code>Aware</code> 方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用 <code>Aware</code> 接口获取的资源， 这也是我们自定义扩展 <code>Spring</code> 的常用方式。 除了实现 <code>InitializingBean</code> 接口之外还能通过注解或者 <code>xml</code> 配置的方式指定初始化方法， 至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</p><p>2️⃣ <code>DisposableBean</code> 类似于 <code>InitializingBean</code>，对应生命周期的销毁阶段，以 <code>ConfigurableApplicationContext#close()</code>方法作为入口，实现是通过循环取所有实现了 <code>DisposableBean</code> 接口的 <code>Bean</code> 然后调用其 <code>destroy() </code>方法。</p><h2 id="spring-bean-生命周期流程图" tabindex="-1"><a class="header-anchor" href="#spring-bean-生命周期流程图" aria-hidden="true">#</a> Spring Bean 生命周期流程图</h2><p><img src="'+k+`" alt="" loading="lazy"></p><h2 id="常用接口说明" tabindex="-1"><a class="header-anchor" href="#常用接口说明" aria-hidden="true">#</a> 常用接口说明</h2><p>1️⃣ <code>BeanNameAware</code></p><p>该接口只有一个方法 <code>setBeanName(String name)</code>，用来获取 <code>bean</code> 的 <code>id</code> 或者 <code>name。</code></p><p>2️⃣ <code>BeanFactoryAware</code></p><p>该接口只有一个方法 <code>setBeanFactory(BeanFactory beanFactory)</code>，用来获取当前环境中的 <code>BeanFactory。</code></p><p>3️⃣ <code>ApplicationContextAware</code></p><p>该接口只有一个方法 <code>setApplicationContext(ApplicationContext applicationContext)</code>，用来获取当前环境中的 <code>ApplicationContext。</code></p><p>4️⃣ <code>InitializingBean</code></p><p>该接口只有一个方法 <code>afterPropertiesSet()</code>，在属性注入完成后调用。</p><p>5️⃣ <code>DisposableBean</code></p><p>该接口只有一个方法<code> destroy()</code>，在容器销毁的时候调用，在用户指定的 <code>destroy-method</code> 之前调用。</p><p>6️⃣ <code>BeanPostProcessor</code></p><p>该接口有两个方法：</p><pre><code>postProcessBeforeInitialization(Object bean, String beanName)：在初始化之前调用此方法
postProcessAfterInitialization(Object bean, String beanName)：在初始化之后调用此方法
</code></pre><p>通过方法签名我们可以知道，我们可以通过 beanName 来筛选出我们需要进行个性化定制的 bean。</p><p>7️⃣ <code>InstantiationAwareBeanPostProcessor</code></p><p>该类是 <code>BeanPostProcessor</code> 的子接口，常用的有如下三个方法：</p><pre><code>postProcessBeforeInstantiation(Class beanClass, String beanName)：在bean实例化之前调用
postProcessProperties(PropertyValues pvs, Object bean, String beanName)：在bean实例化之后、设置属性前调用
postProcessAfterInstantiation(Class beanClass, String beanName)：在bean实例化之后调用
</code></pre>`,68);function w(A,P){const n=i("ExternalLinkIcon");return c(),t("div",null,[e("div",m,[g,e("p",null,[e("a",v,[a("https://segmentfault.com/a/1190000040365130"),s(n)])]),e("p",null,[e("a",B,[a("https://juejin.cn/post/7075168883744718856"),s(n)])])]),f])}const _=o(h,[["render",w],["__file","bean生命周期.html.vue"]]);export{_ as default};

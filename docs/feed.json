{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "JavaNative",
  "home_page_url": "https://vuepress-theme-hope-docs-demo.netlify.app/",
  "feed_url": "https://vuepress-theme-hope-docs-demo.netlify.app/feed.json",
  "description": "java学习笔记&面试资料&工作笔记",
  "items": [
    {
      "title": "111111",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/author/",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/author/",
      "summary": "我是谁 其他",
      "content_html": "<ul>\n<li><a href=\"/author/me.html\" target=\"blank\">我是谁</a></li>\n<li><a href=\"/author/others.html\" target=\"blank\">其他</a></li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:30.489Z",
      "authors": [],
      "tags": [
        "关于作者"
      ]
    },
    {
      "title": "关于作者",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/author/me.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/author/me.html",
      "summary": "---------------我是谁",
      "content_html": "<p>---------------我是谁</p>\n",
      "date_modified": "2023-08-03T23:47:30.490Z",
      "authors": [],
      "tags": [
        "关于作者"
      ]
    },
    {
      "title": "其他",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/author/others.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/author/others.html",
      "summary": "----------------------其他",
      "content_html": "<p>----------------------其他</p>\n",
      "date_modified": "2023-08-03T23:47:30.490Z",
      "authors": [],
      "tags": [
        "关于作者"
      ]
    },
    {
      "title": "指南",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/demo/",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/demo/",
      "summary": "功能亮点 Bar baz ... Foo ray ...",
      "content_html": "<h2> 功能亮点</h2>\n<h3> Bar</h3>\n<ul>\n<li><a href=\"/demo/src/demo/bar/baz.html\" target=\"blank\">baz</a></li>\n<li>...</li>\n</ul>\n<h3> Foo</h3>\n<ul>\n<li><a href=\"/demo/src/demo/foo/ray.html\" target=\"blank\">ray</a></li>\n<li>...</li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:30.493Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "工作笔记",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/work/",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/work/",
      "content_html": "",
      "date_modified": "2023-08-03T23:47:30.493Z",
      "authors": [],
      "tags": [
        "工作笔记"
      ]
    },
    {
      "title": "面试资料",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/",
      "summary": "Java 基础 面试题总结上(必看 👍) 面试题总结中 面试题总结下 重点知识",
      "content_html": "<h2> Java</h2>\n<h3> 基础</h3>\n<ul>\n<li><a href=\"/interview/java/basic/basic-01.html\" target=\"blank\">面试题总结上</a>(必看 👍)</li>\n<li><a href=\"/interview/java/basic/basic-02.html\" target=\"blank\">面试题总结中</a></li>\n<li><a href=\"/interview/java/basic/basic-03.html\" target=\"blank\">面试题总结下</a></li>\n</ul>\n<p><em><strong>重点知识</strong></em></p>\n<ul>\n<li><a href=\"/interview/java/basic/emphasis/bigdecimal.html\" target=\"blank\">BigDecimal详解</a></li>\n<li><a href=\"/interview/java/basic/emphasis/serialization.html\" target=\"blank\">序列化详解详解</a></li>\n</ul>\n<h3> 并发编程</h3>\n<ul>\n<li><a href=\"/interview/java/concurrency/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8A.html\" target=\"blank\">并发编程1</a></li>\n<li><a href=\"/interview/java/concurrency/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8B.html\" target=\"blank\">并发编程2</a></li>\n<li><a href=\"/interview/java/concurrency/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html\" target=\"blank\">线程池</a></li>\n</ul>\n<h2> JVM</h2>\n<ul>\n<li><a href=\"/interview/java/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html\" target=\"blank\">垃圾回收</a></li>\n<li><a href=\"/interview/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3.html\" target=\"blank\">类加载过程详解</a></li>\n<li><a href=\"/interview/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html\" target=\"blank\">类加载器</a></li>\n<li><a href=\"/interview/java/jvm/%E5%86%85%E5%AD%98%E5%8C%BA.html\" target=\"blank\">内存区</a></li>\n</ul>\n<h2> 数据库</h2>\n<h3> 基础</h3>\n<ul>\n<li><a href=\"/interview/db/basic/basic.html\" target=\"blank\">数据库基础知识</a></li>\n<li><a href=\"/interview/db/basic/nosql.html\" target=\"blank\">NoSql基础知识</a></li>\n<li><a href=\"/interview/db/basic/charset.html\" target=\"blank\">字符集知识</a></li>\n</ul>\n<h3> mysql</h3>\n<ul>\n<li><a href=\"/interview/db/mysql/mysql-others.html\" target=\"blank\">常见面试题</a></li>\n<li><a href=\"/interview/db/mysql/mysql-optimization.html\" target=\"blank\">MySQL高性能优化规范建议总结</a></li>\n</ul>\n<p><em><strong>重点知识</strong></em></p>\n<ul>\n<li><a href=\"/interview/db/mysql/emphasis/mysql-index.html\" target=\"blank\">MySQL索引详解</a></li>\n<li><a href=\"/interview/db/mysql/emphasis/mysql-explain.html\" target=\"blank\">执行计划</a></li>\n<li><a href=\"/interview/db/mysql/emphasis/mysql-execute.html\" target=\"blank\">SQL语句在MySQL中执行的过程</a></li>\n</ul>\n<h2> 常用框架</h2>\n<ul>\n<li><a href=\"/interview/framework/mybatis/mybatis.html\" target=\"blank\">mybatis</a></li>\n<li><a href=\"/interview/framework/spring/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%8F%8A%E6%8E%A5%E5%8F%A3.html\" target=\"blank\">常用注解及接口</a></li>\n<li><a href=\"/interview/framework/spring/%E4%BA%8B%E5%8A%A1.html\" target=\"blank\">事务</a></li>\n<li><a href=\"/interview/framework/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.html\" target=\"blank\">循环依赖</a></li>\n<li><a href=\"/interview/framework/spring/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html\" target=\"blank\">bean生命周期</a></li>\n</ul>\n<h2> 中间件</h2>\n<ul>\n<li><a href=\"/interview/middleware/rabbitMq/rabbitmq.html\" target=\"blank\">rabbitMq</a></li>\n<li><a href=\"/interview/middleware/redis/redis%E5%9F%BA%E7%A1%80.html\" target=\"blank\">redis基础</a></li>\n<li><a href=\"/interview/middleware/redis/redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1.html\" target=\"blank\">redis缓存设计</a></li>\n</ul>\n<h2> 分布式</h2>\n<ul>\n<li><a href=\"/interview/distributed/base/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA.html\" target=\"blank\">分布式理论</a></li>\n<li><a href=\"/interview/distributed/base/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.html\" target=\"blank\">分布式理论</a></li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:30.507Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "学习笔记",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/",
      "summary": "web前端 css css布局 css动画 css基础 css响应式设计 css颜色渐变 css元素定位",
      "content_html": "<h2> web前端</h2>\n<h3> css</h3>\n<ul>\n<li><a href=\"/study/web/css/css%E5%B8%83%E5%B1%80.html\" target=\"blank\">css布局</a></li>\n<li><a href=\"/study/web/css/css%E5%8A%A8%E7%94%BB.html\" target=\"blank\">css动画</a></li>\n<li><a href=\"/study/web/css/css%E5%9F%BA%E7%A1%80.html\" target=\"blank\">css基础</a></li>\n<li><a href=\"/study/web/css/css%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1.html\" target=\"blank\">css响应式设计</a></li>\n<li><a href=\"/study/web/css/css%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98.html\" target=\"blank\">css颜色渐变</a></li>\n<li><a href=\"/study/web/css/css%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D.html\" target=\"blank\">css元素定位</a></li>\n</ul>\n<h3> js</h3>\n<ul>\n<li><a href=\"/study/web/js/js-bom.html\" target=\"blank\">js操作bom</a></li>\n<li><a href=\"/study/web/js/js.html\" target=\"blank\">js学习笔记</a></li>\n</ul>\n<h3> jQuery</h3>\n<ul>\n<li><a href=\"/study/web/jquery/jQuery.html\" target=\"blank\">jQuery 笔记</a></li>\n</ul>\n<h3> linux</h3>\n<ul>\n<li><a href=\"/study/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html\" target=\"blank\">linux常用命令</a></li>\n<li><a href=\"/study/linux/linux-shell.html\" target=\"blank\">shell</a></li>\n<li><a href=\"/study/linux/awk.html\" target=\"blank\">awk</a></li>\n<li><a href=\"/study/linux/grep.html\" target=\"blank\">grep</a></li>\n<li><a href=\"/study/linux/sed.html\" target=\"blank\">sed</a></li>\n</ul>\n<h3> charset</h3>\n<ul>\n<li><a href=\"/study/charset/charset.html\" target=\"blank\">字符集和字符编码</a></li>\n</ul>\n<h3> git</h3>\n<ul>\n<li><a href=\"/study/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html\" target=\"blank\">git常用命令</a></li>\n</ul>\n<h3> c 和 c++</h3>\n<ul>\n<li><a href=\"/study/c/c%E5%9F%BA%E7%A1%80.html\" target=\"blank\">c基础</a></li>\n<li><a href=\"/study/c/cpp%E5%9F%BA%E7%A1%80.html\" target=\"blank\">cpp基础</a></li>\n<li><a href=\"/study/c/cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html\" target=\"blank\">cpp面向对象</a></li>\n<li><a href=\"/study/c/cpp%E9%AB%98%E7%BA%A7.html\" target=\"blank\">cpp高级</a></li>\n</ul>\n<h3> 正则表达式</h3>\n<ul>\n<li><a href=\"/study/regex/regex.html\" target=\"blank\">正则表达式笔记</a></li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:30.510Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "Bar 功能",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/demo/bar/",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/demo/bar/",
      "summary": "介绍 我们支持 bar 功能，... 详情 baz ...",
      "content_html": "<h2> 介绍</h2>\n<p>我们支持 bar 功能，...</p>\n<h2> 详情</h2>\n<ul>\n<li><a href=\"/demo/bar/src/demo/bar/baz.html\" target=\"blank\">baz</a></li>\n<li>...</li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:30.511Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Baz",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/demo/bar/baz.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/demo/bar/baz.html",
      "summary": "功能详情...",
      "content_html": "<p>功能详情...</p>\n",
      "date_modified": "2023-08-03T23:47:30.512Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Foo 功能",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/demo/foo/",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/demo/foo/",
      "summary": "介绍 我们支持 foo 功能，... 详情 ray ...",
      "content_html": "<h2> 介绍</h2>\n<p>我们支持 foo 功能，...</p>\n<h2> 详情</h2>\n<ul>\n<li><a href=\"/demo/foo/src/demo/foo/ray.html\" target=\"blank\">ray</a></li>\n<li>...</li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:30.513Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Ray",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/demo/foo/ray.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/demo/foo/ray.html",
      "summary": "功能详情...",
      "content_html": "<p>功能详情...</p>\n",
      "date_modified": "2023-08-03T23:47:30.513Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "分布式",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/distributed/",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/distributed/",
      "summary": "分布式",
      "content_html": "<p>分布式</p>\n",
      "date_modified": "2023-08-03T23:47:30.514Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "常用框架",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/",
      "summary": "常用框架",
      "content_html": "<p>常用框架</p>\n",
      "date_modified": "2023-08-03T23:47:30.514Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "常用中间件",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/middleware/",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/middleware/",
      "summary": "常用中间件",
      "content_html": "<p>常用中间件</p>\n",
      "date_modified": "2023-08-03T23:47:30.514Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "arthas",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/arthas/arthas.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/arthas/arthas.html",
      "summary": "参考 官网",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://arthas.aliyun.com/doc/\" target=\"_blank\" rel=\"noopener noreferrer\">官网</a></p>\n</div>\n<h2> </h2>\n",
      "date_modified": "2023-08-03T23:47:30.517Z",
      "authors": [],
      "tags": [
        "学习"
      ]
    },
    {
      "title": "canal",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/canal/canal.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/canal/canal.html",
      "summary": "参考 源码 官网 canal入门 Canal常用配置",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://github.com/lojzes/middle-study/tree/master/canal/src/main/java/com/lojzes/middle/canal\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a></p>\n<p><a href=\"https://github.com/alibaba/canal\" target=\"_blank\" rel=\"noopener noreferrer\">官网</a></p>\n<p><a href=\"https://developer.aliyun.com/article/770496\" target=\"_blank\" rel=\"noopener noreferrer\">canal入门</a></p>\n<p><a href=\"https://www.cnblogs.com/yushuo/p/11251265.html\" target=\"_blank\" rel=\"noopener noreferrer\">Canal常用配置</a></p>\n</div>\n<h2> 基本原理</h2>\n<h3> mysql 主从复制</h3>\n<p></p>\n<p>【1】MySQL master 将数据变更写入二进制日志( binary log, 其中记录叫做二进制日志事件 binary log events，可以通过 show binlog events 进行查看)</p>\n<p>【2】MySQL slave 将 master 的 binary log events 拷贝到它的中继日志(relay log)</p>\n<p>【3】MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</p>\n<h3> canal 工作原理</h3>\n<p>【1】canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送 dump 协议</p>\n<p>【2】MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )</p>\n<p>【3】canal 解析 binary log 对象(原始为 byte 流)</p>\n<h3> Canal 主要用途</h3>\n<p>Canal 主要用途是对 MySQL 数据库增量日志进行解析，提供增量数据的订阅和消费，简单说就是可以对 MySQL 的增量数据进行实时同步，支持同步到 MySQL、Elasticsearch、HBase 等数据存储中去。</p>\n",
      "date_modified": "2023-08-03T23:47:30.520Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "c++基础",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/c/cpp%E5%9F%BA%E7%A1%80.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/c/cpp%E5%9F%BA%E7%A1%80.html",
      "summary": "参考 https://www.runoob.com/cplusplus/cpp-files-streams.html C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。 C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.runoob.com/cplusplus/cpp-files-streams.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/cplusplus/cpp-files-streams.html</a></p>\n</div>\n<p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。\nC++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。</p>\n<p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的 C，后来在 1983 年更名为 C++。</p>\n<p>C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。</p>\n<p>C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。</p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查</p>\n</div>\n<h2> 面向对象程序设计</h2>\n<p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：</p>\n<ul>\n<li>\n<p>封装（Encapsulation）：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。</p>\n</li>\n<li>\n<p>继承（Inheritance）：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。</p>\n</li>\n<li>\n<p>多态（Polymorphism）：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。</p>\n</li>\n<li>\n<p>抽象（Abstraction）：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。</p>\n</li>\n</ul>\n<h2> 标准库</h2>\n<p>标准的 C++ 由三个重要部分组成：</p>\n\n<h2> ANSI 标准</h2>\n<p>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。\n由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。</p>\n<h2> 学习 C++</h2>\n<p>学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。</p>\n<h2> 标准化</h2>\n<p></p>\n<h2> C++ 编译器</h2>\n<p>写在源文件中的源代码是人类可读的源。它需要\"编译\"，转为机器语言，这样 CPU 可以按给定指令执行程序。</p>\n<p>C++ 编译器用于把源代码编译成最终的可执行程序。</p>\n<p>大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。</p>\n<p>最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。</p>\n<p>以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。</p>\n<h3> UNIX/Linux 上的安装</h3>\n<p>如果您使用的是 Linux 或 UNIX，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> C++ 程序结构</h2>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <code>&lt;iostream&gt;</code>。\n下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</p>\n<p>C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> C++ 中的空格</h3>\n<p>只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。</p>\n<p>在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。</p>\n<h2> 数据类型</h2>\n<p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>关键字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>布尔型</td>\n<td>bool</td>\n</tr>\n<tr>\n<td>字符型</td>\n<td>char</td>\n</tr>\n<tr>\n<td>整型</td>\n<td>int</td>\n</tr>\n<tr>\n<td>浮点型</td>\n<td>float</td>\n</tr>\n<tr>\n<td>双浮点型</td>\n<td>double</td>\n</tr>\n<tr>\n<td>无类型</td>\n<td>void</td>\n</tr>\n<tr>\n<td>宽字符型</td>\n<td>wchar_t</td>\n</tr>\n</tbody>\n</table>\n<p>其实 wchar_t 是这样来的：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>所以 wchar_t 实际上的空间是和 short int 一样。</p>\n<p>一些基本类型可以使用一个或多个类型修饰符进行修饰：</p>\n\n<p>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。</p>\n<p>注意：不同系统会有所差异，一字节为 8 位。\n注意：默认情况下，int、short、long 都是带符号的，即 signed。</p>\n<p>注意：long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>本实例使用了 <code>endl</code>，这将在每一行后插入一个换行符，<code>&lt;&lt;</code> 运算符用于向屏幕传多个值，<code>sizeof()</code>运算符用来获取各种数据类型的大小。</p>\n<h3> typedef 声明</h3>\n<p>使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>下面的声明是完全合法的，它创建了一个整型变量 <code>distance：</code></p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 枚举类型</h3>\n<p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果枚举没有初始化, 即省掉\"=整型常数\"时, 则从第一个标识符开始。</p>\n<p>例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 \"blue\"。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。</p>\n<h2> 类型转换</h2>\n<p>类型转换是将一个数据类型的值转换为另一种数据类型的值。\nC++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。</p>\n<h3> 静态转换（Static Cast）</h3>\n\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 动态转换（Dynamic Cast）</h3>\n<p>动态转换（Dynamic Cast）\n动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。</p>\n<p>//todo 例子</p>\n<h3> 常量转换（Const Cast）</h3>\n<p>常量转换用于将 const 类型的对象转换为非 const 类型的对象。\n常量转换只能用于转换掉 const 属性，不能改变对象的类型。</p>\n<h3> 重新解释转换（Reinterpret Cast）</h3>\n<p>重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。\n重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。</p>\n<h2> 常量</h2>\n<h3> 定义常量</h3>\n<p>在 C++ 中，有两种简单的定义常量的方式：</p>\n\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 修饰符类型</h2>\n<p>C++ 允许在 char、int 和 double 数据类型前放置修饰符。</p>\n<p>修饰符是用于改变变量类型的行为的关键字，它更能满足各种情境的需求。</p>\n<p>下面列出了数据类型修饰符：</p>\n<ul>\n<li>signed：表示变量可以存储负数。对于整型变量来说，signed 可以省略，因为整型变量默认为有符号类型。</li>\n<li>unsigned：表示变量不能存储负数。对于整型变量来说，unsigned 可以将变量范围扩大一倍。</li>\n<li>short：表示变量的范围比 int 更小。short int 可以缩写为 short。</li>\n<li>long：表示变量的范围比 int 更大。long int 可以缩写为 long。</li>\n<li>long long：表示变量的范围比 long 更大。C++11 中新增的数据类型修饰符。</li>\n<li>float：表示单精度浮点数。</li>\n<li>double：表示双精度浮点数。</li>\n<li>bool：表示布尔类型，只有 true 和 false 两个值。</li>\n<li>char：表示字符类型。</li>\n<li>wchar_t：表示宽字符类型，可以存储 Unicode 字符。</li>\n</ul>\n<h2> 类型限定符</h2>\n<p>类型限定符提供了变量的额外信息，用于在定义变量或函数时改变它们的默认行为的关键字。</p>\n<p></p>\n<h2> 存储类</h2>\n<p>C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>\n\n<p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>\n<h3> auto</h3>\n<p>自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p>\n<p>C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在 C++17 中已删除这一用法。</p>\n<p>根据初始化表达式自动推断被声明的变量的类型，如：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> register</h3>\n<p>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&amp;' 运算符（因为它没有内存位置）。</p>\n<h3> static</h3>\n<p>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>\n<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p>\n<p>在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。</p>\n<h3> extern</h3>\n<h3> mutable</h3>\n<p>mutable 说明符仅适用于类的对象。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p>\n<h3> thread_local</h3>\n<p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>\n<p>thread_local 说明符可以与 static 或 extern 合并。</p>\n<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>\n<h2> 字符串</h2>\n<p>C++ 提供了以下两种类型的字符串表示形式：</p>\n\n<h3> C 风格字符串</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>C++ 中有大量的函数用来操作以 null 结尾的字符串:</p>\n<p></p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> String 类</h3>\n<p>C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 引用</h2>\n<p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>\n<p>C++ 引用 vs 指针</p>\n<p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>\n\n<h3> 创建引用</h3>\n<p>试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>我们可以为 i 声明引用变量，如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>&amp; 读作引用。因此，第一个声明可以读作 \"r 是一个初始化为 i 的整型引用\"</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念：</p>\n<p></p>\n<h2> 日期 &amp; 时间</h2>\n<p>C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 <code>&lt;ctime&gt;</code> 头文件。</p>\n<p>有四个与时间相关的类型：<code>clock_t、time_t、size_t</code> 和 <code>tm</code>。类型 <code>clock_t、size_t </code>和 <code>time_t</code> 能够把系统时间和日期表示为某种整数。</p>\n<p>结构类型 <code>tm</code> 把日期和时间以 <code>C</code> 结构的形式保存，<code>tm </code>结构的定义如下：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当前时间</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 基本的输入输出</h2>\n<h3> I/O 库头文件</h3>\n<p></p>\n<h3> 标准输出流（cout）</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 标准输入流（cin）</h3>\n<p>预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 标准错误流（cerr）</h3>\n<p>预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。</p>\n<p>cerr 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 标准日志流（clog）</h3>\n<p>预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。</p>\n<p>clog 也是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 数据结构(struct)</h2>\n",
      "date_modified": "2023-08-03T23:47:30.576Z",
      "authors": [],
      "tags": [
        "学习"
      ]
    },
    {
      "title": "c++面向对象",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/c/cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/c/cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",
      "summary": "参考 https://www.runoob.com/cplusplus/cpp-files-streams.html 类 &amp; 对象 C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.runoob.com/cplusplus/cpp-files-streams.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/cplusplus/cpp-files-streams.html</a></p>\n</div>\n<h2> 类 &amp; 对象</h2>\n<p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。</p>\n<p>类用于指定对象的形式，是一种用户自定义的数据类型，它是一种封装了数据和函数的组合。类中的数据称为成员变量，函数称为成员函数。类可以被看作是一种模板，可以用来创建具有相同属性和行为的多个对象。</p>\n<h2> 类定义</h2>\n<p></p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义了两个对象：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对象 Box1 和 Box2 都有它们各自的数据成员。</p>\n<h3> 访问数据成员</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问</p>\n</div>\n<h3> 继承</h3>\n<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。</p>\n<p>继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p>\n<p></p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 基类 &amp; 派生类</h2>\n<p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>\n<p>假设有一个基类 Shape，Rectangle 是它的派生类，如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 访问控制和继承</h2>\n<p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>\n<p>我们可以根据访问权限总结出不同的访问类型，如</p>\n<table>\n<thead>\n<tr>\n<th>访问</th>\n<th>public</th>\n<th>protected</th>\n<th>private</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同一个类</td>\n<td>yes</td>\n<td>yes</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>派生类</td>\n<td>yes</td>\n<td>yes</td>\n<td>no</td>\n</tr>\n<tr>\n<td>外部的类</td>\n<td>yes</td>\n<td>no</td>\n<td>no</td>\n</tr>\n</tbody>\n</table>\n<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>\n\n<h2> 继承类型</h2>\n<p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>\n<p>我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则：</p>\n<ul>\n<li>公有继承（public）：当一个类派生自公有基类时，基类的<u>公有成员也是派生类的公有成员</u>，\n<u>基类的保护成员也是派生类的保护成员</u>，<u>基类的私有成员不能直接被派生类访问</u>，\n但是可以通过调用基类的公有和保护成员来访问。</li>\n<li>保护继承（protected）： 当一个类派生自保护基类时，基类的<u>公有和保护</u>成员将成为派\n生类的<u>保护成员</u>。</li>\n<li>私有继承（private）：当一个类派生自私有基类时，基类的<u>公有和保护</u>成员将成为派生类\n的<u>私有</u>成员。</li>\n</ul>\n<h2> 多继承</h2>\n<p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>\n<p>C++ 类可以从多个类继承成员，语法如下：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 重载运算符和重载函数</h2>\n<p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>\n<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>\n<p>当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p>\n<h3> 函数重载</h3>\n<p>在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。</p>\n<p>下面的实例中，同名函数 print() 被用于输出不同的数据类型：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 运算符重载</h3>\n<p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>\n<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 可重载运算符/不可重载运算符</h3>\n<p>下面是可重载的运算符列表</p>\n<p></p>\n<p>下面是不可重载的运算符列表：</p>\n<ul>\n<li>.：成员访问运算符</li>\n<li>.<em>, -&gt;</em>：成员指针访问运算符</li>\n<li>::：域运算符</li>\n<li>sizeof：长度运算符</li>\n<li>?:：条件运算符</li>\n<li>#： 预处理符号</li>\n</ul>\n<h3> 多态</h3>\n<p>多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。\n<code>C++</code> 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>\n<p>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 数据抽象</h2>\n<p>数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。\n数据抽象是一种依赖于接口和实现分离的编程（设计）技术。</p>\n<h2> 数据封装</h2>\n<h2> 接口（抽象类）</h2>\n<p>接口描述了类的行为和功能，而不需要完成类的特定实现。\nC++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。\n如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 \"= 0\" 来指定的，如下所示</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 抽象类的实例</h3>\n<p>基类 Shape 提供了一个接口 getArea()，在两个派生类 Rectangle 和 Triangle 中分别实现了 getArea()：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.599Z",
      "authors": [],
      "tags": [
        "学习"
      ]
    },
    {
      "title": "c++高级",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/c/cpp%E9%AB%98%E7%BA%A7.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/c/cpp%E9%AB%98%E7%BA%A7.html",
      "summary": "参考 https://www.runoob.com/cplusplus/cpp-files-streams.html 文件和流 要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 &lt;iostream&gt; 和 &lt;fstream&gt;。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.runoob.com/cplusplus/cpp-files-streams.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/cplusplus/cpp-files-streams.html</a></p>\n</div>\n<h2> 文件和流</h2>\n<p></p>\n<p>要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 <code>&lt;iostream&gt;</code> 和 <code>&lt;fstream&gt;</code>。</p>\n<h3> 打开文件</h3>\n<p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。</p>\n<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。</p>\n<p></p>\n<p>//todo</p>\n<h2> 异常处理</h2>\n<p>C++ 异常处理涉及到三个关键字：try、catch、throw。</p>\n<ul>\n<li>throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。</li>\n<li>catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。</li>\n<li>try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>\n</ul>\n<p>如果有一个块抛出一个异常，捕获异常的方法会使用 try 和 catch 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果 try 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 catch 语句，用于捕获不同类型的异常。</p>\n<h3> 抛出异常</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 捕获异常</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 标准的异常</h2>\n<p><code>C++</code> 提供了一系列标准的异常，定义在 <code>&lt;exception&gt;</code> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示</p>\n<h2> 命名空间</h2>\n<p>引入了命名空间这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。</p>\n<h3> 定义命名空间</h3>\n<p>命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> using 指令</h2>\n<p>您可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 模板</h2>\n<p>// todo</p>\n<h2> 信号处理</h2>\n<p>信号是由操作系统传给进程的中断，会提早终止一个程序。在 <code>UNIX、LINUX、Mac OS X</code> 或 <code>Windows</code> 系统上，\n可以通过按 <code>Ctrl+C </code>产生中断。</p>\n<p>有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。\n这些信号是定义在 <code>C++</code> 头文件 <code>&lt;csignal&gt;</code> 中</p>\n<p></p>\n<h2> 多线程</h2>\n<p>要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。</p>\n<h3> 创建线程</h3>\n<p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>thread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明：</p>\n<p></p>\n<p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p>\n<h3> 终止线程</h3>\n<p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在这里，<code>pthread_exit </code>用于显式地退出一个线程。通常情况下，<code>pthread_exit()</code> 函数是在线程完成工作后无需继续存在时被调用。</p>\n<p>如果 <code>main() </code>是在它所创建的线程之前结束，并通过 <code>pthread_exit()</code> 退出，那么其他线程将继续执行。否则，它们将在 <code>main() </code>结束时自动被终止。</p>\n<h2> Web 编程</h2>\n<p>什么是 CGI？</p>\n\n",
      "date_modified": "2023-08-03T23:47:30.605Z",
      "authors": [],
      "tags": [
        "学习"
      ]
    },
    {
      "title": "c基础",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/c/c%E5%9F%BA%E7%A1%80.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/c/c%E5%9F%BA%E7%A1%80.html",
      "summary": "参考 https://www.runoob.com/cplusplus/cpp-files-streams.html 版本 当前最新的 C 语言标准为 C18 ，在它之前的 C 语言标准有 C17、C11...C99 等。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.runoob.com/cplusplus/cpp-files-streams.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.runoob.com/cplusplus/cpp-files-streams.html</a></p>\n</div>\n<h2> 版本</h2>\n<p>当前最新的 C 语言标准为 C18 ，在它之前的 C 语言标准有 C17、C11...C99 等。</p>\n<h2> 开发工具</h2>\n<p>vscode\n插件 c c++ 、code-runner(可以解决 scanf 输入问题、兼容控制台，右键点击 run code)</p>\n<h2> 源码编译</h2>\n<h3> 一步编译</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 分步编译</h3>\n<p>1️⃣ 预处理 <br></p>\n<ul>\n<li>宏定义展开</li>\n<li>头文件展开</li>\n<li>条件编译</li>\n<li>删除注释</li>\n<li>不检查语法</li>\n</ul>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>2️⃣ 编译成汇编语言<br></p>\n<ul>\n<li>检查语法</li>\n<li>将 c 语言转成汇编语言</li>\n</ul>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>3️⃣ 汇编语言编译成机器语言（二进制文件）</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>4️⃣ 链接<br>\n将 c 语言库文件连接到可执行程序中</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 程序执行过程</h2>\n<p></p>\n<h2> CPU 内部结构与寄存器（了解）</h2>\n<h3> 64 位和 32 位系统区别</h3>\n<ul>\n<li>寄存器是 CPU 内部最基本的存储单元。</li>\n<li>CPU 对外是通过总线(地址、控制、数据)来和外部设备交互的，总线的宽度是 8 位，同时 CPU 的寄存器也是 8 位，那么这个 CPU 就叫 8 位 CPU.</li>\n<li>如果总线是 32 位，寄存器也是 32 位的，那么这个 CPU 就是 32 位 CPU</li>\n<li>有一种 CPU 内部的寄存器是 32 位的，但总线是 16 位，准 32 位 CPU</li>\n<li>所有的 64 位 CPU 兼容 32 位的指令， 32 位要兼容 16 位的指令，所以在 64 位的 CPU 上是可以识别 32 位的指令</li>\n<li>在 64 位的 CPU 构架上运行了 64 位的软件操作系统，那么这个系统是 64 位</li>\n<li>在 64 位的 CPU 构架上， 运行了 32 位的软件操作系统，那么这个系统就是 32 位</li>\n</ul>\n<h2> 寄存器名称（了解）</h2>\n<p></p>\n<h2> 寄存器、缓存、内存三者关系</h2>\n<p>按与 CPU 远近来分，离得最近的是寄存器，然后缓存(CPU 缓存)，最后内存。+\nCPU 计算时，先预先把要用的数据从硬盘读到内存，然后再把即将要用的数据读到寄存器。于是 CPU&lt;---&gt;寄存器&lt;---&gt;内存，这就是它们之间的信息交换。\n那为什么有缓存呢?因为如果经常操作内存中的同一址地的数据，就会影响速度。于是就在寄存器与内存之间设置一个缓存。“\n因为从缓存提取的速度远高于内存。当然缓存的价格肯定远远高于内存，不然的话，机器里就没有内存的存在。“\n由此可以看出，从远近来看: CPU(---) 寄存器《---&gt; 缓存 &lt;---&gt; 内存。“</p>\n<h2> C 语言内可以嵌套汇编语言</h2>\n<p></p>\n<p></p>\n<h2> 32 个关键字</h2>\n<ul>\n<li>数据类型关键字 (12 个)\nchar, short, int, long, float, double,\nunsigned, signed, struct, union, enum, void</li>\n</ul>\n<p>void* 万能指针</p>\n<ul>\n<li>控制语句关键字 (12 个)\nif, else, switch, case, default for, do, while, break, continue, goto, <code>return</code></li>\n<li>存储类关键字 (5 个)\nauto, extern, register, static, const</li>\n<li>其他关键字 (3 个)\n<code>sizeof</code>,<code>typedef</code> ,<code>volatile</code></li>\n</ul>\n<h3> 数据类型</h3>\n<p></p>\n<h3> 变量</h3>\n<p>//标识符:</p>\n<ul>\n<li>1、不能使用系统关键字</li>\n<li>2、允许使用字母数字下划线</li>\n<li>3、不允许数组开头</li>\n<li>4、标识符区分大小写</li>\n<li>5、见名知义</li>\n</ul>\n<h3> 全局变量</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 变量占用字节</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> int</h3>\n<div class=\"hint-container danger\">\n<p class=\"hint-container-title\">c 语言不能直接定义二进制数据</p>\n</div>\n<table>\n<thead>\n<tr>\n<th>打印格式</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%d</td>\n<td>输出一个<mark>有符号</mark>的 10 进制 int 类型</td>\n</tr>\n<tr>\n<td>%u</td>\n<td>输出一个 10 进制的<mark>无符号</mark>数数据</td>\n</tr>\n<tr>\n<td>%o(字母 o)</td>\n<td>输出 8 进制的 int 类型</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>输出 16 进制的 int 类型，字母以小写输出</td>\n</tr>\n<tr>\n<td>%X</td>\n<td>输出 16 进制的 int 类型，字母以大写输出</td>\n</tr>\n</tbody>\n</table>\n<h4> float</h4>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 常量</h3>\n<p>定义常量后，不能再赋值</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 定义常量</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> scanf 中断输入</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 数组</h3>\n<p>C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 枚举</h2>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container danger\">\n<p class=\"hint-container-title\">注意</p>\n<p>枚举不连续，不能遍历</p>\n</div>\n<p>方式 2</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 枚举类型在 switch 中的使用</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 结构体 struct</h2>\n<p>结构体定义由关键字 struct 和结构体名组成，结构体名可以根据需要自行定义。\nstruct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>tag 是结构体标签。\nmember-list 是标准的变量定义，比如 int i; 或者 float f;，或者其他有效的变量定义。\nvariable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 结构体的赋值与使用</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 指向结构体的指针</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 共用体</h2>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在这里，我们可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。</p>\n<h2> 类型转换</h2>\n<p>类型转换是将一个数据类型的值转换为另一种数据类型的值。</p>\n<p>C 语言中有两种类型转换：</p>\n\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 函数的定义</h2>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>函数的定义和调用顺序。</p>\n<p>函数在调用之前，必须先定义</p>\n</div>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 函数参数</h2>\n<p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。\n形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。\n当调用函数时，有两种向函数传递参数的方式：</p>\n<table>\n<thead>\n<tr>\n<th>调用类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>传值调用</td>\n<td>该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td>\n</tr>\n<tr>\n<td>引用调用</td>\n<td>通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td>\n</tr>\n</tbody>\n</table>\n<p>默认情况下，C 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p>\n<h2> typedef</h2>\n<p>C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>您也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> typedef vs #define</h2>\n<p>#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：</p>\n\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 指针</h2>\n<p>学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的。</p>\n<p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用 &amp; 运算符访问的地址，它表示了在内存中的一个地址。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出:</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p></p>\n<h3> 什么是指针？</h3>\n<p>指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var_name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。\n不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>\n<h3> 如何使用指针？</h3>\n<p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> NULL 指针</h3>\n<p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。</p>\n<p>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p>\n<p>如需检查一个空指针，您可以使用 if 语句，如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 预处理器</h2>\n<p>C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p>\n<p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>#define</td>\n<td>定义宏</td>\n</tr>\n<tr>\n<td>#include</td>\n<td>包含一个源代码文件</td>\n</tr>\n<tr>\n<td>#undef</td>\n<td>取消已定义的宏</td>\n</tr>\n<tr>\n<td>#ifdef</td>\n<td>如果宏已经定义，则返回真</td>\n</tr>\n<tr>\n<td>#ifndef</td>\n<td>如果宏没有定义，则返回真</td>\n</tr>\n<tr>\n<td>#if</td>\n<td>如果给定条件为真，则编译下面代码</td>\n</tr>\n<tr>\n<td>#else</td>\n<td>#if 的替代方案</td>\n</tr>\n<tr>\n<td>#elif</td>\n<td>如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>\n</tr>\n<tr>\n<td>#endif</td>\n<td>结束一个 #if……#else 条件编译块</td>\n</tr>\n<tr>\n<td>#error</td>\n<td>当遇到标准错误时，输出错误消息</td>\n</tr>\n<tr>\n<td>#pragma</td>\n<td>使用标准化方法，向编译器发布特殊的命令到编译器中</td>\n</tr>\n</tbody>\n</table>\n<h3> 预处理器实例</h3>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 定义为 20。使用 #define 定义常量来增强可读性。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这些指令告诉 CPP 从系统库中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 myheader.h，并添加内容到当前的源文件中。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 -DDEBUG 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。</p>\n<h3> 预定义宏</h3>\n<p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p>\n<table>\n<thead>\n<tr>\n<th>宏</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>DATE</strong></td>\n<td>当前日期，一个以 \"MMM DD YYYY\" 格式表示的字符常量。</td>\n</tr>\n<tr>\n<td><strong>TIME</strong></td>\n<td>当前时间，一个以 \"HH:MM:SS\" 格式表示的字符常量。</td>\n</tr>\n<tr>\n<td><strong>FILE</strong></td>\n<td>这会包含当前文件名，一个字符串常量。</td>\n</tr>\n<tr>\n<td><strong>LINE</strong></td>\n<td>这会包含当前行号，一个十进制常量。</td>\n</tr>\n<tr>\n<td><strong>STDC</strong></td>\n<td>当编译器以 ANSI 标准编译时，则定义为 1。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 预处理器运算符</h3>\n<p>C 预处理器提供了下列的运算符来帮助您创建宏：\n宏延续运算符（\\）</p>\n<p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\\）。例如：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>字符串常量化运算符（#）</p>\n<p>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>标记粘贴运算符（##）</p>\n\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。\ndefined() 运算符</p>\n<p>预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 参数化的宏</h3>\n<p>CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们可以使用宏重写上面的代码，如下：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 头文件</h2>\n<p>头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。</p>\n<p>有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。\n在程序中要使用头文件，需要使用 C 预处理指令 #include 来引用它。前面我们已经看过 stdio.h 头文件，它是编译器自带的头文件。</p>\n<p>引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。</p>\n<p>A simple practice in C 或 C++ 程序中，<u>建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件</u>。</p>\n<h3> 引用头文件的语法</h3>\n<p>使用预处理指令 #include 可以引用用户和系统头文件。它的形式有以下两种：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p>\n<h3> 只引用一次头文件</h3>\n<p>如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种结构就是通常所说的包装器 #ifndef。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。</p>\n<h3> 有条件引用</h3>\n<p>有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的有条件引用。它不是用头文件的名称作为 #include 的直接参数，您只需要使用宏名称代替即可：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 #include 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。</p>\n<h2> 错误处理</h2>\n<p>C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。</p>\n<p>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。</p>\n<h3> errno、perror() 和 strerror()</h3>\n<p>C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。</p>\n\n<p>让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 stderr 文件流来输出所有的错误。</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 内存管理</h2>\n<p>C 中的动态内存管理。C 语言为内存的分配和管理提供了几个函数。这些函数可以在 <code>&lt;stdlib.h&gt;</code> 头文件中找到。</p>\n<p>在 C 语言中，内存是通过指针变量来管理的。指针是一个变量，它存储了一个内存地址，这个内存地址可以指向任何数据类型的变量，包括整数、浮点数、字符和数组等。C 语言提供了一些函数和运算符，使得程序员可以对内存进行操作，包括分配、释放、移动和复制等。</p>\n<p></p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>void* 类型表示未确定类型的指针。C、C++ 规定 void _ 类型可以通过类型转换强制转换为任何其它类型的指针。</p>\n</div>\n<h3> 动态分配内存</h3>\n<p>编程时，如果您预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>但是，如果您预先不知道需要存储的文本长度，例如您想存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。</p>\n<h3> 重新调整内存的大小和释放内存</h3>\n<p>当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 free() 来释放内存。\n或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：</p>\n<div class=\"language-c line-numbers-mode\" data-ext=\"c\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> C 语言中常用的内存管理函数和运算符</h3>\n<ul>\n<li>\n<p>malloc() 函数：用于动态分配内存。它接受一个参数，即需要分配的内存大小（以字节为单位），并返回一个指向分配内存的指针。</p>\n</li>\n<li>\n<p>free() 函数：用于释放先前分配的内存。它接受一个指向要释放内存的指针作为参数，并将该内存标记为未使用状态。</p>\n</li>\n<li>\n<p>calloc() 函数：用于动态分配内存，并将其初始化为零。它接受两个参数，即需要分配的内存块数和每个内存块的大小（以字节为单位），并返回一个指向分配内存的指针。</p>\n</li>\n<li>\n<p>realloc() 函数：用于重新分配内存。它接受两个参数，即一个先前分配的指针和一个新的内存大小，然后尝试重新调整先前分配的内存块的大小。如果调整成功，它将返回一个指向重新分配内存的指针，否则返回一个空指针。</p>\n</li>\n<li>\n<p>sizeof 运算符：用于获取数据类型或变量的大小（以字节为单位）。</p>\n</li>\n<li>\n<p>指针运算符：用于获取指针所指向的内存地址或变量的值。</p>\n</li>\n<li>\n<p>&amp; 运算符：用于获取变量的内存地址。</p>\n</li>\n<li>\n<p><code>*</code> 运算符：用于获取指针所指向的变量的值。</p>\n</li>\n<li>\n<p>-&gt; 运算符：用于指针访问结构体成员，语法为 pointer-&gt;member，等价于 (*pointer).member。</p>\n</li>\n<li>\n<p>memcpy() 函数：用于从源内存区域复制数据到目标内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）。</p>\n</li>\n<li>\n<p>memmove() 函数：类似于 memcpy() 函数，但它可以处理重叠的内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）。</p>\n</li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:30.653Z",
      "authors": [],
      "tags": [
        "学习"
      ]
    },
    {
      "title": "字符集和字符编码",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/charset/charset.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/charset/charset.html",
      "summary": "参考 ASCII 字符集 和 ASCII编码 美国人把自己使用的所有字符编成 ASCII 字符集，从0 ~ 127 (称ASCII 码)一共128个字符，然后把这128的字符，以二进制的方式（以一个字节方式）存在的计算机中， 二进制的开头是以 0 开头。 GBK 字符集 和GBK 编码",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n</div>\n<h2> ASCII 字符集 和 ASCII编码</h2>\n<p></p>\n<p></p>\n<p>美国人把自己使用的所有字符编成<u> ASCII 字符集</u>，从0 ~ 127 (<u>称ASCII 码</u>)一共128个字符，然后把这128的字符，以<u>二进制</u>的方式（<u>以一个字节方式</u>）存在的计算机中，\n二进制的开头是以 <u>0</u> 开头。</p>\n<h2> GBK 字符集 和GBK 编码</h2>\n<p></p>\n<p>GKB 字符集是对 ASCII 的扩充，兼容了 ASCII ,一共存储了2万多汉字字，一个汉字占2个字节，用二进制表示式，二进制是以1 开头，以1开头的二进制是 负数。</p>\n<p>2个字节一个能存 2<sup>15</sup> = 32786 个汉字</p>\n<h2> Uicode 字符集 和Unicode 编码（UTF-8）</h2>\n<p></p>\n<p>每个国家都有自己的字符集，比较乱，所有国际组织提出了 Unicode 字符集，来统一管理全世界的字符，最终使用的是 UTF-8 可变长的编码方式。\n即 英文 占一个字符 ，汉字占 3 个字节，存储在计算机中。</p>\n<p></p>\n<p></p>\n<h2> java 字符集编码解码</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.655Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "跨域",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/cors/%E8%B7%A8%E5%9F%9F.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/cors/%E8%B7%A8%E5%9F%9F.html",
      "summary": "参考 跨域产生的原因 浏览器的同源策略 协议 域名 端口 不一样时，请求接口会产生跨域 例如在 http://localhost:8080 中前端服务中，请求 http://localhost:8888 的接口，就会跨域 解决方案 1 在前端开发框架中，通过代理，把接口转发到 真实的后端服务，此时，后端接口，不要配置跨域 vue-cli 项目中的配置",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n</div>\n<h2> 跨域产生的原因</h2>\n<p>浏览器的同源策略</p>\n<p>协议 域名 端口 不一样时，请求接口会产生跨域</p>\n<p>例如在 http://localhost:8080 中前端服务中，请求 http://localhost:8888 的接口，就会跨域</p>\n<h2> 解决方案</h2>\n<h3> 1 在前端开发框架中，通过代理，把接口转发到 真实的后端服务，此时，后端接口，不要配置跨域</h3>\n<p>vue-cli 项目中的配置</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.657Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "常见算法",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/datastruct/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/datastruct/%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95.html",
      "summary": "源码 源码 排序 冒泡排序 平均时间复杂度：O(n2) 空间复杂度：O(1) (用于交换)",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">源码</p>\n<p><a href=\"https://github.com/lyyitit/java-data-structure/tree/master/src/main/java/com/lojzes\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a></p>\n</div>\n<h2> 排序</h2>\n<h3> 冒泡排序</h3>\n<p>平均时间复杂度：O(n<sup>2</sup>)</p>\n<p>空间复杂度：O(1) (用于交换)</p>\n<p>稳定性：稳定</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 选择排序</h3>\n<p>平均时间复杂度：O(n<sup>2</sup>)</p>\n<p>空间复杂度：O(1)  (用于交换和记录索引)</p>\n<p>不稳定</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 快速排序</h3>\n<p>最坏时间复杂度 O(n<sup>2</sup>)</p>\n<p>平均复杂度 O(nlogn)</p>\n<p>空间复杂度O(logn)</p>\n<p>不稳定</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 合并两个有序数组</h3>\n<p>平均时间复杂度：O(m + n)</p>\n<p>空间复杂度：O(1)</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 查找</h2>\n<h3> 二分查找</h3>\n<h3> 递归法</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 迭代法</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 链表相关操作</h2>\n<h3> 单链表翻转</h3>\n<h4> 迭代法</h4>\n<p>时间复杂度O（n）</p>\n<p>空间复杂度 O（1）</p>\n<p>假设存在链表 <code>1 → 2 → 3 → Ø</code>，我们想要把它改成 <code>Ø ← 1 ← 2 ← 3</code>。</p>\n<p>在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。\n在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 递归法</h3>\n<p>时间复杂度 O(n)</p>\n<p>空间复杂度 O(n)</p>\n<p><code>n1 -&gt; n2 -&gt; n3 -&gt; ...-&gt; nk -&gt; n(k+1) &gt; -&gt;nm</code></p>\n<p>从后向前反转。假设链表后面的节点已反转完毕，如何反转当前节点及之前的部分？\n<code> n1 -&gt; n2 -&gt; n3 -&gt; ...-&gt; nk -&gt; n(k+1) &lt;- nm</code>\n假设从 <code>k+1</code> 已经反转\n那么，希望 <code>n(k + 1)</code> 的下一个节点 指向 <code>n(k)</code>\n即\n<code> nk.next.next = nk</code></p>\n<p>最后 <code>n1</code> 的下一个节点必须是 <code>null</code>,\n即：<code>n1.next = null</code></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 链表取中间值</h3>\n<h3> 数组法</h3>\n<p>时间复杂度：O(N)，其中 N 是给定列表的结点数目。</p>\n<p>空间复杂度：O(N)， 数值用去的空间</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 快慢指针法</h3>\n<p>时间复杂度：O(N)，其中 N 是给定列表的结点数目。</p>\n<p>空间复杂度：O(1)，slow 和 fast 用去的空间。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 合并两个有序链表</h3>\n<h4> 递归法</h4>\n<p>两个链表头部较小的一个与剩下元素的 merge 操作结果合并。\n*\n* 算法 我们直接将以上递归过程建模，首先考虑边界情况。 特殊的，如果 l1 或者 l2 一开始就是 null ，\n* 那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，\n* 然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。</p>\n<p>时间复杂度 O(m + n)</p>\n<p>空间复杂度 O(m + n)</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 迭代法</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.674Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "排序",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/datastruct/%E6%8E%92%E5%BA%8F.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/datastruct/%E6%8E%92%E5%BA%8F.html",
      "summary": "参考 https://www.cnblogs.com/onepixel/articles/7674659.html https://github.com/MisterBooo/Article",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.cnblogs.com/onepixel/articles/7674659.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>\n<p><a href=\"https://github.com/MisterBooo/Article\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/MisterBooo/Article</a></p>\n</div>\n<p>排序算法可以分为内部排序和外部排序。\n内部排序是数据记录在内存中进行排序。\n而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。\n常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p>\n<p></p>\n<h2> 相关概念</h2>\n<ul>\n<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>\n<li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>\n<li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>\n<li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>\n</ul>\n<h2> 冒泡排序</h2>\n<ul>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>\n</ul>\n<p></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.676Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "数据结构",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/datastruct/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/datastruct/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",
      "summary": "参考 https://zhuanlan.zhihu.com/p/363418853 等差数列 等比数列",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/363418853\" target=\"_blank\" rel=\"noopener noreferrer\">https://zhuanlan.zhihu.com/p/363418853</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97\" target=\"_blank\" rel=\"noopener noreferrer\">等差数列</a></p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97\" target=\"_blank\" rel=\"noopener noreferrer\">等比数列</a></p>\n</div>\n<h2> 数学基础</h2>\n<p>数学知识，数学是基础. 可以理解成计算机是数学的一个发展应用方向</p>\n<h3> 等差数列及求和</h3>\n<p>在等差数列中，任何相邻两项的差相等，该差值称为公差（common difference）。</p>\n<p>例如数列：</p>\n\n<p>就是一个等差数列。 在这个数列中，从第二项起，每项与其前一项之公差都相等 。</p>\n<h4> 等差数列求和</h4>\n<p>一个等差数列的首 n 项之和，称为等差数列和（sum of arithmetic sequence）或算术级数（arithmetic series），记作 Sn。</p>\n<p>等差数列：</p>\n<p>{ a , a + d, a + 2d , ... a + (n - 1)d}</p>\n<p>举例来说，等差数列 {1, 3, 5, 7} 的和是 1 + 3 + 5 + 7 = 16。</p>\n<p>举例来说，等差数列 {1, 2, 3, 4} 的和是 1 + 2 + 3 + 4 = 10。</p>\n<p>前n项和\na<sub>1</sub> + a<sub>2</sub> + a<sub>3</sub> + a<sub>4</sub> + ......a<sub>n</sub></p>\n<p class=\"katex-block\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.9535em;vertical-align:-1.3021em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6514em;\"><span style=\"top:-1.8479em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.05em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3021em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361em;\"><span style=\"top:-2.55em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/2</span></span></span></span></span></p>\n<p>即： <code>（首 + 尾）* 相数 / 2</code></p>\n<h3> 等比数列及求和</h3>\n<p>等比数列，又名几何数列（英语：Geometric progression），是数列的一种。在等比数列中，任何相邻两项的比例相等，该比值称为公比。</p>\n<p>例如数列：</p>\n\n<p>就是一个等比数列。在这个数列中，从第二项起，每项与其前一项之公比都等于 2 2。</p>\n<p>等比数列表示：</p>\n<p>{a , ar , ar<sup>2</sup>, ... ar<sup>n-1</sup>}</p>\n<p class=\"katex-block\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8333em;vertical-align:-0.15em;\"></span><span class=\"mspace\">&nbsp;</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.1514em;\"><span style=\"top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.2604em;vertical-align:-0.7693em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.4911em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p>r 为：公比</p>\n<h3> 求和公式及性质</h3>\n<h3> 平方和与立方和公式</h3>\n<p class=\"katex-block\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.9535em;vertical-align:-1.3021em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6514em;\"><span style=\"top:-1.8479em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.05em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3021em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/6</span></span></span></span></span></p>\n<p class=\"katex-block\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.9535em;vertical-align:-1.3021em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6514em;\"><span style=\"top:-1.8479em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.05em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3021em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1141em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1141em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mord\">/4</span></span></span></span></span></p>\n<h3> 几何级数</h3>\n<p class=\"katex-block\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.9535em;vertical-align:-1.3021em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6514em;\"><span style=\"top:-1.8479em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.05em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.3021em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8991em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7278em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.9474em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7144em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<h2> 数学归纳法</h2>\n<h2> 数据结构</h2>\n<h2> 逻辑分类</h2>\n<h3> 集合结构</h3>\n<h2> 数组</h2>\n<p>数组内的元素是连续存储的，所有数组中的元素地址是根据索引计算出来的。\n例如</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>知道了数组起始地址 BaseAddress ,就可以通过公式 BaseAddress + i * size 计算出\n元素 i 索引对于的元素的地址</p>\n<ul>\n<li>i 索引，从0 开始</li>\n<li>size 没每个元素占用的字节，例如 int 占用 4个字节，double 占8 个字节</li>\n</ul>\n<p></p>\n",
      "date_modified": "2023-08-03T23:47:30.691Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "设计模式的应用",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/designpattern/apply.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/designpattern/apply.html",
      "summary": "参考 设计模式在业务系统中的应用 线路检查工具 1 意义 为什么需要线路检查工具呢，有以下几个方面的原因： 每逢大促都需要进行各网络和各行业的线路调整，调整完成之后，是否得到期望状态，需要检查确认。 上下游应用之间数据的一致性检查，如果存在不一致，可能会在订单履行时造成卡单。 有些问题发生后，业务同学需要全面检查一遍线路数据，判断是否符合预期。 各领域之间的数据变更缺乏联动性，导致资源和线路出现不一致。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://developer.aliyun.com/article/785815\" target=\"_blank\" rel=\"noopener noreferrer\">设计模式在业务系统中的应用</a></p>\n</div>\n<h2> 线路检查工具</h2>\n<p>1 意义</p>\n<p>为什么需要线路检查工具呢，有以下几个方面的原因：</p>\n\n<p>为什么要把线路检查工具产品化呢，考虑如下：</p>\n\n<p>2 检查项</p>\n<p>根据2020年D11进行的数据检查，本次共实现8项，下面列举了4项，如下：</p>\n\n<p>好了，了解了背景知识，下面开始介绍所用到的设计模式，以及为什么要用、怎么用。</p>\n<h2> 设计模式</h2>\n<h3> 模板方法模式+泛型</h3>\n<p>1 模板方法模式+泛型</p>\n<p>上述8项数据检查工具，大致的处理流程是类似的，如下：</p>\n<p></p>\n<p>针对不同的检查工具，只有“线路数据检查”这一步是不一样的逻辑，其他步骤都是相同的，如果每个检查工具都实现这么一套逻辑，必定造成大量的重复代码，维护性较差。</p>\n<p>模板方法模式能够很好地解决这个问题。模板方法设计模式包含模板方法和基本方法，模板方法包含了主要流程；基本方法是流程中共用的逻辑，如创建检查任务，结果输出等等。</p>\n<p>下图是所实现的模板方法模式的类继承关系：</p>\n<p></p>\n<p>分析如下：</p>\n<p>1）DataCheckProductService接口为对外提供的服务，dataCheck方法为统一的数据检查接口。</p>\n<p>2）AbstractDataCheckProductService是一个抽象类，设定模板，即在dataCheck方法中设定好流程，包括如下：</p>\n\n<p>dataCheck方法为模板方法，runDataCheck方法由各个子类去实现，其他方法是基本方法。还有一些其他方法，是各个检查工具都需要使用的，所以就放在了父类中。</p>\n<p>3）CheckSupplierAndCodeMappingService类、CheckLandingCoverAreaService类和CheckAncPathNoServiceService类为具体的检查工具子类，必须实现runDataCheck方法</p>\n<p>因为不同检查项检的查结果的格式是不一样的，所以使用了泛型，使得可以兼容不同的检查结果。</p>\n<p>简化的代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用模板方法模式的好处是：</p>\n\n<h3> 策略模式</h3>\n<p>之所以会用到策略模式，是因为一些检查工具写完之后，发现跑出来的结果数据太多，有几万、几十万等等，一方面，检查比较耗时，结果文件会很大，下载耗时；另一方面，这么多数据给到业务同学，他们也很难处理和分析，也许他们只是想看一下总体情况，并不想看具体的到哪个地方的线路。为此，在原先方案设计的基础上，增加了“统计信息”的选项，让用户可以自行选择“详细信息”还是“统计信息”，对应到页面上就是一个单选框，如下：</p>\n<p></p>\n<p>现在增加了一种检查方式，今后是否还会有其他的检查方式？完全有可能的。所以得考虑到扩展性，便于后面同学增加新的检查方式。</p>\n<p>此外，还有一种场景也可以使用策略模式，那就是业务系统中有很多业务网络，不同网络之间有一些差异；本次所实现的检查工具，有几个涉及到多个网络，今后可能会涉及到所有网络。</p>\n<p>综合以上两种场景，最合适的就是策略模式了。“详细信息”和“统计信息”各采用一种策略，不同网络使用不同的策略，既便于代码理解，又便于后续扩展。</p>\n<p>“详细信息”和“统计信息”两种检查结果的策略类图如下：</p>\n<p></p>\n<p>解析：</p>\n<p>CompareModeStrategy对外提供统一的结果处理接口doHandle，策略子类必须实现此接口。\nSupplierAndCodeMappingStatisticsStrategy和SupplierAndCodeMappingDetailStrategy是检查配送资源和编码映射一致性的两种结果信息方式，前者为统计方式，后者为详细方式。\nLandingCoverAreaStatisticsStrategy和LandingCoverAreaDetailStrategy是检查落地配覆盖范围的两种结果信息方式，前者为统计方式，后者为详细方式。\n那AbstractCompareModeStrategy是干什么用的？它是一个抽象类，负责承接所有策略子类共用的一些方法。</p>\n<p>简化的代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同样，不同网络的处理策略类图如下</p>\n<p></p>\n<p>代码与上面类似，就不展示了。</p>\n<p>使用策略模式的好处是：</p>\n\n<h3> 工厂模式</h3>\n<p>工厂模式解决的是bean的生产问题，简单工厂模式根据入参生产不同的bean，普通工厂模式针对每个bean都构建一个工厂，此两者各有优劣，看需要。本方案采用的是简单工厂模式。</p>\n<p>之所以使用工厂模式，是因为有太多的bean需要构造，如果在业务逻辑中构造各种bean，则会显得凌乱和分散，所以需要一个统一生成bean的地方，更好地管理和扩展。</p>\n<p>本方案中主要有三类bean需要工厂来生成：</p>\n\n<p>所以，使用三个工厂分别构造这三种类型的bean。另外，因为每个bean主要的功能都在方法中，不涉及类变量的使用，所以可以利用spring容器生成的bean，而不是我们自己new出来，这样就使得bean可以重复使用。因此，这里的工厂只是bean的决策（根据参数决定使用哪个bean），不用自己new了。</p>\n<p>三个工厂分别如下：</p>\n<p>DataCheckProductFatory：由getDataCheckProductService方法根据输入参数决策使用哪个数据检查工具。\nCompareModeStrategyFactory：用于决策使用哪种格式输出，因为将输出策略分为了2类（详细信息和统计信息），所以需要传入两个参数才能决定使用哪种策略。\nDataCheckNetworkStrategyFactory：用于决策使用哪种网络处理策略，因为将策略分为了2类（4PL网络和其他网络），所以需要传入两个参数才能决定使用哪种策略。</p>\n<p>\n\n</p>\n<p>这三个工厂的代码类似，这里就以CompareModeStrategyFactory为例，简化的代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用工厂模式的好处是：</p>\n\n<h3> “代理模式”</h3>\n<p>这个代理模式是打着双引号的，因为不是真正的代理模式，只是从实现方式上来说，具有代理模式的意思。为什么需要用到代理模式？是因为类太多了，业务逻辑分散在各个类中，有的在模板子类中，有的在网络策略中，有的在结果输出格式策略中，而这些业务逻辑都需要多线程执行和异常捕获。如果有个代理类，能够收口这些处理逻辑，只需增加前置多线程处理和后置异常处理即可。</p>\n<p>Java语言中的函数式编程，具备这种能力。所谓函数式编程，是指能够将方法当做参数传递给方法，前面“方法”是业务逻辑，后面“方法”是代理，将业务逻辑传递给代理，就实现了统一收口的目的。</p>\n<p>能够实现此功能的接口有四个，分别是：Consumer、Supplier、Predicate与Function，怎么使用可以网上查询。本方案使用的是Consumer，因为它是用来消费的，即需要传入一个参数，没有返回值，符合本方案的设计。</p>\n<p>简化后的代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看出，Consumer所代表的就是一个方法，将此方法作为parallelCheckByFromResCodes方法的一个参数，在parallelCheckByFromResCodes中进行多线程和异常处理，既能统一收口，又大大减少了重复代码。</p>\n<p>代理模式的好处是：</p>\n\n<h3> 其他</h3>\n<p>像结果输出格式策略模式那样，虽然AbstractCompareModeStrategy没有实际的业务逻辑，但仍然把它作为一个基类，目的是所有子类共用的逻辑或方法，能够放在此类中，减少代码量，提升维护性。</p>\n<p>但是有的时候，不是继承自同一个基类的子类们，仍然要共用一些逻辑或方法（如parallelCheckByFromResCodes方法），但Java语言限制一个类只能继承一个基类，怎么办呢？简单的办法就是把这些共用逻辑或方法放到一个工具类（如DataCheckUtils）中。</p>\n<p>总结以下几点：</p>\n\n",
      "date_modified": "2023-08-03T23:47:30.716Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "设计模式",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/designpattern/%E5%9F%BA%E7%A1%80.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/designpattern/%E5%9F%BA%E7%A1%80.html",
      "summary": "参考 源码 设计原则 单一原(Single Responsibility Principle，简称SRP） 核心思想：应该有且仅有一个原因引起类的变更问题描述：假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。好处：类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。需注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“责”和“变化原因”都是不可以度量的，因项目和环境而异。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://github.com/lyyitit/java-design-patterns\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a></p>\n</div>\n<h2> 设计原则</h2>\n<h3> 单一原(Single Responsibility Principle，简称SRP）</h3>\n<p>核心思想：应该有且仅有一个原因引起类的变更问题描述：假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。好处：类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。需注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“责”和“变化原因”都是不可以度量的，因项目和环境而异。</p>\n<h3> 接口隔离原则（Interface Segregation Principle）</h3>\n<p>使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>\n<h3> 依赖倒转原则（Dependence Inversion Principle）</h3>\n<p>这个原则是开闭原则的基础，具体内容：针对对接口编程，依赖于抽象而不依赖于具体。使用接口和抽象类的目的是制定好规范，而不涉及具体的操作，由具体的子类或实现类去实现。</p>\n<h3> 开闭原则（Open Close Principle）</h3>\n<p><u>对扩展开放，对修改关闭</u>。在程序需要进行拓展的时候，不要（或者尽量修改少的代码）去修改原有的代码，要通过扩展的方法来实现功能变化。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p>\n<h3> 里氏代换原则（Liskov Substitution Principle）</h3>\n<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n在使用继承时，尽量不重写父类非抽象的方法。\n继承关系增强了类之间耦合关系，在适当的情况下可以使用聚合、组合、依赖来解决。</p>\n<h3> 迪米特法则，最少知道原则（Demeter Principle）</h3>\n<p>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n只与直接朋友通讯。\n直接朋友：类之间的耦合关系称之为朋友关系，耦合的关系很多，如聚合、组合、依赖等。其中，成员变量、方法参数、返回类型称之为直接朋友。而出现在局部变量中的类（我只要结果，不需要知道完成的过程，此过程要封装，此处指提供一个public 方法即可）不是直接朋友</p>\n<h3> 合成复用原则（Composite Reuse Principle）</h3>\n<p>量使用合成/聚合的方式，而不是使用继承。</p>\n",
      "date_modified": "2023-08-03T23:47:30.717Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "dubbo",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/dubbo/dubbo.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/dubbo/dubbo.html",
      "summary": "参考 dubbo 负载均衡策略解析 dubbo的负载均衡以及配置方式补充 Dubbo面试题",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.cnblogs.com/yougewe/p/12734558.html\" target=\"_blank\" rel=\"noopener noreferrer\">dubbo 负载均衡策略解析</a></p>\n<p><a href=\"https://blog.51cto.com/u_15127568/4356830\" target=\"_blank\" rel=\"noopener noreferrer\">dubbo的负载均衡以及配置方式补充</a></p>\n<p><a href=\"https://juejin.cn/post/6844904127076499463\" target=\"_blank\" rel=\"noopener noreferrer\">Dubbo面试题</a></p>\n</div>\n<h2> 负载均衡</h2>\n<p><code>Dubbo</code>官方为我们提供了四种负载均衡策略，分别是<code>随机策略、轮询策略、最少活跃调用数策略</code>和<code>一致性 Hash策略</code>。如果我们不指定负载均衡策略，默认情况下为<code>随机策略</code>。</p>\n<ul>\n<li>\n<p>RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的默认负载均衡策略。</p>\n</li>\n<li>\n<p>RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。</p>\n</li>\n<li>\n<p>LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机。活跃数指调用前后计数差。使慢的 Provider 收到更少请求，因为越慢的 Provider 的调用前后计数差会越大。</p>\n</li>\n<li>\n<p>ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。</p>\n</li>\n</ul>\n<h2> 如何配置dubbo负载均衡策略？</h2>\n<p>有多种级别的配置：服务端服务/方法级别、客户端服务/方法级别; 具体配置如下:</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Dubbo 核心功能有哪些？</h2>\n<ul>\n<li>Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。</li>\n<li>Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li>\n<li>Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li>\n</ul>\n<h2> Dubbo 核心组件有哪些？</h2>\n<p></p>\n\n<h2> Dubbo 服务器注册与发现的流程？</h2>\n<ul>\n<li>服务容器 Container 负责启动，加载，运行服务提供者。</li>\n<li>服务提供者 Provider 在启动时，向注册中心注册自己提供的服务。</li>\n<li>服务消费者 Consumer 在启动时，向注册中心订阅自己所需的服务。</li>\n<li>注册中心 Registry 返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>\n<li>服务消费者 Consumer，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>\n<li>服务消费者 Consumer 和提供者 Provider，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 Monitor。</li>\n</ul>\n<h2> Dubbo 的整体架构设计有哪些分层?</h2>\n<p></p>\n<ul>\n<li>接口服务层（Service）：该层与业务逻辑相关，根据 provider 和 consumer 的业务设计对应的接口和实现</li>\n<li>配置层（Config）：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心</li>\n<li>服务代理层（Proxy）：服务接口透明代理，生成服务的客户端 Stub 和 服务端的 Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>\n<li>服务注册层（Registry）：封装服务地址的注册和发现，以服务 URL 为中心，扩展接口为 RegistryFactory、Registry、RegistryService</li>\n<li>路由层（Cluster）：封装多个提供者的路由和负载均衡，并桥接注册中心，以Invoker 为中心，扩展接口为 Cluster、Directory、Router 和 LoadBlancce</li>\n<li>监控层（Monitor）：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory、Monitor 和 MonitorService</li>\n<li>远程调用层（Protocal）：封装 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocal、Invoker 和 Exporter</li>\n<li>信息交换层（Exchange）：封装请求响应模式，同步转异步。以 Request 和Response 为中心，扩展接口为 Exchanger、ExchangeChannel、ExchangeClient 和 ExchangeServer</li>\n<li>网络 传输 层（Transport）：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel、Transporter、Client、Server 和 Codec</li>\n<li>数据序列化层（Serialize）：可复用的一些工具，扩展接口为 Serialization、ObjectInput、ObjectOutput 和 ThreadPool</li>\n</ul>\n<h2> Dubbo 和 Spring Cloud 有什么关系？</h2>\n<p>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。</p>\n<p>而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spring、Spring Boot 的优势之上，</p>\n<p>两个框架在开始目标就不一致，Dubbo 定位服务治理、Spring Cloud 是打造一个生态。</p>\n<h2> Dubbo 和 Spring Cloud 有什么哪些区别？</h2>\n<p>Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于 TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。</p>\n<p>Spring Cloud 是基于 Http 协议 Rest 接口调用远程过程的通信，相对来说 Http 请求会有更大的报文，占的带宽也会更多。但是 REST 相比</p>\n<p>RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重</p>\n<p>通信速度还是方便灵活性，具体情况具体考虑。</p>\n<h2> Dubbo 有哪些注册中心？</h2>\n<ul>\n<li>Multicast 注册中心：Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现,基于网络中组播传输实现。</li>\n<li>Zookeeper 注册中心：基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 watch 机制实现数据变更。</li>\n<li>Redis 注册中心：基于 Redis 实现，采用 key/map 存储，key 存储服务名和类型，map 中 key 存储服务 url，value 服务过期时间。基于 Redis 的发布/订阅模式通知数据变更。</li>\n<li>Simple 注册中心。\n推荐使用 Zookeeper 作为注册中心</li>\n</ul>\n<h2> Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？</h2>\n<p>可以通讯。启动 Dubbo 时，消费者会从 Zookeeper 拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。</p>\n<h2> Dubbo集群提供了哪些负载均衡策略？</h2>\n<ul>\n<li>Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。</li>\n<li>RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题。</li>\n<li>LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求。</li>\n<li>ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。</li>\n</ul>\n<p>默认为 Random 随机调用。</p>\n<h2> Dubbo的集群容错方案有哪些？</h2>\n<ul>\n<li>Failover Cluster：失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。</li>\n<li>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li>\n<li>Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li>\n<li>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li>\n<li>Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2″ 来设置最大并行数。</li>\n<li>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li>\n</ul>\n<p>默认的容错方案是 Failover Cluster。</p>\n<h2> Dubbo 配置文件是如何加载到 Spring 中的？</h2>\n<p>Spring 容器在启动的时候，会读取到 Spring 默认的一些 schema 以及 Dubbo 自定义的 schema，每个 schema 都会对应一个自己的 NamespaceHandler，NamespaceHandler 里面通过 BeanDefinitionParser 来解析配置信息并转化为需要加载的 bean 对象！</p>\n<h2> Dubbo 超时设置有哪些方式？</h2>\n<h3> Dubbo 超时设置有两种方式：</h3>\n<p>服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。</p>\n<p>服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。</p>\n<h3> 服务调用超时会怎么样？</h3>\n<p>dubbo 在调用服务不成功时，默认是会重试两次。</p>\n<h2> 通信协议</h2>\n<h3> Dubbo 使用的是什么通信框架?</h3>\n\n<h3> Dubbo 支持哪些协议，它们的优缺点有哪些？</h3>\n<ul>\n<li>\n<p>Dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步 Hessian 序列化。Dubbo推荐使用dubbo协议。</p>\n</li>\n<li>\n<p>RMI： 采用 JDK 标准的 RMI 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 Java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接 TCP 协议传输，同步传输，适用常规的远程服务调用和 RMI 互操作。在依赖低版本的 Common-Collections 包，Java 序列化存在安全漏洞。</p>\n</li>\n<li>\n<p>WebService：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用。</p>\n</li>\n<li>\n<p>HTTP： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用。</p>\n</li>\n<li>\n<p>Hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。</p>\n</li>\n<li>\n<p>Memcache：基于 Memcache实现的 RPC 协议。</p>\n</li>\n<li>\n<p>Redis：基于 Redis 实现的RPC协议。</p>\n</li>\n</ul>\n<h2> 设计模式</h2>\n<h3> Dubbo 用到哪些设计模式？</h3>\n<p>Dubbo 框架在初始化和通信过程中使用了多种设计模式，可灵活控制类加载、权限控制等功能。</p>\n<p>工厂模式</p>\n\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>装饰器模式</p>\n<p>Dubbo 在启动和调用阶段都大量使用了装饰器模式。以 Provider 提供的调用链为例，具体的调用链代码是在 ProtocolFilterWrapper 的 buildInvokerChain 完成的，具体是将注解中含有 group=provider 的 Filter 实现，按照 order 排序，最后的调用顺序是：</p>\n<p>EchoFilter -&gt; ClassLoaderFilter -&gt; GenericFilter -&gt; ContextFilter -&gt;\nExecuteLimitFilter -&gt; TraceFilter -&gt; TimeoutFilter -&gt; MonitorFilter -&gt;\nExceptionFilter</p>\n<p>更确切地说，这里是装饰器和责任链模式的混合使用。例如，EchoFilter 的作用是判断是否是回声测试请求，是的话直接返回内容，这是一种责任链的体现。而像ClassLoaderFilter 则只是在主功能上添加了功能，更改当前线程的 ClassLoader，这是典型的装饰器模式。</p>\n<p>观察者模式</p>\n<p>Dubbo 的 Provider 启动时，需要与注册中心交互，先注册自己的服务，再订阅自己的服务，订阅时，采用了观察者模式，开启一个 listener。注册中心会每 5 秒定时检查是否有服务更新，如果有更新，向该服务的提供者发送一个 notify 消息，provider 接受到 notify 消息后，运行 NotifyListener 的 notify 方法，执行监听器方法。</p>\n<p>动态代理模式</p>\n<p>Dubbo 扩展 JDK SPI 的类 ExtensionLoader 的 Adaptive 实现是典型的动态代理实现。Dubbo 需要灵活地控制实现类，即在调用阶段动态地根据参数决定调用哪个实现类，所以采用先生成代理类的方法，能够做到灵活的调用。生成代理类的代码是 ExtensionLoader 的 createAdaptiveExtensionClassCode 方法。代理类主要逻辑是，获取 URL 参数中指定参数的值作为获取实现类的 key。</p>\n<h2> 运维管理</h2>\n<h3> 服务上线怎么兼容旧版本？</h3>\n<p>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。</p>\n<h3> Dubbo telnet 命令能做什么？</h3>\n\n<h3> Dubbo 支持服务降级吗？</h3>\n<p>以通过 dubbo:reference 中设置 mock=“return null”。mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑</p>\n<h3> Dubbo 如何优雅停机？</h3>\n<p>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</p>\n<h2> SPI</h2>\n<h3> Dubbo SPI 和 Java SPI 区别？</h3>\n<p>JDK SPI：</p>\n<p>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了</p>\n<p>DUBBO SPI：</p>\n<p>1、对 Dubbo 进行扩展，不需要改动 Dubbo 的源码</p>\n<p>2、延迟加载，可以一次只加载自己想要加载的扩展实现。</p>\n<p>3、增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</p>\n<p>4、Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。</p>\n<h2> Dubbo 可以对结果进行缓存吗？</h2>\n<p>为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作量<code>&lt;dubbo:reference cache=“true” /&gt;</code>\n其实比普通的配置文件就多了一个标签 cache=“true”</p>\n<h2> Dubbo 支持哪些序列化方式？</h2>\n<p>默认使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。</p>\n<h2> Dubbo 在安全方面有哪些措施？</h2>\n<p>Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。\nDubbo 还提供服务黑白名单，来控制服务所允许的调用方。</p>\n<h2> 服务调用是阻塞的吗？</h2>\n<p>默认是阻塞的，可以异步调用，没有返回值的可以这么做。Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</p>\n<h2> 服务提供者能实现失效踢出是什么原理？</h2>\n<p>服务失效踢出基于 zookeeper 的临时节点原理。</p>\n<h2> Dubbo 使用过程中都遇到了些什么问题？</h2>\n<p>在注册中心找不到对应的服务,检查 service 实现类是否添加了@service 注解无法连接到注册中心,检查配置文件中的对应的测试 ip 是否正确</p>\n<h2> RPC和SOA、SOAP、REST的区别</h2>\n<p>1、REST</p>\n<p>可以看着是HTTP协议的一种直接应用，默认基于JSON作为传输格式,使用简单,学习成本低效率高,但是安全性较低。</p>\n<p>2、SOAP</p>\n<p>SOAP是一种数据交换协议规范,是一种轻量的、简单的、基于XML的协议的规范。而SOAP可以看着是一个重量级的协议，基于XML、SOAP在安全方面是通过使用XML-Security和XML-Signature两个规范组成了WS-Security来实现安全控制的,当前已经得到了各个厂商的支持 。</p>\n<p>它有什么优点？简单总结为：易用、灵活、跨语言、跨平台。</p>\n<p>3、SOA</p>\n<p>面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。</p>\n<p>SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。</p>\n<p>4、REST 和 SOAP、RPC 有何区别呢?</p>\n<p>没什么太大区别，他们的本质都是提供可支持分布式的基础服务，最大的区别在于他们各自的的特点所带来的不同应用场景 。</p>\n",
      "date_modified": "2023-08-03T23:47:30.728Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "es学习笔记",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/elasticsearch/es.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/elasticsearch/es.html",
      "summary": "参考 介绍 ElasticSearch 是一个基于Lucene的搜索服务器 是一个分布式、高扩展、高实时的搜索与数据分析引警 基于RESTful web接口 Elasticsearch 是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引警",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n</div>\n<h2> 介绍</h2>\n<p><code>ElasticSearch</code> 是一个基于Lucene的搜索服务器</p>\n<p>是一个分布式、高扩展、高实时的搜索与数据分析引警</p>\n<p>基于<code>RESTful web</code>接口</p>\n<p><code>Elasticsearch</code> 是用<code>Java</code>语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引警</p>\n<p><code>MySQL</code>有事务性而<code>ElasticSearch</code>没有事务性,所以你删了的数据是无法恢复的。</p>\n<p><code>ElasticSearch</code>没有物理外键这个特性，,如果你的数据强一致性要求比较高还是建议慎用</p>\n<p><code>ElasticSearch</code>和<code>MySql</code>分工不同<code>，MySQL</code>责存储数据，<code>ElasticSearch</code>负责搜索数据</p>\n<h2> 倒排索引</h2>\n<p>将各个文档中的内容，进行分词，形成词条。然后记录词条和数据的唯一标识（id）的对应关系，形成的索引。</p>\n<p>形成倒排索引时候，词条会进行排序，来解决词条数据大查询效率的问题。</p>\n<h2> 安装</h2>\n<h3> 新建用户</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 安装kibana</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 使用kibana 操作es</h2>\n<p>在菜单中 点击 dev-tools</p>\n<h2> 核心概念</h2>\n<p><code>索引 (index)</code></p>\n<p><code>ElasticSearch</code>存储数据的地方，可以理解成关系型数据库中的数据库概念</p>\n<p><code>映射 (mapping)</code></p>\n<p><code>mapping</code>定义了每个字段的类型、字段所使用的分词器等、相当于关系型数据库中的表结构文档</p>\n<p><code>(document)</code> <code>Elasticsearch</code>中的最小数据单元，常以ison格式显示。一个document相当于关系型数据库中的一行数据.</p>\n<p><code>倒排索引</code></p>\n<p>一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，对应一个包含它的文档id列表</p>\n<p><code>类型 (type)</code></p>\n<p>type就像 类表。如用户表、角色表等。在<code>Elasticsearch7.X</code>默认<code>type</code>为<code> doc</code></p>\n<p>ES 5.x中一个index可以有多种type。</p>\n<p>ES 6.x中一个index只能有一种type。</p>\n<p>ES 7.x以后，将逐步移除type这个概念，现在的操作已经不再使用，默认 doc</p>\n<h2> 索引的操作</h2>\n<p>1 创建索引 index</p>\n\n<p>返回</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2 查看索引 index</p>\n<p>GET http://localhost:9200/books_index</p>\n<p>返回</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>3 查看所有索引</p>\n<p>get http://localhost:9200/_all</p>\n<p>关闭索引</p>\n<p>POST http://localhost:9200/books_index/_close</p>\n<p>打开索引</p>\n<p>POST http://localhost:9200/books_index/_open</p>\n<h2> 映射 mapping</h2>\n<h3> 支持的数据类型</h3>\n<p></p>\n<p></p>\n<p></p>\n<h2> kibana 使用</h2>\n<p>创建索引</p>\n<p>PUT book_index</p>\n<p>查看索引</p>\n<p>GET book_index</p>\n<h2> 创建映射 mapping</h2>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>查询映射</p>\n<p>GET books_index/_mapping</p>\n<h2> 创建索引并且添加mapping</h2>\n<p>PUT book_index</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 添加字段</h2>\n<h1> 添加字段</h1>\n<p>GET book_index/_mapping</p>\n<p>PUT book_index/_mapping</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 添加文档</h2>\n<h3> 指定id 插入</h3>\n<p>PUT book_index/_doc/1</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>返回</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 查询文档</h2>\n<p>GET book_index/_doc/1</p>\n<p>返回</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 不指定id 插入</h2>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>GET book_index/_doc/CYsOrogBbjJWakCUgynF</p>\n<h2> 修改文档</h2>\n<p>id 存在则修改，不存在则创建</p>\n<p>PUT book_index/_doc/1</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 删除字段</h2>\n<p>PUT book_index/_doc/1</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 查询所有文档</h2>\n<p>GET /book_index/_search</p>\n<p>返回</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 删除文档</h2>\n<p>DELETE /book_index/_doc/CYsOrogBbjJWakCUgynF</p>\n<h2> 分词器</h2>\n<p></p>\n<h2> 使用分词器查询分词效果</h2>\n<p>GET _analyze</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>返回</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> IK 分词器</h2>\n<p></p>\n<h2> IK 分词器安装</h2>\n<p>下载</p>\n<p>https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.17.5</p>\n<p>1 在es 安装目录的plugins 创建 analysis-ik 文件夹， 解压下载的zip包</p>\n<p>2 把 解压后的文文件中的config 文件夹内的所有内容，拷贝到 es 的config 文件内</p>\n<p>3 重启es</p>\n<h2> 使用IK 分词器</h2>\n<p>ik_smart 粗粒度</p>\n<p>ik_max_word 细粒度</p>\n<p>GET _analyze</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>返回</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>GET _analyze</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>返回</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 查询文档</h2>\n<p></p>\n<h2> 创建 索引并且指定 ik 分词器</h2>\n<p>PUT book_index</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> term 查询</h2>\n<p>term 查询，完全匹配到，才能查到</p>\n<p>GET /book_index/_search</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> match</h2>\n<p>match 会对查询的词进行分词，然后求合集</p>\n<p>GET /book_index/_search</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> spring-boot 操作es</h2>\n<h3> 创建索引</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 获取索引</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删除索引</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 判断索引是否存在</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 添加文档</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 通过id 查询文档</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 跟新文档</h3>\n<p>修改： id 存在则修改，id 不存在则添加</p>\n<h3> 删除文档</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.762Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "es score",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/elasticsearch/esscore.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/elasticsearch/esscore.html",
      "summary": "参考 实战 | Elasticsearch自定义评分的N种方法 实战 | Elasticsearch自定义评分的N种方法",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://blog.csdn.net/laoyang360/article/details/104809787\" target=\"_blank\" rel=\"noopener noreferrer\">实战 | Elasticsearch自定义评分的N种方法</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1600163\" target=\"_blank\" rel=\"noopener noreferrer\">实战 | Elasticsearch自定义评分的N种方法</a></p>\n</div>\n<h2> 期望Elasticsearch搜索结果更准确，不可回避的三个问题</h2>\n<h3> 问题1：用户真正的需求是什么？</h3>\n<p>如果不能获得用户的搜索意图，搜索的准确性无从谈起。</p>\n<p>比如：同样输入“锤子”，工匠期望的是钉子对应的“锤子”，老罗的粉丝期望的是“锤子科技”、“锤子便签”、“锤子手机”等。</p>\n<p>即使同一用户发出的同一个查询，也可能因为用户所处场景不同，其期望结果也存在很大差异。</p>\n<h3> 问题2：哪些信息是和用户需求真正相关的？</h3>\n<p>搜索引擎本质是一个匹配过程，即从海量的数据中找到匹配用户需求的内容。</p>\n<p></p>\n<p>判定内容与用户查询的相关性(relevance，如上图），一直是搜索引擎领域核心研究课题之一。</p>\n\n<h3> 问题3：哪些信息是最值得用户信赖的？</h3>\n<p>衡量信息满足用户需求的两个核心属性。</p>\n\n<p>举例：疫情环境下，新华网、人民网发布文章的可信性远大于某公众号大V发布的。</p>\n<h2> Elasticsearch相关性是如何控制的？</h2>\n<p>结构化数据库如Mysql，只能查询结果与数据库中的row的是否匹配？回答往往是“是”、“否”。</p>\n<p>如：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>而全文搜索引擎Elasticsearch中不仅需要找到匹配的文档，还需根据它们相关度的高低进行排序。</p>\n<p>实现相关度排序的核心概念是评分。</p>\n<p><code>_score</code>就是<code>Elasticsearch</code>检索返回的评分。该得分衡量每个文档与查询的匹配程度。</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>每个文档都有与之相关的评分，该得分由正浮点数表示。文档分数越高，则文档越相关。</p>\n<p>分数与查询匹配成正比。查询中的每个子句都将有助于文档的得分。</p>\n<h2> Elasticsearch 如何计算评分？</h2>\n<p>官方文档相关度评分背后的理论解读如下：</p>\n<p>Lucene（或 Elasticsearch）使用 布尔模型查找匹配文档，并用一个名为 实用评分函数的公式来计算相关度。\n这个公式借鉴了 词频/逆向文档频率和 向量空间模型，同时也加入了一些现代的新特性，如协调因子（coordination factor），字段长度归一化<code>（field length normalization）</code>，以及词或查询语句权重提升。</p>\n<p><code>Elasticsearch 5 </code>之前的版本，评分机制或者打分模型基于 <code>TF-IDF</code>实现。</p>\n<p>注意：从<code>Elasticsearch 5</code>之后, 缺省的打分机制改成了<code>Okapi BM25</code>。</p>\n<p><code>BM25</code> 的 <code>BM </code>是缩写自 <code>Best Match</code>,<code> 25</code> 貌似是经过 <code>25</code> 次迭代调整之后得出的算法，它也是基于 <code>TF/IDF</code> 进化来的。</p>\n<h3> TF-IDF与BM25 的相同点</h3>\n<p><code>TF-IDF</code> 和<code> BM25</code> 同样使用 逆向文档频率 来区分普通词（不重要）和非普通词（重要），同样认为：</p>\n\n<h3> TF-IDF与BM25 的不同点</h3>\n<p><code>BM25</code>在传统<code>TF-IDF</code>的基础上增加了几个可调节的参数，使得它在应用上更佳灵活和强大，具有较高的实用性。</p>\n\n<div class=\"language-code line-numbers-mode\" data-ext=\"code\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>\n<p>（1）L是文档长度与平均长度的比值。如果文档长度是平均长度的2倍，则L＝2。</p>\n<p>（2）b是一个常数，它的作用是规定L对评分的影响有多大。加了L和b的公式变为：</p>\n<div class=\"language-code line-numbers-mode\" data-ext=\"code\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p></p>\n<p>更多细节原理推荐：</p>\n<p>https://blog.mimacom.com/elasticsearch-scoring-algorithm-changes/</p>\n<p>https://blog.mimacom.com/bm25-got/</p>\n<h3> Elasticsearch 哪些查询影响相关性评分？</h3>\n<p>布尔查询中的每个must，should和must_not元素称为查询子句。</p>\n\n<p>一句话概括：filter、must_not不影响评分，其他影响评分。</p>\n<h2> Elasticsearch 如何自定义评分？</h2>\n<p>这里说是自定义评分，核心还是通过修改评分修改文档相关性，在最前面返回用户最期望的结果。</p>\n<h3> Index Boost 索引层面修改相关性</h3>\n<h3> 原理说明</h3>\n<p>允许在跨多个索引搜索时为每个索引配置不同的级别。</p>\n<h3> 适用场景</h3>\n<p>索引级别调整评分。</p>\n<h3> 实战举例：</h3>\n\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> boosting 修改文档相关性</h3>\n<p>boosting分为两种类型：</p>\n\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>索引期间修改相关性的弊端非常明显：修改boost值的唯一方式是重建索引，reindex数据，成本太高了！</p>\n\n<p>本小节着重讲解：查询时候修改文档相关性。\n原理说明</p>\n<p>通过boosting修改文档相关性。</p>\n\n<p>适用场景</p>\n<p>自定义修改满足某个查询条件的评分。\n实战一把</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>negative_boost 降低相关性\n原理说明</p>\n\n<p>适用场景</p>\n<p>对某些返回结果不满意，但又不想排除掉（must_not），可以考虑boosting query的negative_boost。\n实战一把</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> function_score 自定义评分</h3>\n\n<p>支持用户自定义一个或多个查询或者脚本，达到精细化控制评分的目的。\n适用场景</p>\n<p>支持针对复杂查询的自定义评分业务场景。\n实战一把</p>\n<p>实战问题1：如何同时根据 销量和浏览人数进行相关度提升？</p>\n<p>问题来源：https://elasticsearch.cn/question/4345</p>\n<p>问题描述：针对商品，例如有</p>\n<p></p>\n<p>想要有一个提升相关度的计算，同时针对销量和浏览人数</p>\n<p>例如oldScore*(销量+浏览人数) field_value_factor好像只能支持单个field 求大神解答？</p>\n<p>解答，可以借助：script_score实现。</p>\n<p>实战如下：</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实战问题2：\n基于文章点赞数计算评分。以下：title代表文章标题；like：代表点赞数。</p>\n<p>期望评分标准：基于点赞数评分，且最终评分相对平滑。</p>\n\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：</p>\n\n<p>实战常见问题</p>\n<p>星球提问：有没有办法让同一个索引里面对固定的查询返回的相关性评分是在固定的范围之内的？比如0-100分这样的？</p>\n<p>这样就可以知道对某些词语或文档的搜索，在索引里面是否有满足相关性的文档了。</p>\n<p>回答：</p>\n\n<p>通过设置max_boost参数，可以将新分数限制为不超过特定限制。</p>\n<p>max_boost的默认值为FLT_MAX。</p>\n<div class=\"language-code line-numbers-mode\" data-ext=\"code\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>查询后二次打分rescore_query</p>\n\n<p>二次评分是指重新计算查询返回结果文档中指定个数文档的得分，Elasticsearch会截取查询返回的前N个，并使用预定义的二次评分方法来重新计算他们的得分。\n适用场景</p>\n<p>对查询语句的结果不满意，需要重新打分的场景。</p>\n<p>但，如果对全部有序的结果集进行重新排序的话势必开销会很大，使用rescore_query只对结果集的子集进行处理。\n实战一把</p>\n\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>window_size含义：</p>\n<p>query rescorer仅对query和 post_filter阶段返回的前K个结果执行第二个查询。</p>\n<p>每个分片上要检查的文档数量可由window_size参数控制，默认为10。</p>\n<p>探讨了Elasticsearch相关性、打分机制、不同自定义评分的原理、适用场景，并结合实战业务进行解读。</p>\n",
      "date_modified": "2023-08-03T23:47:30.771Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "es排序",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/elasticsearch/es%E6%8E%92%E5%BA%8F.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/elasticsearch/es%E6%8E%92%E5%BA%8F.html",
      "summary": "参考 Elasticsearch原理（九）：相关性排序算法详解 ElasticSearch(ES)搜索排序、相关性、评分机制",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://blog.csdn.net/xiaoyu_BD/article/details/108076618\" target=\"_blank\" rel=\"noopener noreferrer\">Elasticsearch原理（九）：相关性排序算法详解</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/343337038\" target=\"_blank\" rel=\"noopener noreferrer\">ElasticSearch(ES)搜索排序、相关性、评分机制</a></p>\n</div>\n<p><code>Elasticsearch</code> 中的相关性算法主要还是基于<code>Lucene</code>的相关性算法，<code>Lucene</code>的算法是基于<code>TF-IDF</code>的，但和<code>TF-ID</code>F还是有些区别。那么我们就从<code>TF-IDF</code>开始介绍。</p>\n<h2> TF-IDF</h2>\n<p>定义</p>\n<p><code>TF-IDF（term frequency–inverse document frequency）</code>是一种用于信息检索与数据挖掘的常用加权技术。TF是词频<code>(Term Frequency)</code>，<code>IDF</code>是逆文本频率指数<code>(Inverse Document Frequency)</code>。（来源百度百科）</p>\n<h2> 算法核心</h2>\n<p>TF-IDF实际上就是TF和IDF的两个算法的乘积。</p>\n<p>TF（词频）</p>\n<p>词频的所在对象是一个具体的文档，是指一个文档中出现某个单词（Term）的频率（Frequency）。这里用的是频率而不是次数，是为了防止文档内容过长从而导致某些单词出现过多.</p>\n<p>IDF（逆向文档频率）</p>\n<p>逆向文件频率描述的对象是一个文档集合中，包含某个单词的文档数量。它表示的是一个单词在一个文档集合中的普遍重要程度。</p>\n<p>TF-IDF</p>\n<p>某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的tf-idf。因此，tf-idf倾向于过滤掉常见的词语，保留重要的词语。</p>\n<h2> BM25</h2>\n<p><code>BM25（Best Match25</code>）是在信息检索系统中根据提出的<code>query</code>对<code>document</code>进行评分的算法。</p>\n<p><code>TF-IDF </code>算法是一个可用的算法，但并不太完美。它给出了一个基于统计学的相关分数算法，而BM25算法则是在此之上做出改进之后的算法。（为什么要改进呢？ <code>TF-IDF</code> 不完美的地方在哪里？）</p>\n<p>当两篇描述“人工智能”的文档A和B，其中A出现“人工智能”100次，B出现“人工智能”200次。\n两篇文章的单词数量都是10000，那么按照 TF-IDF 算法，A的 <code>tf</code> 得分是：0.01，B的\n<code>tf</code> 得分是0.02。得分上B比A多了一倍，但是两篇文章都是再说人工智能， <code>tf </code>分数\n不应该相差这么多。可见单纯统计的 <code>tf </code>算法在文本内容多的时候是不可靠的\n多篇文档内容的长度长短不同，对 <code>tf</code> 算法的结果也影响很大，所以需要将\n也考虑到算法当中去</p>\n<h2> 检索词频率</h2>\n<p>检索词在该字段出现的频率？出现频率越高，相关性也越高。字段中出现过 5 次要比只出现过 1 次的相关性高。</p>\n<h2> 反向文档频率</h2>\n<p>每个检索词在索引中出现的频率？频率越高，相关性越低。检索词出现在多数文档中会比出现在少数文档中的权重更低。常用词如 and 或 the 对相关度贡献很少，因为它们在多数文档中都会出现。</p>\n<h2> 字段长度准则</h2>\n<p>字段的长度是多少？长度越长，相关性越低。检索词出现在一个短的 title 要比同样的词出现在一个长的 content 字段权重更大。</p>\n<h2> 举例</h2>\n<p>假设，检索关键词 <code>honeymoon</code>，在索引上所有文档中的<code>tweet</code>字段中检索。</p>\n<p>检索词频率:</p>\n<p>检索词 <code>honeymoon</code> 在这个文档的 <code>tweet</code> 字段中的出现次数。出现次数越多，评分越高。</p>\n<p>反向文档频率:</p>\n<p>检索词 <code>honeymoon</code> 在索引上所有文档的 <code>tweet</code> 字段中出现的次数。出现次数越多，评分越低。</p>\n<p>字段长度准则:</p>\n<p>在这个文档中， <code>tweet</code> 字段内容的长度 -- 内容越长，评分越低。</p>\n",
      "date_modified": "2023-08-03T23:47:30.773Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "es高级",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/elasticsearch/es%E9%AB%98%E7%BA%A7.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/elasticsearch/es%E9%AB%98%E7%BA%A7.html",
      "summary": "参考 批量操作 matchAll 查询 默认情况下，es一次展示10条 GET persons/_search { \"query\": { \"match_all\": { } }, \"from\": 0, \"size\": 20 }",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n</div>\n<h2> 批量操作</h2>\n<p></p>\n<h2> matchAll 查询</h2>\n<h1> 默认情况下，es一次展示10条</h1>\n<p>GET persons/_search</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> match</h2>\n<p></p>\n<h2> 模糊查询</h2>\n<p></p>\n<p>GET persons/_search</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意： 不要在查询内容前面加通配符，否则会全表查询</p>\n<h2> 范围查询</h2>\n<p>GET persons/_search</p>\n<div class=\"language-json line-numbers-mode\" data-ext=\"json\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.775Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "函数式编程",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/function/%E5%9F%BA%E7%A1%80.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/function/%E5%9F%BA%E7%A1%80.html",
      "summary": "参考 方法引用 方法引用组成：类名或对象名，后面跟 :: ，然后跟方法名称。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n</div>\n<h2> 方法引用</h2>\n<p>方法引用组成：类名或对象名，后面跟 <code>:: </code>，然后跟方法名称。</p>\n",
      "date_modified": "2023-08-03T23:47:30.775Z",
      "authors": [],
      "tags": [
        "函数式编程"
      ]
    },
    {
      "title": "高并发",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/gbf/gbf.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/gbf/gbf.html",
      "summary": "参考 流量架构（流量预研） 流量架构包含的主要内容： 1 按照未来一段时间的用户规模，做系统的流量（吞吐量）预估。 2 按照流量预估值和系统各层组件的性能基线值，做各层的组件的部署架构规划，确保系统的高性能、 高可用。 所以，最终的流量架构，就是系统在不同用户量、不同场景下（如平时、战时）的分层规划、组件规 划。 流量架构的类型 老系统的流量架构",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n</div>\n<h2> 流量架构（流量预研）</h2>\n<p>流量架构包含的主要内容：</p>\n<p>1 按照未来一段时间的用户规模，做系统的流量（吞吐量）预估。</p>\n<p>2 按照流量预估值和系统各层组件的性能基线值，做各层的组件的部署架构规划，确保系统的高性能、\n高可用。</p>\n<p>所以，最终的流量架构，就是系统在不同用户量、不同场景下（如平时、战时）的分层规划、组件规\n划。</p>\n<h2> 流量架构的类型</h2>\n<h3> 老系统的流量架构</h3>\n<p>如果是老系统，做流量架构的时候，可以参考现有的监控数据，服务能力，流量指标 。对着老的架构版</p>\n<p>本，进行偏离指标的计算，折算成冗余系数，完成流量架构的工作：</p>\n<p>（1）做出系统在不同用户量、不同场景（高峰、平峰、低峰）下的流量（吞吐量）预估，含未来一段\n时期如两年。</p>\n<p>（2）做出系统在不同用户量、不同场景下的各层组件的部署架构。</p>\n<h3> 新系统的流量架构</h3>\n<p>接下来我们重点说一下新系统，也是在实际工作中遇到最多的情况。</p>\n<p>有的朋友可能说：我们公司的项目就是啥都没有，三无产品，没有业务监控、没有中间件日志，\n也没有日活数据，那怎么评估预期指标。</p>\n<p>新项目是还没有上线，在上线前希望先进行一轮压测，评估项目性能是否能支撑当前的用户，这个时候\n性能预期指标更为重要。</p>\n<p>如果是新系统，线上并没有任何的历史监控数据和日志数据，所以之前介绍的方法就不再适用，这个时\n候需要使用另外一种方法来评估性能指标，那就是“二八定律”。</p>\n<p>对新系统来说，完成流量架构的工作：</p>\n<p>（1）根据二八定律，做出系统在不同用户量、不同场景下的流量（吞吐量）预估，含未来一段时期如\n两年。</p>\n<p>（2）做出系统在不同用户量、不同场景下的各层组件的部署架构。</p>\n<h2> 亿级用户量场景下的流量预估</h2>\n<p>根据二八定律，做出系统在不同用户量、不同场景下的流量（吞吐量）预估，含未来一段时期如两年。</p>\n<p>二八定律</p>\n<h3> 什么是二八定律？</h3>\n<p>先来看一下定义。 二八定律又名80/20定律、帕累托法则（Pareto‘s principle）、巴莱特定律、\n朱伦法则（Juran’s Principle）、关键少数法则（Vital FeRule）、不重要多数法则（Trivial Many\nRule）最省力的法则、不平衡原则等，被广泛应用于社会学及企业管理学等。</p>\n<p>二八定律是19世纪末20世纪初意大利经济学家<code>帕累托</code>发现的。<u>他认为，在任何一种事物中，最重要的\n只占其中一小部分，约20%，其余80%尽管是多数，却是次要的</u>。</p>\n<h2> 使用场景：</h2>\n<h3> 软件测试</h3>\n<p>软件测试理论中，常提到2-8原则</p>\n<p>80%的测试成本花在20%的软件模块中</p>\n<p>所谓2-8原则，即80%的bug多发生在软件的20%的模块。所以，在回归测试的时候，这20%的高发地带\n是关注的重点！</p>\n<p>80%的错误是由20%的模块引起的</p>\n<p>站在用户角度，并非研发实现的角度，正确地选择重要模块作为测试重点，从而不偏离方向。\n80%的测试时间花在20%的软件模块中</p>\n<p>软件测试执行过程中需要将时间倾斜在重要模块的测试用例中，从而使测试更加有效，发现bug</p>\n<h3> 经济学场景</h3>\n<p>从经济学上看，世界上80%的财富，都集中的20%的人手里</p>\n<h2> 互联网行为场景</h2>\n<p>一个网站有成千上万的用户，但是<u>80%的用户请求是发生在20%的时间内</u>，比如大家去网上购物，基本\n也都集中在中午休息或晚上下班后。</p>\n<p>二八定律的核心原则是关注重要部分，忽略次要部分。<u>系统性能如果能支撑发生在20%时间内的高并发\n请求，必然也能支持非高峰期的访问</u>。</p>\n<h2> 二八定律来计算预期指标</h2>\n<p>通过用户量来预估QPS</p>\n<p>首先先预估系统的<code>每日总请求数</code>，这个没有固定的方法，如果没有任何历史数据参考，一般是通过用户\n量或者其他关联系统来评估</p>\n<p>术语说明：\n<code>QPS = req/sec = 请求数/秒</code></p>\n<blockquote>\n<p>说明：对于单次接口调用的请求， QPS=TPS</p>\n</blockquote>\n<h3> 【通过用户量来推算PV】</h3>\n<p>公式：<code>( 总用户数 * 20% ) * 每天的大致点击次数（淘宝经验30-50次）= pv数</code></p>\n<p>问：用户数是1000万，pv量是多少？</p>\n<p>答：1000万 * 20% *30= 6000万 【PV推算QPS的公式】</p>\n<p>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)</p>\n<p>问：每天6000万 PV ，多少QPS？</p>\n<p>答：(6000万 * 0.8 ) / (86400 * 0.2 ) = 4800W/17280(QPS) =2700</p>\n<h2> 【乘上冗余系数】</h2>\n<p>评估出来指标后，为了更加保险一些，最好再乘以一个冗余系数（偏离系数），提高预期指标，防止人\n为评估造成预期指标偏低的情况。</p>\n<p>这个冗余系数一般定为2-5之间（行业经验），上面计算出来的tps指标为2700，如果再乘以一个冗余系\n数4，那么最终tps指标就定为10800。</p>\n<p>2700 (QPS) * 4 =10800 (QPS)</p>\n<p>总结一下，二八定律的算法为<u> 80%的请求 / 20%的时间 * 冗余系数</u></p>\n<h2> 冗余系数的迭代</h2>\n<p>同时，将来项目上线后，可以通过对项目接口的峰值监控，来对比之前评估的算法结果，调整冗余系\n数，最终随着不断的数据积累，将会形成一套本项目的性能模型。</p>\n<h2> 十万级用户量的压力预估</h2>\n<p>假设这个网站预估的用户数是10万，那么根据28法则，每天会来访问这个网站的用户占到20%，也就\n是2万用户每天会过来访问。</p>\n<p>【通过用户量来推算PV】\n公式：( 总用户数 * 20% ) / 每天的大致点击次数（淘宝经验30-50次）= pv数</p>\n<p>问：用户数是10万，pv量是多少？\n答：10万 * 20% * 30= 60万</p>\n<p>通常假设平均每个用户每次过来会有30次的点击，那么总共就有60万的点击（PV）。</p>\n<h2> 【PV推算QPS的公式】</h2>\n<p>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)</p>\n<p>答：60W * 0.8 / 5 * 3600 = 27 (QPS)</p>\n<p>问：5小时内会有48万点击 ，多少QPS？</p>\n<p>答： 48W * 0.8 / 5 * 3600 * 0.2 = 107 (QPS) * 冗余系统 = 107 * 4 = 428 (QPS)</p>\n<p>【 乘上冗余系统 】</p>\n<p>27 (QPS) * 4 =108 (QPS)</p>\n<h2> 百万级用户量的压力预估</h2>\n<p>个假设这个网站预估的用户数是100万，那么根据28法则，每天会来访问这个网站的用户占到20%，也\n就是2万用户每天会过来访问。</p>\n<p>【通过用户量来推算PV】\n公式：( 总用户数 * 20% ) / 每天的大致点击次数（淘宝经验30-50次）= pv数</p>\n<p>问：用户数是100万，pv量是多少？\n答：100万 * 20% * 30= 600万</p>\n<p>通常假设平均每个用户每次过来会有30次的点击，那么总共就有600万的点击（PV）。</p>\n<p>【PV推算QPS的公式】\n公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)</p>\n<p>问：5小时内会有48万点击 ，多少QPS？</p>\n<p>答：600W * 0.8 / 5 * 3600 = 270 (QPS)</p>\n\n<p>【乘上冗余系统 】</p>\n<p>270 (QPS) * 4 =1080 (QPS)</p>\n<h2> 千万级用户量的压力预估</h2>\n<p>这个假设这个网站预估的用户数是1000万，那么根据28法则，每天会来访问这个网站的用户占到\n20%，也就是200万用户每天会过来访问。</p>\n<p>【通过用户量来推算PV】</p>\n<p>公式：( 总用户数 * 20% ) / 每天的大致点击次数（淘宝经验30-50次）= pv数</p>\n<p>问：用户数是1000万，pv量是多少？</p>\n<p>答：1000万 * 20% * 30= 6000万</p>\n<p>通常假设平均每个用户每次过来会有30次的点击，那么总共就有6000万的点击（PV）。</p>\n<p>【PV推算QPS的公式】</p>\n<p>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)\n问：5小时内会有48万点击 ，多少QPS？</p>\n<p>答：6000 W * 0.8 / 5 * 3600 = 2700 (QPS)</p>\n<p>【加上冗余系统 】</p>\n<p>2700 (QPS) * 4 =10800 (QPS)</p>\n<h2> 亿级用户量的压力预估</h2>\n<p>这个假设这个网站预估的用户数是10000万，那么根据28法则，每天会来访问这个网站的用户占到\n20%，也就是2000万用户每天会过来访问。</p>\n<p>【通过用户量来推算PV】</p>\n<p>公式：( 总用户数 * 20% ) / 每天的大致点击次数（淘宝经验30-50次）= pv数</p>\n<p>问：用户数是1000万，pv量是多少？</p>\n<p>答：10000万 * 20% * 30= 60000万</p>\n<p>通常假设平均每个用户每次过来会有30次的点击，那么总共就有60000万的点击（PV）。</p>\n<p>【PV推算QPS的公式】</p>\n<p>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)</p>\n<p>问：5小时内会有48万点击 ，多少QPS？</p>\n<p>答：60000 W * 0.8 / 5 * 3600 = 27000 (QPS)</p>\n<p>【加上冗余系统 】</p>\n<p>27000 (QPS) * 4 =108000 (QPS)</p>\n<h2> 实际与理论的差距</h2>\n<p>那么将来项目上线后，接口的访问量真的和计算的一模一样吗？</p>\n<p>这个肯定不会，大家一定得知道一个原则，性能测试从来都不是一门非常精确的技术。</p>\n<p>二八定律也并不是100%适用于所有业务场景。在没有任何历史数据参考的背景下，二八定律相对来说\n是一种相对来说靠谱的算法，最起码有一定的理论依据，比拍脑袋猜的值靠谱多了。</p>\n<h2> Tomcat</h2>\n<p>tomcat 默认配置的最大请求数是<code>150</code>，也就是说同时支持<code>150</code>个并发。具体能承载多少并发，需要看硬\n件的配置，CPU 越多性能越高，分配给JVM的内存越多性能也就越高，但也会加重GC的负担。当</p>\n<p>某个应用拥有 <code>250</code> 个以上并发的时候，应考虑应用服务器的集群。</p>\n<p>一般来说，虽然tomcat的io线程最多控制在400以内，如果每个请求要300ms，一个线程3qps，</p>\n<p>那么一个tomcat到达1000qps，还是可以的。</p>\n<p>所以，<u>tomcat参考的并发能力为 1000qps</u></p>\n<h2> Nginx的并发能力</h2>\n<p>看到这里，这个框架的弱点仍然是Nginx结点的并发问题和单点故障。</p>\n<p>对于Nginx的抗并发能力，官方给出的是5w并发量，即轻轻松松处理5w的并发访问。</p>\n<p>对比tomcat，之所以有这么大抗并发，主要原因有两个：</p>\n<p>一是Nginx只做请求和响应的转发而没有业务逻辑处理，大部分的时间花在与其他计算的I/O上；</p>\n<p>二是Nginx的I/O采用的是单线程或少线程、异步非阻塞的模式（Tomcat是一个连接一个线程，同步阻\n塞的模式），避免了打开I/O通道等待数据传输的过程（仅仅是在数据传到了，再来接收即可），极大\n的缩短了线程调度和I/O处理的时间。</p>\n<h2> MySQL</h2>\n<p>MySQL数据库查询能力</p>\n<p>主键查询：千万级别数据 = 1~10 ms ， 4核心 8线程 为 1000qps* 8=8000qps</p>\n<p>唯一索引查询：千万级别数据 = 10~100 ms ， 4核心 8线程 为 100qps* 8=800qps</p>\n<p>非唯一索引查询：千万级别数据 = 100~1000 ms ， 4核心 8线程 为 10qps* 8=80qps</p>\n<p>无索引：百万条数据 = 1000 ms+</p>\n<p>综合来说，mysql的并发能力，大概在1500qps左右</p>\n<h2> Springcloud Gateway</h2>\n<p>单节点可以按照 预估。\n一次8核8G压测结果：\n并发数：300；\nnetty工作线程数（reactor.netty.ioWorkerCount）：8（默认）\n样本数据：返回1.5k大小\n服务端响应时间：10ms左右\n测试时长：5分钟\nJVM内存：2G</p>\n<p>5000 ~ 10000 QPS</p>\n<h2> 10W用户 各层的部署架构</h2>\n<p></p>\n<h2> 100W用户的各层的部署架构</h2>\n<p>1080qps</p>\n<p>1000W用户的各层的部署架构</p>\n<p>10800qps</p>\n<p>10000W用户的各层的部署架构</p>\n<p>108000qps</p>\n<p></p>\n",
      "date_modified": "2023-08-03T23:47:30.783Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "git常用命令",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",
      "summary": "1.修改已提交的msg git commit --amend 命令 git commit --amend 修改最后一次提交的msg",
      "content_html": "<h2> 1.修改已提交的msg</h2>\n<blockquote>\n<p>git commit  --amend 命令</p>\n</blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><blockquote>\n<p>修改最近一次提交的用户名和邮箱</p>\n</blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>2 git reset --soft HEAD~2(回退从当前到第几个)</p>\n</blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>注意：git reset --hard 会有文件丢失，慎用</p>\n</blockquote>\n<h2> git rebase</h2>\n<blockquote>\n<p>切记！！！，不要在主分支上rebase</p>\n</blockquote>\n<p>使用 rebase\n1 把master 上的代码合并到 dev</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2 在dev 进入 git rebase 交互式 进行提交压缩、删除操作 ，然后在合并到master</p>\n<p>3 也可以直接 git rebase -i master 交互式</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>rebase -i commit开始id commit结束id</p>\n</blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>使用 git rebase -i HEAD~(向前几次提交)</p>\n</blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 2.rebase 合并代码</h2>\n<blockquote>\n<p>如果之前使用 merge 的同学，可以直接把merge 获取rebase 命令</p>\n</blockquote>\n<p>把 dev1 合并到master上，操作步骤：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> git merage 与 git merge 的区别</h2>\n<p></p>\n",
      "date_modified": "2023-08-03T23:47:30.786Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "go msyql",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/go/go-mysql.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/go/go-mysql.html",
      "summary": "参考 https://www.liwenzhou.com/posts/Go/mysql/ 源码地址",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.liwenzhou.com/posts/Go/mysql/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.liwenzhou.com/posts/Go/mysql/</a></p>\n<p><a href=\"https://github.com/lojzes/go-study-base/blob/master/src/mysql/mysql.go\" target=\"_blank\" rel=\"noopener noreferrer\">源码地址</a></p>\n</div>\n<h2> 安装依赖</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 初始化连接</h2>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 查询</h2>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 插入</h2>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 更新</h2>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 删除</h2>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.791Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "go 并发编程",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/go/go-%E5%B9%B6%E5%8F%91.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/go/go-%E5%B9%B6%E5%8F%91.html",
      "summary": "参考 Go语言高级编程 源码地址",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-05-mem.html\" target=\"_blank\" rel=\"noopener noreferrer\">Go语言高级编程</a></p>\n<p><a href=\"https://github.com/lojzes/go-study-base/blob/master/src/mysql/mysql.go\" target=\"_blank\" rel=\"noopener noreferrer\">源码地址</a></p>\n</div>\n<h2> Mutex</h2>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.792Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "goweb",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/go/goweb.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/go/goweb.html",
      "summary": "参考 https://github.com/lojzes/go-study-base/tree/master/src/http-base/http-router",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://github.com/lojzes/go-study-base/tree/master/src/http-base/http-router\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/lojzes/go-study-base/tree/master/src/http-base/http-router</a></p>\n</div>\n",
      "date_modified": "2023-08-03T23:47:30.792Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "go基础",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/go/go%E5%9F%BA%E7%A1%80.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/go/go%E5%9F%BA%E7%A1%80.html",
      "summary": "字符串 go 字符串是 unicode 字符，使用 utf-8 编码 编码、解码 打印 unicode、utf-8 编码 package main import \"fmt\" func main() { \t// 字节长度 \t//fmt.Println(len(s)) \t// rune 相当于go 中的char \tvar s = \"YES你好世界!\" // 默认UTF-8 一个中文 占3个字节 \tfor i, v := range s { // v 是rune unicode、utf-8 编码 \t\tfmt.Printf(\"(%d %X)\\n\", i, v) \t} }",
      "content_html": "<h2> 字符串</h2>\n<p>go 字符串是 unicode 字符，使用 utf-8 编码</p>\n<h3> 编码、解码</h3>\n<p>打印 unicode、utf-8 编码</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 打印字节长度</h3>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>打印字节</p>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<p>utf-8 编码 一个汉字占用 3 个字节</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 字符串和字节相互转换</h3>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Rune 字符串长度</h3>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 编码解码</h3>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> int float string 相互转换</h3>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> io</h2>\n<h3> 控制台输入</h3>\n<div class=\"language-go line-numbers-mode\" data-ext=\"go\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.798Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "awk",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/linux/awk.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/linux/awk.html",
      "summary": "AWK AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。 之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。 $1 表示第一列 $2 表示第二列 一次类推 $0 表示整行 $NF 最后一列 [root@w1 ~]# ll | awk '{print $1}' total -rw-r--r--. -rw-r--r--. -rw-r--r--. -rw-------. -rw-------. -rw-r--r--. -rw-r--r--. [root@w1 ~]# ll | awk '{print $NF}' 56 1.txt 2.txt 3.txt anaconda-ks.cfg original-ks.cfg settings.zip test.sh",
      "content_html": "<h2> AWK</h2>\n<blockquote>\n<p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。\n之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</p>\n</blockquote>\n<blockquote>\n<p>$1 表示第一列  $2 表示第二列 一次类推 <br>\n$0 表示整行 $NF 最后一列</p>\n</blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 选择行 $NR==1 选择第一行</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 指定分割符（默认空格）</h3>\n<p>指定分割符 通过 -F 指定</p>\n<p>举例 -F “.”  以. 为分割符</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出分隔符</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.799Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "grep",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/linux/grep.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/linux/grep.html",
      "summary": "Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。 grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。 语法 grep [options] pattern [files] pattern - 表示要查找的字符串或正则表达式。 files - 表示要查找的文件名，可以同时查找多个文件，如果省略 files 参数， 则默认从标准输入中读取数据。 常用选项：： -i：忽略大小写进行匹配。 -v：反向查找，只打印不匹配的行。 -n：显示匹配行的行号。 -r：递归查找子目录中的文件。 -l：只打印匹配的文件名。 -c：只打印匹配的行数。 例子：在 hello.sh 中查找o ，并打印行号 [root@w1 ~]# grep -n o test.sh 1:hello 2:world 在文件夹 dir 中递归查找所有文件中匹配正则表达式 \"pattern\" 的行，并打印匹配行所在的文件名和行号： grep -r -n pattern dir/ 在标准输入中查找字符串 \"world\"，并只打印匹配的行数： echo \"hello world\" | grep -c world 在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。 此时，可以使用如下命令： grep test *file 场景： 系统报警显示了时间，但是日志文件太大无法直接 cat 查看。 (查询含有特定文本的文件，并拿到这些文本所在的行) grep -n '2019-10-24 00:01:11' *.log",
      "content_html": "<p>Linux grep (global regular expression) 命令用于查找文件里符合条件的字符串或正则表达式。</p>\n<p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。</p>\n<h2> 语法</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.800Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "linux shell",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/linux/linux-shell.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/linux/linux-shell.html",
      "summary": "shell 查看默认shell [root@w1 ~]# echo $SHELL /bin/bash",
      "content_html": "<h2> shell</h2>\n<p>查看默认shell</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 环境变量</h2>\n<h3> 用户登录时执行的环境变量</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 用户非登录执行的环境变量</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 环境变量的定义</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 输出变量</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 比较变量</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 执行脚本时传递参数</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> shell 常用变量</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> bash shell 内置命令</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 变量的数值计算</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 基于shell 传参 read</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 条件测试与比较</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> if</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> for</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> while</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> case 条件语句</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 监控服务是否正常</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> shell  函数</h2>\n<h2> 让脚本在后台运行</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 循环控制及状态返回值的应用实践</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> shell 数组</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> shell 脚本开发规范</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"></div></div><h2> 脚本调试</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.815Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "linux常用命令",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",
      "summary": "yum yum autoremove 对于大部分使用红帽系（RedHat）Linux系统的用户而言，我们习惯使用yum命令安装或卸载软件包。当我们使用yum install命令安装一枚软件包时，yum会将该软件包连同其所有依赖包一并安装到本机。但当我们使用yum remove命令卸载一枚已安装软件包时，yum默认只会移除你所指定的那枚软件包，并不会移除该包的相关依赖包。 自从Fedora 18之后，我们便可以使用yum autoremove pakage命令来干净卸载软件包了。",
      "content_html": "<h2> yum</h2>\n<h3> yum  autoremove</h3>\n<p>对于大部分使用红帽系（RedHat）Linux系统的用户而言，我们习惯使用<code>yum</code>命令安装或卸载软件包。当我们使用<code>yum install</code>命令安装一枚软件包时，<code>yum</code>会将该软件包连同其所有依赖包一并安装到本机。但当我们使用<code>yum remove</code>命令卸载一枚已安装软件包时，<code>yum</code>默认只会移除你所指定的那枚软件包，并不会移除该包的相关依赖包。</p>\n<p>自从<em>Fedora 18</em>之后，我们便可以使用<code>yum autoremove pakage</code>命令来干净卸载软件包了。</p>\n<h3> yum clean all</h3>\n<p>/var/cache/yum目录。\n使用yum clean all 清除，很方便，绕开了没有root权限的问题。\n该命令介绍如下，作用：清除YUM缓存。</p>\n<p>yum 会把下载的软件包和header存储在cache中，而不自动删除。如果觉得占用磁盘空间，可以使用yum clean指令进行清除，更精确 的用法是yum clean headers清除header，yum clean packages清除下载的rpm包，yum clean all一全部清除</p>\n<h2> env 环境变量</h2>\n<p>查看环境变量</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>设置环境变量(临时)</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 权限</h2>\n<p>Linux系统上对文件的权限有着严格的控制，如果想对某个文件执行某种操作，必须具有对应的权限方可执行成功。\nLinux下文件的权限类型一般包括读，写，执行。对应字母为 r、w、x。\nLinux下权限的粒度有 拥有者 、群组 、其它组 三种。每个文件都可以针对三个粒度，设置不同的rwx(读写执行)权限。通常情况下，一个文件只能归属于一个用户和组， 如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组。</p>\n<h3> 更改文件权限 （chmod命令）</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>示例：\n设置所有用户可读取文件 a.conf</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>设置 c.sh 只有 拥有者可以读写及执行</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>设置文件 a.conf 与 b.xml 权限为拥有者与其所属同一个群组 可读写，其它组可读不可写</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>设置当前目录下的所有档案与子目录皆设为任何人可读写</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 数字权限使用格式</h2>\n<p>在这种使用方式中，首先我们需要了解数字如何表示权限。 首先，我们规定 数字 4 、2 和 1表示读、写、执行权限（具体原因可见下节权限详解内容），即 r=4，w=2，x=1 。此时其他的权限组合也可以用其他的八进制数字表示出来，</p>\n\n<p>即</p>\n<p>若要同时设置 rwx (可读写运行） 权限则将该权限位 设置 为 4 + 2 + 1 = 7</p>\n<p>若要同时设置 rw- （可读写不可运行）权限则将该权限位 设置 为 4 + 2 = 6</p>\n<p>若要同时设置 r-x （可读可运行不可写）权限则将该权限位 设置 为 4 +1 = 5</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中\na,b,c各为一个数字，分别代表User、Group、及Other的权限。\n相当于简化版的\nchmod u=权限,g=权限,o=权限 file...\n而此处的权限将用8进制的数字来表示User、Group、及Other的读、写、执行权限</p>\n<p>示例：设置所有人可以读写及执行</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>设置拥有者可读写，其他人不可读写执行</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 更改文件拥有者（chown命令）</h2>\n<p>linux/Unix 是多人多工作业系统，每个的文件都有拥有者（所有者），如果我们想变更文件的拥有者（利用 chown 将文件拥有者加以改变），一般只有系统管理员(root)拥有此操作权限，而普通用户则没有权限将自己或者别人的文件的拥有者设置为别人。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>示例：设置文件 d.key、e.scrt的拥有者设为 users 群体的 tom</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>设置当前目录下与子目录下的所有文件的拥有者为 users 群体的 James</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> echo</h2>\n<p>输出内容到文件</p>\n<h3> 覆盖方式</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>追加方式</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> EOF</h2>\n<p>EOF是END Of File的缩写,表示自定义终止符.既然自定义,那么EOF就不是固定的,可以随意设置别名,在linux按ctrl-d就代表EOF.\nEOF一般会配合cat能够多行文本输出.</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 线上查询、帮助文档</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 文件和目录</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 查看文件及内容处理</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 文件压缩解压</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 显示系统信息命令</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 搜索文件</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 用户命令</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 基础网络</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container info\">\n<p class=\"hint-container-title\">ARP</p>\n<p><a href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html</a></p>\n<p>什么是ARP?\nARP（Address Resolution Protocol，地址解析协议）是用来将IP地址解析为MAC地址的协议。主机或三层网络设备上会维护一张ARP表，用于存储IP地址和MAC地址的映射关系，一般ARP表项包括动态ARP表项和静态ARP表项</p>\n<p>为什么需要ARP?</p>\n<p>在局域网中，当主机或其它三层网络设备有数据要发送给另一台主机或三层网络设备时，需要知道对方的网络层地址（即IP地址）。但是仅有IP地址是不够的，因为IP报文必须封装成帧才能通过物理网络发送，因此发送方还需要知道接收方的物理地址（即MAC地址），这就需要一个通过IP地址获取物理地址的协议，以完成从IP地址到MAC地址的映射。地址解析协议ARP即可实现将IP地址解析为MAC地址。</p>\n</div>\n<h2> 查看端口占用</h2>\n<blockquote>\n<p>lsof -i:22 <br>\nnetstat -tunlp | grep 22</p>\n</blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 输入网络操作命令</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 系用户权限相关</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 查看系统用户登录信息的命令</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 内置命令</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 系统关联与性能</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 关机 重启 注销 和查看系统信息</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 进程关联相关命令</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.835Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "sed",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/linux/sed.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/linux/sed.html",
      "summary": "sed Linux sed 命令是利用脚本来处理文本文件。 sed 可依照脚本的指令来处理、编辑文本文件。 sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。 查找 指定行号查找 [root@w1 ~]# sed -n '2p' test.txt 篮球 最后一行 [root@w1 ~]# sed -n '$p' test.txt 篮球 指定行号范围查找 [root@w1 ~]# sed -n '1,2p' test.txt hello world 篮球 指定行号范围查找 2 到最后一行 [root@w1 ~]# sed -n '2,$p' test.txt hello world 篮球 正则查找 [root@w1 ~]# sed -n '/篮/p' test.txt 篮球 查找含有3的行 -r 是对正则扩展的支持 [root@w1 ~]# sed -nr '/[3]/p' test.txt 10:30 运动 13:00 code 时间范围查找 注意： 如果结尾没有匹配到，会查询到最后一行 [root@w1 ~]# cat test.txt hello world 10:00 篮球 10:30 运动 11:00 吃饭 12:00 睡觉 13:00 code [root@w1 ~]# sed -n '/10:00/,/11:00/p' test.txt 10:00 篮球 10:30 运动 11:00 吃饭",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">sed</p>\n<p>Linux sed 命令是利用脚本来处理文本文件。<br>\nsed 可依照脚本的指令来处理、编辑文本文件。<br>\nsed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。<br></p>\n</div>\n<h2> 查找</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 删除</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> ! 的妙用 ，！ 一般是取反</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 增加</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 替换</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.838Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "基础",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/mongodb/%E5%9F%BA%E7%A1%80.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/mongodb/%E5%9F%BA%E7%A1%80.html",
      "summary": "参考 https://github.com/lojzes/middle-study/blob/master/mongodb/src/test/java/com/lojzes/middle/mongo/Test01.java https://blog.csdn.net/a1120467800/article/details/109954145",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://github.com/lojzes/middle-study/blob/master/mongodb/src/test/java/com/lojzes/middle/mongo/Test01.java\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/lojzes/middle-study/blob/master/mongodb/src/test/java/com/lojzes/middle/mongo/Test01.java</a></p>\n<p><a href=\"https://blog.csdn.net/a1120467800/article/details/109954145\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/a1120467800/article/details/109954145</a></p>\n</div>\n<h2> 下载 、解压</h2>\n<p>https://www.mongodb.com/try/download/community</p>\n<h2> 启动</h2>\n<p>在解压的后根文件夹，创建数据文件</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置文件方式启动</p>\n<p>在安装目录下 新建 config 文件夹，</p>\n<p>mongodb.conf</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 详细配置文件</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> GUI</h2>\n<p>https://www.mongodb.com/try/download/compass</p>\n<h2> 链接客户端</h2>\n<p>执行</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 选择和创建数据库</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 常用命令</h2>\n<h3> show dbs</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 删除数据</h3>\n<p>在当前库上执行</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 创建collection</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 删除集合</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 创建文档</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 查询文档</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 插入多个 inserMany</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 查询单条</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 显示字段控制</h3>\n<p>只显示 name 字段 和 _id</p>\n<p>如果也把 _id 也隐藏，</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 更新</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 列值增长修改</h3>\n<p><code>$inc</code> 每次增长为1</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 删除文档</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 统计文档数 count</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 限制条数查询</h2>\n<p>limit 只查询2条</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 跳数查询 skip</h2>\n<p><code>skip(2)</code> 跳过前2条</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> sort</h2>\n<p>1  为升序\n-1 为降序</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 复杂正则查询</h2>\n<p>包含 <code>海淀</code> 的都会匹配</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 比较查询</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> in 查询</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 关系连接</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 查看当前数据库</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 默认的3个库</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p></p>\n<h2> 索引</h2>\n<p>查看文档索引</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 创建索引</h3>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 删除索引</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 执行计划</h2>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>userId 加索引后</p>\n<div class=\"language-javascript line-numbers-mode\" data-ext=\"js\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.856Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "mysql sql 调优",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/mysql/mysql-sql%E8%B0%83%E4%BC%98.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/mysql/mysql-sql%E8%B0%83%E4%BC%98.html",
      "summary": "参考 掌握这12个SQL优化方法，你基本上就无敌了 mysql内部逻辑图 1）连接器：主要负责跟客户端建立连接、获取权限、维持和管理连接。 2）查询缓存：优先在缓存中进行查询，如果查到了则直接返回，如果缓存中查询不到，在去数据库中查询。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://dbaplus.cn/news-155-4717-1.html\" target=\"_blank\" rel=\"noopener noreferrer\">掌握这12个SQL优化方法，你基本上就无敌了</a></p>\n</div>\n<p>mysql内部逻辑图</p>\n<p></p>\n<p>1）连接器：主要负责跟客户端建立连接、获取权限、维持和管理连接。</p>\n<p>2）查询缓存：优先在缓存中进行查询，如果查到了则直接返回，如果缓存中查询不到，在去数据库中查询。</p>\n<p>MySQL缓存是默认关闭的，也就是说不推荐使用缓存，并且在MySQL8.0 版本已经将查询缓存的整块功能删掉了。这主要是它的使用场景限制造成的：</p>\n\n<p>3）解析器/分析器：分析器的工作主要是对要执行的SQL语句进行词法解析、语法解析，最终得到抽象语法树，然后再使用预处理器对抽象语法树进行语义校验，判断抽象语法树中的表是否存在，如果存在的话，在接着判断select投影列字段是否在表中存在等。</p>\n<p>4）优化器：主要将SQL经过词法解析、语法解析后得到的语法树，通过数据字典和统计信息的内容，再经过一系列运算 ，最终得出一个执行计划，包括选择使用哪个索引。</p>\n<p>在分析是否走索引查询时，是通过进行动态数据采样统计分析出来；只要是统计分析出来的，那就可能会存在分析错误的情况，所以在SQL执行不走索引时，也要考虑到这方面的因素。</p>\n<p>5）执行器：根据一系列的执行计划去调用存储引擎提供的API接口去调用操作数据，完成SQL的执行。</p>\n<h2> SQL语句的优化</h2>\n<h3> 尽量避免使用子查询</h3>\n<p>例：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其子查询在<code>Mysql5.5</code>版本里，内部执行计划是这样：<u>先查外表再匹配内表，而不是先查内表t2，当外表的数据很大时，查询速度会非常慢</u>。</p>\n<p>在<code>MariaDB10/Mysql5.6</code>版本里，采用join关联方式对其进行了优化，这条SQL语句会<u>自动转换为</u>：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>但请注意的是：<u>优化只针对<code>SELECT</code>有效，对<code>UPDATE/DELETE</code>子查询无效，固生产环境应避免使用子查询</u></p>\n<p>由于<code>MySQL</code>的优化器对于子查询的处理能力比较弱，所以不建议使用子查询，可以改写成<code>Inner Join</code>，之所以 <code>join</code> 连接效率更高，是因为 MySQL<u>不需要在内存中创建临时表</u></p>\n<h3> 用IN来替换OR</h3>\n\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>另外，MySQL对于<code>IN</code>做了相应的优化，即将<code>IN</code>中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>对于<u>连续的数值，能用 between 就不要用 in 了；再或者使用连接来替换。</u></p>\n<h2> 读取适当的记录LIMIT M,N，而不要读多余的记录</h2>\n\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>使用上述<code>sql</code>语句做分页的时候，可能有人会发现，随着<u>表数据量的增加，直接使用limit分页查询会越来越慢</u>。</p>\n<p>对于 <code>limit m, n </code>的分页查询，越往后面翻页（即m越大的情况下）SQL的耗时会越来越长，对于这种应该先取出主键id，然后通过主键id跟原表进行Join关联查询。因为MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。</p>\n<p>优化的方法如下：可以取前一页的最大行数的id（将上次遍历到的最末尾的数据ID传给数据库，然后直接定位到该ID处，再往后面遍历数据），然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。sql可以采用如下的写法：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 禁止不必要的Order By 排序</h3>\n\n<p>另外，分组统计查询时可以禁止其默认排序</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>默认情况下，Mysql会对所有的<code>GROUP BT col1,col2…</code>的字段进行排序，也就是说上述会对 goods_id进行排序，如果想要避免排序结果的消耗，可以指定<code>ORDER BY NULL</code>禁止排序：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 总和查询可以禁止排重用union all</h3>\n<p><code>union</code>和<code>union all</code>的差异主要是<u>前者</u>需要将结<u>果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟</u>。</p>\n<p>当然，<code>union all</code> 的前提条件是两个结果集没有重复数据。所以一般是我们明确知道不会出现重复数据的时候才建议使用 <code>union all </code>提高速度。</p>\n<h3> 避免随机取记录</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上两个语句都无法用到索引</p>\n<h3> 将多次插入换成批量Insert插入</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 只返回必要的列，用具体的字段列表代替 select * 语句</h3>\n<p><code>SELECT * </code>会增加很多不必要的消耗（<code>cpu、io、内存、网络带宽</code>）；增加了使用覆盖索引的可能性；当表结构发生改变时，前者也需要经常更新。所以要求直接在<code>select</code>后面接上字段名。</p>\n<p><code>MySQL</code>数据库是按照行的方式存储，而数据存取操作都是以一个页大小进行<code>IO</code>操作的，每个IO单元中存储了多行，每行都是存储了该行的所有字段。所以无论取一个字段还是多个字段，实际上数据库在表中需要访问的数据量其实是一样的。</p>\n<p>但是如果查询的字段都在索引中，也就是覆盖索引，那么可以直接从索引中获取对应的内容直接返回，不需要进行回表，减少<code>IO</code>操作。除此之外，当存在 <code>order by </code>操作的时候，<code>select</code> 子句中的字段多少会在很大程度上影响到我们的排序效率。</p>\n<h3> 区分in和exists</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>上面的语句相当于：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>区分<code>in</code>和<code>exists</code>主要是造成了<code>驱动顺序</code>的改变（这是性能变化的关键），如果是<code>exists</code>，\n那么<code>以外层表为驱动表</code>，<code>先被访问</code>，如果是<code>IN</code>，那么<code>先执行子查询</code>。所以<code>IN</code>适合于<code>外表大而内表小</code>的情况；\n<code>EXISTS</code>适合于<code>外表小而内表大</code>的情况。</p>\n<p>另外，<code>in</code>查询在某些情况下有可能会查询返回错误的结果，因此，\n通常是<u>建议在确定且有限的集合时，可以使用<code>in</code>。如 <code>IN （0，1，2）</code></u>。</p>\n<h3> 优化Group By语句</h3>\n<p>如果对<code>group by</code>语句的结果没有排序要求，要在语句后面加 <code>order by null</code>（<code>group</code> 默认会排序）；</p>\n<p>尽量让<code>group by</code>过程用上表的索引，确认方法是<code>explain</code>结果里没有<code>Using temporary 和 Using filesort</code>；</p>\n<p>如果<code>group by</code>需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大<code>tmp_table_size</code>参数，来避免用到磁盘临时表；</p>\n\n<p>使用<code>where</code>子句替换<code>Having子</code>句：避免使用<code>having</code>子句，<code>having</code>只会在检索出所有记录之后才会对结果集进行过滤，这个处理需要排序分组，如果能通过<code>where</code>子句提前过滤查询的数目，就可以减少这方面的开销。</p>\n\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 尽量使用数字型字段</h3>\n<p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能。\n引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>\n<h3> 优化Join语句</h3>\n<p>当我们执行两个表的<code>Join</code>的时候，就会有一个比较的过程，逐条比较两个表的语句是比较慢的，\n因此可以把两个表中数据依次读进一个内存块中，在Mysql中执行：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>可以看到·在内存中的缓存池大小，其大小将会影响join语句的性能。在执行<code>join</code>的时候，\n数据库会选择一个表把他要返回以及需要进行和其他表进行比较的数据放进<code>join_buffer</code>。</p>\n<p><u>什么是驱动表，什么是被驱动表，</u>这两个概念在查询中有时容易让人搞混，有下面几种情况，大家需要了解。</p>\n<p>1）当连接查询没有where条件时</p>\n\n<p>2）当连接查询有where条件时，带where条件的表是驱动表，否则是被驱动表</p>\n<p>假设有表如右边：t1与t2表完全一样，a字段有索引，b无索引，t1有100条数据，t2有1000条数据</p>\n<p>若被驱动表有索引，那么其执行算法为：Index Nested-Loop Join（NLJ），示例如下：</p>\n<p>①执行语句：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>由于被驱动表<code>t2.a</code>是有索引的，其执行逻辑如下：</p>\n\n<p></p>\n<p>若被驱动表无索引，那么其执行算法为：Block Nested-Loop Join（BLJ）（Block 块，每次都会取一块数据到内存以减少I/O的开销），示例如下：</p>\n<p>②执行语句：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>由于被驱动表t2.b是没有索引的，其执行逻辑如下：</p>\n\n<h3> 尽可能减少Join语句中的NestedLoop的循环次数：“永远用小结果集驱动大的结果集”</h3>\n<p>用小结果集驱动大结果集，将筛选结果小的表（在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”）首先连接，再去连接结果集比较大的表，尽量减少join语句中的Nested Loop的循环总次数</p>\n<p>优先优化<code>Nested Loop</code>的内层循环（也就是最外层的Join连接），因为内层循环是循环中执行次数最多的，每次循环提升很小的性能都能在整个循环中提升很大的性能；</p>\n<p>对被驱动表的<code>join</code>字段上建立索引；</p>\n<p>当被驱动表的<code>join</code>字段上无法建立索引的时候，设置足够的<code>Join Buffer Size。</code></p>\n<p>尽量用<code>inner join</code>(因为其会自动选择小表去驱动大表).</p>\n<p>避免 <code>LEFT JOIN </code>(一般我们使用<code>Left Join</code>的场景是大表驱动小表)和NULL，那么如何优化<code>Left Join</code>呢？</p>\n<p>条件中尽量能够过滤一些行将驱动表变得小一点，用小表去驱动大表</p>\n<p>右表的条件列一定要加上索引（<code>主键、唯一索引、前缀索引</code>等），最好能够使<code>type</code>达到<code>range</code>及以上<code>（ref,eq_ref,const,system）</code></p>\n<p>适当地在表里面添加冗余信息来减少<code>join</code>的次数</p>\n<p>使用更快的固态硬盘</p>\n<p>性能优化，<code>left join</code> 是由左边决定的，左边一定都有，所以右边是我们的关键点，建立索引要建在右边。\n当然如果索引是在左边的，我们可以考虑使用右连接，如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container warning\">\n<p class=\"hint-container-title\">提示</p>\n<p>Join左连接在右边建立索引；\n组合索引则尽量将数据量大的放在左边，在左边建立索引。</p>\n</div>\n<h2> 索引的优化/如何避免索引失效</h2>\n<h3> 最佳左前缀法则</h3>\n<p>如果索引了多列，要遵守最左前缀法则，指的是查询从索引的最左前列开始并且不跳过索引中的列。\n<code>Mysql</code>查询优化器会对查询的字段进行改进，判断查询的字段以哪种形式组合能使得查询更快，\n所有比如创建的是<code>(a,b)</code>索引，查询的是<code>(b,a)</code>，查询优化器会修改成<code>(a,b)</code>后使用索引查询。</p>\n<h2> 不在索引列上做任何操作</h2>\n<p>1）计算：对索引进行表达式计算会导致索引失效，如 <code>where id + 1 = 10</code>，可以转换成 <code>where id = 10 -1</code>，这样就可以走索引</p>\n<p>2）函数：<code>select * from t_user where length(name)=6;</code> 此语句对字段使用到了函数，会导致索引失效</p>\n<p>从 <code>MySQL 8.0</code> 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，\n也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>（自动/手动）类型转换</p>\n<p>（<u>字符串类型必须带''引号才能使索引生效</u>）字段是varchar，用整型进行查询时，无法走索引，\n如</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>Mysql</code> 在执行上述语句时，会把字段转换为数字再进行比较，所以上面那条语句就相当于：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>CAST</code> 函数是作用在了 <code>phone</code> 字段，而 <code>phone</code> 字段是索引，也就是对索引使用了函数！所以索引失效</p>\n<p>字段是<code>int</code>，用<code>string</code>进行查询时，<code>mysql</code>会自动转化，可以走索引，如：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>MySQL</code> 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。以上这条语句相当于：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的。</p>\n<h3> 存储引擎不能使用索引中范围条件右边的列。</h3>\n<p>如这样的<code>sql</code>:</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>其中<code>username, age, phone</code>都有索引，<u>只有<code>username</code>和<code>age</code>会生效，<code>phone</code>的索引没有用到</u>。</p>\n<h3> 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致））</h3>\n<p>如<code>select age from user，减少select *</code></p>\n<h3> mysql在使用负向查询条件(!=、&lt;&gt;、not in、not exists、not like)的时候无法使用索引会导致全表扫描。</h3>\n<p>你可以想象一下，对于一棵B+树，根节点是40，如果你的条件是等于20，就去左面查，你的条件等于50，就去右面查，但是你的条件是不等于66，索引应该咋办？还不是遍历一遍才知道。</p>\n<h3> is null, is not null 也无法使用索引，在实际中尽量不要使用null（避免在 where 子句中对字段进行 null 值判断） 不过在mysql的高版本已经做了优化，允许使用索引</h3>\n<p>对于<code>null</code>的判断会导致引擎放弃使用索引而进行全表扫描。</p>\n<h3> like 以通配符开头(%abc..)时，mysql索引失效会变成全表扫描的操作。</h3>\n<p>所以最好用右边<code>like ‘abc%’</code>。如果两边都要用，可以用</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中username是必须是索引列，才可让索引生效</p>\n<p>假如i<code>ndex(a,b,c)</code>,<code> where a=3 and b like ‘abc%’ and c=4</code>，<code>a能用，b能用，c不能用</code>，类似于不能使用范围条件右边的列的索引</p>\n<p>对于一棵B+树索引来讲，如果根节点是字符def，假如查询条件的通配符在后面，例如abc%，则其知道应该搜索左子树，假如传入为efg%，则应该搜索右子树，如果通配符在前面%abc，则数据库不知道应该走哪一面，就都扫描一遍了。</p>\n<h3> 少用or，在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</p>\n<p>必须要or前后的字段都有索引，查询才能使用上索引（分别使用，最后合并结果<code>type = index_merge</code>）</p>\n<p></p>\n<h3> 在组合/联合索引中，将有区分度的索引放在前面</h3>\n<p>如果没有区分度，例如用性别，相当于把整个大表分成两部分，查找数据还是需要遍历半个表才能找到，使得索引失去了意义。</p>\n<h3> 使用前缀索引</h3>\n<p><code>短索引</code>不仅可以提高查询性能而且可以节省磁盘空间和I/O操作，减少索引文件的维护开销，但缺点是不能用于 <code>ORDER BY</code> 和 <code>GROUP BY </code>操作，也不能用于覆盖索引。</p>\n<p>比如有一个<code>varchar(255)</code>的列，如果该列在前10个或20个字符内，可以做到既使前缀索引的区分度接近全列索引，\n那么就不要对整个列进行索引。为了减少<code>key_len</code>，可以考虑创建前缀索引，即指定一个前缀长度，可以使用\n<code>count(distinct leftIndex(列名, 索引长度))/count(*) </code>来计算前缀索引的区分度。</p>\n<h3> SQL 性能优化 explain 中的 type：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。</h3>\n\n<p>当 type=index 时，索引物理文件全扫，速度非常慢。</p>\n",
      "date_modified": "2023-08-03T23:47:30.871Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "mysql",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/mysql/mysql.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/mysql/mysql.html",
      "summary": "参考 centos7安装mysql8 https://www.cnblogs.com/greyzeng/p/16756049.html",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.cnblogs.com/secretmrj/p/15600144.html\" target=\"_blank\" rel=\"noopener noreferrer\">centos7安装mysql8</a>\n<a href=\"https://www.cnblogs.com/greyzeng/p/16756049.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/greyzeng/p/16756049.html</a></p>\n</div>\n<h2> 下载</h2>\n<p>https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.33-linux-glibc2.17-x86_64-minimal.tar.xz</p>\n<h2> 环境配置</h2>\n<p>centos7</p>\n<h3> hostname</h3>\n<p>查看hostname</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>m</code>\n<code>w1</code>\n<code>w2</code></p>\n<h3> hosts</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> ssh 免密登录</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 测试</h2>\n<p>在 m 执行</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 安装软件目录规定</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> mysql 单机安装</h2>\n<h3> minimal 安装方式</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> my_env.sh 环境变量</h2>\n<p>自己安装的软件，可以都写在 /etc/profile.d/my_env.sh 内，统一管理</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 确认安装</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 创建用户组、用户</h2>\n<p>mysql 启动时默认使用 mysql 用户</p>\n<p>建用户组：groupadd</p>\n<p>创建用户：useradd（-r 创建系统用户，-g 指定用户组）</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 创建数据目录</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> centos7 vim 中文乱码</h2>\n<p>先查看系统默认编码</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>解决linux下vim中文乱码的方法\n问题出在vim上，对于CentOS应该修改 /etc/vimrc 文件，在该文件头上添加下面四行代码</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 修改配置文件</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> my.cnf</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 初始化</h2>\n<p>初始化命令：注意文件夹名称。</p>\n\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 启动服务</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 登录</h2>\n<p>无密码：若以 <code>--initialize-insecure</code> 初始化，首次登录时跳过密码。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>有密码：若初始化时设置了随机密码，在 <code>/data/mysql8_data/mysql/mysql.log </code>查看</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 修改密码</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 退出关闭服务</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> service 启动和关闭mysql</h2>\n<p>修改</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 创建远程连接用户</h2>\n<p>选择 mysql 数据库，查看当前用户</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建用户，任意远程访问</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> mysql 集群安装</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 在主库上新建 主从同步账号</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 从数据库配置</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 创建用户组、用户</h3>\n<p>mysql 启动时默认使用 mysql 用户</p>\n<p>建用户组：groupadd</p>\n<p>创建用户：useradd（-r 创建系统用户，-g 指定用户组）</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 创建数据目录</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 初始化</h3>\n<p>初始化命令：注意文件夹名称。</p>\n\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 启动服务</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 更改主从关系</h3>\n<p>在主库上</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>在从库上执行</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 验证 copy 能否登录上 主库</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 启动 slave</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 检查是否启动正常</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 查询错误详情</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 注意</h2>\n<p>主从同步时，要保证主从中库一样，因为主从复制，不会在从库上创建数据库；\n如果主中有数据，则在同步之前要把数据导入从库</p>\n<h3> rpm 安装方式</h3>\n<p>下载安装包</p>\n<p>https://repo.mysql.com//mysql80-community-release-el7-7.noarch.rpm</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>默认安装 的配置文件在</p>\n<p>/etc/my.cnf</p>\n<h2> 修改 my.cnf</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.881Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "mysql主从复制",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/mysql/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/mysql/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html",
      "summary": "参考 mysql主从复制与读写分离 Mysql 主从复制原理 Mysql 的主从复制和 MySQL 的读写分离两者联系紧密，先要部署主从复制，然后在此基础上进行数据的读写分离。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.cnblogs.com/darryallen/p/15236550.html\" target=\"_blank\" rel=\"noopener noreferrer\">mysql主从复制与读写分离</a></p>\n</div>\n<h2> Mysql 主从复制原理</h2>\n<p><code>Mysql</code> 的主从复制和 <code>MySQL</code> 的读写分离两者联系紧密，先要部署主从复制，然后在此基础上进行数据的读写分离。</p>\n<h3> <code>MySQL</code> 支持的复制类型</h3>\n<ul>\n<li>基于语句的复制<code>（STATEMENT）</code>。在主服务器上执行的 <code>SQL</code> 语句，在从服务器上执行同样的语句。<code>MySQL</code> 默认采用基于语句的复制，效率比较高。</li>\n<li>基于行的复制<code>（ROW）</code>。把改变的内容复制过去，而不是把命令在从服务器上执行一遍。</li>\n<li>混合类型的复制<code>（MIXED）</code>。默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。</li>\n</ul>\n<h3> <code>MySQL</code>主从复制的工作过程</h3>\n<p></p>\n<h2> MySQL支持的复制类型</h2>\n<ul>\n<li>STATEMENT∶基于语句的复制。在服务器上执行SQL语句，在从服务器上执行同样的语句，mysgl默认采用基于语句的复制，执行效率高。</li>\n</ul>\n<blockquote>\n<p>虽然效率较高但是高并发情况下可能精确度不够</p>\n</blockquote>\n<ul>\n<li>ROW∶基于行的复制。把改变的内容复制过去，而不是把命令在从服务器上执行一遍</li>\n</ul>\n<blockquote>\n<p>虽然拥有很高的精确度，但是读写效率较低</p>\n</blockquote>\n<ul>\n<li>MIXED∶混合类型的复制。默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制</li>\n</ul>\n<blockquote>\n<p>结合前两种类型的优点，比较实用</p>\n</blockquote>\n<h3> 主从复制的工作原理</h3>\n<p>（1）Master节点将数据的改变记录成二进制日志（Binary log），当Master上的数据发生改变时，则将其改变写入二进制日志中。</p>\n<p>（2）Slave节点会在一定时间间隔内对Master的二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/O线程请求Master的二进制事件。</p>\n<p>（3）同时Master节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至Slave节点本地的中继日志（Relay log）中，Slave节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，即解析成sql语句逐一执行，使得其数据和Master节点的保持一致，最后I/O线程和SQL线程将进入睡眠状态，等待下一次被唤醒。</p>\n<p>也就是说：</p>\n<blockquote>\n<p>在每个事务更新数据完成之前，Master在二进制日志(Binary log)记录这些改变。写入二进制日志完成后，Master通知存储引擎提交事务。\nSlave将Master复制到其中继日志(Relay log) 。首先slave开始一个工作线程(I/O)，I/0线程在Master上打开一个普通的连接，然后开始Binlog dump process。Binlog dump process 从Master的二进制日志中读取事件，如果已经跟上 Master ,它会睡眠并等待Master产生新的事件，I/O线程将这些事件写入中继日志（缓存中）。\nSQL slave thread (SQL从线程)处理该过程的最后一步，SQL线程从中继日志读取事件，并重放其中的事件而更新 Slave 数据，使其与Master 中的数据一致，只要该线程与I/O 线程保持一致，执行结束后I/O线程和SQL线程都会进行睡眠状态等待下一次操作的执行</p>\n</blockquote>\n<blockquote>\n<p>注：\n中继日志通常位于OS缓存中，所以中继日志的开销很小。\n复制过程有一个很重要的限制，即复制在Slave上是串行化的，也就是说Master上的并行更新操作不能在Slave上并行操作。</p>\n</blockquote>\n<h2> MySQL主从复制延迟及解决思路</h2>\n<p>（1）master服务器高并发，形成大量事务</p>\n<p>（2）网络波动，延迟</p>\n<p>（3）主从硬件设备差异过大导致（如cpu主频、内存io、硬盘io）</p>\n<p>（4）本来就不是同步复制、而是异步复制</p>\n<p>解决方案：</p>\n<p>（1）从库优化Mysql参数。比如增大<code>Innodb_buffer_pool_size</code>，该参数定义了<code>InnoDB</code>存储引擎的表数据和索引数据的最大内存缓冲区大小，让更多操作在<code>Mysql</code>内存中完成，减少磁盘操作。</p>\n<blockquote>\n<p>一般设置 buffer pool 大小为总内存的  3/4 至 4/5 约等于总内存的80%。</p>\n</blockquote>\n<p>（2）从库使用高性能主机。包括<code>cpu</code>强悍、内存加大。避免使用虚拟云主机，使用物理主机，这样提升了<code>i/o</code>方面性。</p>\n<p>（3）从库使用<code>SSD</code>磁盘（固态硬盘）</p>\n<p>（4）网络优化，避免跨机房实现同步（减小网络延迟）</p>\n<h3> mysql 优化</h3>\n<p>查询速度慢的问题：</p>\n<p>用于缓存 索引 和 数据的内存大小, 这个当然是越多越好, 数据读写在内存中非常快, 减少了对磁盘的读写。 当数据提交或满足检查点条件后才一次性将内存数据刷新到磁盘中。然而内存还有操作系统或数据库其他进程使用, 一般设置 buffer pool 大小为总内存的  3/4 至 4/5。</p>\n<p>并提出：较优设置：假设系统内存 = 128 GB, buffer pool 大小预计100GB(128GB*80%)</p>\n<p>查询cpu 个数</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.883Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "mysql优化",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/mysql/mysql%E4%BC%98%E5%8C%96.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/mysql/mysql%E4%BC%98%E5%8C%96.html",
      "summary": "参考 看MySQL的参数调优及数据库锁实践有这一篇足够了 MySQL调优之服务器参数优化实践",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1480451\" target=\"_blank\" rel=\"noopener noreferrer\">看MySQL的参数调优及数据库锁实践有这一篇足够了</a></p>\n<p><a href=\"https://blog.csdn.net/J080624/article/details/88065417\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL调优之服务器参数优化实践</a></p>\n</div>\n<h2> InnoDB内存优化</h2>\n<p>innoDB用一块内存区做IO缓存池，该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。</p>\n<h3> innodb_buffer_pool_size</h3>\n<p>innodb_buffer_pool_size\n该变量决定了innodb存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I/O就越少，性能也就越高。</p>\n<p>用于缓存 索引 和 数据的内存大小, 这个当然是越多越好, 数据读写在内存中非常快, 减少了对磁盘的读写。 当数据提交或满足检查点条件后才一次性将内存数据刷新到磁盘中。然而内存还有操作系统或数据库其他进程使用, 一般设置 buffer pool 大小为总内存的  3/4 至 4/5。</p>\n<p>并提出：较优设置：假设系统内存 = 128 GB, buffer pool 大小预计100GB(128GB*80%)</p>\n<p>查询cpu 个数</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>innodb_buffer_pool_instances = 8 </code> #默认值,或者逻辑CPU数量</p>\n<p><code>innodb_buffer_pool_chunk_size = 128MB</code> #默认值</p>\n<p><code>innodb_buffer_pool_size = 100 GB </code>  # N<em>8</em>128MG = N GB ,N 刚好为正整数。设 N=100使得 buffer pool 为总内存的 3/4 至 4/5。</p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>在调整 <code>innodb_buffer_pool_size</code> 期间，用户的请求将会阻塞，直到调整完毕，所以请勿在白天调整，在凌晨3-4点低峰期调整。</p>\n</div>\n<h2> 日志优化</h2>\n<h3> innodb_log_file_size</h3>\n<p>作用：指定在一个日志组中，每个log的大小。结合<code>innodb_buffer_pool_size</code>设置其大小，25%-100%。避免不需要的刷新。</p>\n<p>注意：这个值分配的大小和数据库的写入速度，事务大小，异常重启后的恢复有很大的关系。一般取256M可以兼顾性能和recovery的速度。</p>\n<p>分配原则：几个日志成员大小加起来差不多和你的<code>innodb_buffer_pool_size</code>相等。上限为每个日志上限大小为4G。一般控制在几个Log文件相加大小在2G以内为佳。具体情况还需要看你的事务大小，数据大小为依据。</p>\n<p>可以在my.cnf文件里设置：</p>\n<p>innodb_log_file_size = 256M</p>\n<p>这个参数是一个日志组中每个日志文件的大小,此参数在高写入负载尤其是大数据集的情况下很重要。这个值越大则性能相对越高,但好似副作用是一旦系统崩溃恢复的时间会加长</p>\n<h3> innodb_log_buffer_size</h3>\n<p>决定innodb重做日志缓存的大小，对于可能产生大量更新记录的大事务，\n增加<code>innodb_log_buffer_size</code>的大小，可用避免innodb在事物提交前就执行不必要的日志写入磁盘操作。\n<code> innodb_log_buffer_size=10M</code></p>\n<h2> 文件IO与空间占用</h2>\n<h3> innodb_file_per_table</h3>\n<p>作用：使每个<code>Innodb</code>的表，有自已<code>独立的表空间</code>。如删除文件后可以<code>回收那部分空间</code>。默认是关闭的，建议打开（innodb_file_per_table=1）</p>\n<p>分配原则：只有使用不使用。但DB还需要有一个公共的表空间。</p>\n<p>在my.cnf文件里设置：</p>\n<p><code>innodb_file_per_table=1</code></p>\n<h2> innodb_open_files</h2>\n<p>作用：限制Innodb能打开的表的数据。</p>\n<p>分配原则：这个值默认是<code>300</code>。如果库里的表特别多的情况，可以适当增大为<code>1000</code>。</p>\n<p><code>innodb_open_files</code>的大小对<code>InnoDB</code>效率的影响比较小。但是在InnoDBcrash的情况下，innodb_open_files设置过小会影响recovery的效率。所以用InnoDB的时候还是把innodb_open_files放大一些比较合适。</p>\n<p>在my.cnf文件里设置：</p>\n<p><code>innodb_open_files=800</code></p>\n<h2> MySQL并发参数调整</h2>\n<p>从实现上来说，MySQL Server是多线程结构，包括后台线程和客户服务线程。多线程可用有效利用服务器资源，提供数据库的并发性能。\n在MySQL中，控制并发连接和线程的主要参数包括max_connections、back_log、thread_cache_siez、table_open_cache。</p>\n<h3> max_connections</h3>\n<p>采用max_connections控制允许连接到MySQL数据库的最大数量，默认值时<code>151</code>.如果状态变量<code>connection_errors_max_connections</code>不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections的值。\n<code>MySQL</code>最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux平台下，性能好的服务器，支持<code>500-1000</code>个连接不是难事，需要根据服务器性能进行评估设定。</p>\n<h3> back_log</h3>\n<p>back_log参数控制MySQL监听TCP端口时设置的积压请求栈大小。如果MySQL的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6版本之前默认值为50，之后的版本默认为50+（max_connections / 5），最大不超过900。\n如果需要数据库在较短的时间内处理大量连接请求，可以考虑适当增大back_log的值。</p>\n<h3> table_open_cache</h3>\n<p>该参数用来控制所有SQL语句执行线程可打开表缓存的数量，而在执行SQL语句时，每一个SQL执行线程至少要打开1个表缓存。该参数的值应该根据设置的最大连接数mac_connections以及每个连接执行关联查询中涉及的表的最大数量来设定 ：\nmax_connections x N ;</p>\n<h3> thread_cache_size</h3>\n<p>为了加快连接数据库的速度，MySQL会缓存一定数量的客户服务线程以备重用，通过参数 <code>thread_cache_size</code> 可控制MySQL缓存客户服务线程的数量。</p>\n<h3> innodb_lock_wait_timeout</h3>\n<p>该参数是用来设置InnoDB事务等待行锁的时间，默认值是50ms，可以根据需要进行动态设置。对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起；对于后台运行的批量处理程序来说，可以将行锁的等待时间调大，以避免发生大的回滚操作。</p>\n<h2> 常用SQL技巧</h2>\n<p>SQL执行顺序</p>\n<p>编写顺序</p>\n<p></p>\n<p>执行顺序</p>\n<p></p>\n",
      "date_modified": "2023-08-03T23:47:30.885Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "nginx",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/nginx/%E5%9F%BA%E7%A1%80.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/nginx/%E5%9F%BA%E7%A1%80.html",
      "summary": "参考 源码安装 下载源码 https://nginx.org/download/nginx-1.24.0.tar.gz 安装 配置configure # 执行 指定安装目录 ./configure --prefix=/soft/nginx-test1 make &amp;&amp; make install # 输出 Configuration summary + using system PCRE2 library + OpenSSL library is not used + using system zlib library nginx path prefix: \"/soft/nginx-test1/nginx\" nginx binary file: \"/soft/nginx-test1/nginx/sbin/nginx\" nginx modules path: \"/soft/nginx-test1/nginx/modules\" nginx configuration prefix: \"/soft/nginx-test1/nginx/conf\" nginx configuration file: \"/soft/nginx-test1/nginx/conf/nginx.conf\" nginx pid file: \"/soft/nginx-test1/nginx/logs/nginx.pid\" nginx error log file: \"/soft/nginx-test1/nginx/logs/error.log\" nginx http access log file: \"/soft/nginx-test1/nginx/logs/access.log\" nginx http client request body temporary files: \"client_body_temp\" nginx http proxy temporary files: \"proxy_temp\" nginx http fastcgi temporary files: \"fastcgi_temp\" nginx http uwsgi temporary files: \"uwsgi_temp\" nginx http scgi temporary files: \"scgi_temp\"",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n</div>\n<h2> 源码安装</h2>\n<h3> 下载源码</h3>\n<p>https://nginx.org/download/nginx-1.24.0.tar.gz</p>\n<h3> 安装</h3>\n<h3> 配置configure</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>看生成的的后续打印情况，缺少依赖就按照缺少依赖</p>\n<h3> 编译</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 安装信息</h3>\n<p>安装目录为</p>\n<p>/soft/nginx-test1</p>\n<h3> 赋值权限</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 常用命令</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:30.895Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "基础",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/ps/%E5%9F%BA%E7%A1%80.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/ps/%E5%9F%BA%E7%A1%80.html",
      "summary": "参考",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n</div>\n",
      "date_modified": "2023-08-03T23:47:30.895Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "主从复制原理",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/redis/copy.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/redis/copy.html",
      "summary": "参考 面试必问的 Redis：主从复制 主从复制实现原理 在当前最新的 Redis 6.0 中，主从复制的完整过程如下： 开启主从复制 通常有以下三种方式：",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/340355908\" target=\"_blank\" rel=\"noopener noreferrer\">面试必问的 Redis：主从复制</a></p>\n</div>\n<h2> 主从复制实现原理</h2>\n<p>在当前最新的 <code>Redis 6.0 </code> 中，主从复制的完整过程如下：</p>\n<h3> 开启主从复制</h3>\n<p>通常有以下三种方式：</p>\n<p>1）在 slave 直接执行命令：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p>\n<p>2）在 slave 配置文件中加入：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p>\n<p>3）使用启动命令：<code>--slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p>\n<p>注：在 <code>Redis 5.0 </code>之后，<code>slaveof</code> 相关命令和配置已经被替换成 <code>replicaof</code>，例如 <code>replicaof &lt;masterip&gt; &lt;masterport&gt;</code>。为了兼容旧版本，通过配置的方式仍然支持 <code>slaveof</code>，但是通过命令的方式则不行了。</p>\n<h3> 建立套接字（socket）连接</h3>\n<p><code>slave</code> 将根据指定的 <code>IP</code> 地址和端口，向 <code>master</code> 发起套接字<code>（socket）</code>连接，<code>master</code> 在接受（<code>accept</code>） <code>slave</code> 的套接字连接之后，为该套接字创建相应的客户端状态，此时连接建立完成。</p>\n<h3> 发送PING命令</h3>\n<p><code>slave</code> 向 <code>master </code>发送一个 <code>PING</code> 命令，以检査套接字的读写状态是否正常、 <code>master</code> 能否正常处理命令请求。</p>\n<p>如果 <code>slave</code> 收到 <code>\"PONG\" </code>回复，那么表示 <code>master</code> 和 <code>slave</code> 之间的网络连接状态正常， 并且 <code>master</code> 可以正常处理命令请求。</p>\n<p>如果是其他回复或者没有回复，表示 <code>master</code> 和 <code>slave</code> 之间的网络连接状态不佳或者 <code>master</code> 暂时没办法处理 <code>slave</code> 的命令请求，则</p>\n<p><code>slave</code> 进入 <code>error</code> <code>流程：slave</code> 断开当前的连接，之后再进行重试。</p>\n<h3> 身份验证</h3>\n<p>如果 <code>master</code> 和 <code>slave</code> 都没有设置密码，则无需验证。</p>\n<p>如果 <code>master</code> 和 <code>slave</code> 都设置了密码，并且密码相同，则验证成功。</p>\n<p>否则，<code>master</code> 和 <code>slave</code> 设置的<code>密码不同</code>、<code>master</code> 和 <code>slave</code> 一个设置密码一个没设置密码都会返回错误。</p>\n<p>所有错误情况都会令 <code>slave</code> 进入 <code>error</code> 流程：<code>slave</code> 断开当前的连接，之后再进行重试。</p>\n<h3> 发送端口信息</h3>\n<p>在身份验证通过后后， <code>slave </code>将向 <code>master</code> 发送自己的监听端口号， <code>master</code> 收到后记录在 <code>slave</code> 所对应的客户端状态的 <code>slave_listening_port</code> 属性中。</p>\n<h3> 发送IP地址</h3>\n<p>如果配置了 <code>slave_announce_ip</code>，则 <code>slave</code> 向 <code>master</code> 发送 <code>slave_announce_ip</code> 配置的 <code>IP</code> 地址， <code>master</code> 收到后记录在 <code>slave</code> 所对应的客户端状态的 <code>slave_ip</code> 属性。</p>\n<p>该配置是用于解决服务器返回内网 <code>IP</code> 时，其他服务器无法访问的情况。可以通过该配置直接指定公网 <code>IP</code>。</p>\n<h3> 发送CAPA</h3>\n<p><code>CAPA</code> 全称是 <code>capabilities</code>，这边表示的是同步复制的能力。</p>\n<p><code>slave</code> 会在这一阶段发送 <code>capa</code> 告诉 <code>master</code> 自己具备的（同步）复制能力， <code>master</code> 收到后记录在 <code>slave</code> 所对应的客户端状态的 <code>slave_capa</code> 属性。</p>\n<p><code>CAPA</code> 在最新的 <code>Redis 6.0</code> 版本中有两种值：<code>eof</code> 和 <code>psync2</code>。</p>\n<p><code>eof</code> 表示 <code>slave</code> 支持直接接收从 <code>socket</code> 发送过来的 <code>RDB</code> 数据流，也就是无盘加载（diskless_load）。</p>\n<p><code>psync2</code> 表示 <code>slave</code> 支持 <code>Redis 4.0 </code>引入的<code>部分重同步 v2</code> 版本，这个在下文会详细介绍。</p>\n<h3> 数据同步</h3>\n<p><code>slave</code> 将向 <code>master</code> 发送 <code>PSYNC</code> 命令， <code>master</code> 收到该命令后判断是进行<code>部分重同步</code>还是<code>完整重同步</code>，然后根据策略进行数据的同步。</p>\n<p>1）如果是 <code>slave</code> 第一次执行复制，则向 <code>master</code> 发送 <code>PSYNC ? -1</code>， <code>master</code> 返回 <code>+FULLRESYNC &lt;replid&gt; &lt;offset&gt;</code> 执行完整重同步</p>\n<p>2）如果不是第一次执行复制，则向 <code>master 发送 </code>PSYNC replid offset<code>，其中 </code>replid<code>是</code>master<code>的复制</code>ID<code>，而 </code>offset<code>是</code>slave<code> 当前的复制偏移量。</code>master<code>根据</code>replid<code>和</code>offset` 来判断应该执行哪种同步操作。</p>\n<p>如果是完整重同步，则返回 <code>+FULLRESYNC &lt;replid&gt; &lt;offset&gt;</code>；如果是部分重同步，则返回 <code>+CONTINUE &lt;replid&gt;</code>，此时 <code>slave</code> 只需等待 <code>master</code> 将自己缺少的数据发送过来就可以。</p>\n<h3> 命令传播</h3>\n<p>当完成了同步之后，就会进人命令传播阶段，这时 <code>master</code> 只要一直将自己执行的写命令发送给 <code>slave</code> ，而 <code>slave</code> 只要一直接收并执行 <code>master</code> 发来的写命令，就可以保证 <code>master</code> 和 <code>slave</code> 一直保持一致了。</p>\n<p>在命令传播阶段， <code>slave</code> 默认会以每秒一次的频率，向 <code>master</code> 发送命令：<code>REPLCONF ACK &lt;reploff&gt;</code>，其中 <code>reploff</code> 是 <code>slave</code> 当前的复制偏移量。</p>\n<p>发送 <code>REPLCONF ACK </code>命令对于主从服务器有三个作用：</p>\n<p>1）检测 master 和 slave 的网络连接状态。</p>\n<p>2）汇报自己的复制偏移量，检测命令丢失，master 会对比复制偏移量，如果发现 slave 的复制偏移量小于自己，会向 slave 发送未同步的数据。</p>\n<p>3）辅助实现 min-slaves 配置，用于防止 master 在不安全的情况下执行写命令。</p>\n<p>例如以下配置表示：当延迟时间小于10秒的 slave 数量小于3个，则会拒绝执行写命令。而这边的延迟时间，就是以 slave 最近一次发送 ACK 时间和当前时间作对比。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 新引入概念</h2>\n<p>实现部分重同步，<code>Redis</code> 引入了<code>复制偏移量</code>、<code>复制积压缓冲区</code>和<code>运行 ID</code> 三个概念。</p>\n<h3> 复制偏移量（offset）</h3>\n<p>执行主从复制的双方都会分别维护一个复制偏移量，<code>master</code> 每次向 <code>slave</code> 传播 <code>N</code> 个字节，自己的复制偏移量就增加 <code>N</code>；同理 <code>slave</code> 接收 <code>N</code> 个字节，复制偏移量也增加 <code>N</code>。通过对比主从之间的复制偏移量就可以知道主从间的同步状态。</p>\n<h3> 复制积压缓冲区（replication backlog buffer）</h3>\n<p>复制积压缓冲区是 <code>master</code> 维护的一个固定长度的 <code>FIFO</code> 队列，默认大小为 <code>1MB</code>。</p>\n<p>当 <code>master</code> 进行命令传播时，不仅将写命令发给 <code>slave</code> 还会同时写进复制积压缓冲区，因此 <code>master</code> 的复制积压缓冲区会保存一部分最近传播的写命令。</p>\n<p>当 <code>slave</code> 重连上 <code>master</code> 时会将自己的复制偏移量通过 <code>PSYNC</code> 命令发给 <code>master</code>，<code>master</code> 检查自己的复制积压缓冲区，如果发现这部分未同步的命令还在自己的复制积压缓冲区中的话就可以利用这些保存的命令进行部分同步，反之如果断线太久这部分命令已经不在复制缓冲区中了，那没办法只能进行全量同步。</p>\n<h3> 运行 ID（runid）</h3>\n<p>每个 <code>Redis server</code> 都会有自己的运行 <code>ID</code>，由 <code>40</code> 个随机的十六进制字符组成。当 <code>slave</code> 初次复制 <code>master</code> 时，<code>master </code>会将自己的运行 <code>ID</code> 发给 <code>slave</code> 进行保存，这样 <code>slave</code> 重连时再将这个运行 <code>ID</code> 发送给重连上的 <code>master</code> ，<code>master</code> 会接受这个 <code>ID</code> 并与自身的运行 <code>ID</code> 比较进而判断是否是同一个 <code>master</code>。</p>\n<p>引入这三个概念后，数据同步过程如下：</p>\n<p>1）<code>slave</code> 通过 <code>PSYNC runid offset </code>命令，将正在复制的 <code>runid</code> 和 <code>offset</code> 发送给 <code>master</code>。</p>\n<p>2）<code>master</code> 判断 <code>runid</code> 和自己的 <code>runid</code> 相同，并且 <code>offset</code> 还在复制积压缓冲区，则进行<code>部分重同步</code>：通过复制积压缓冲区将 <code>slave</code> 缺失的命令发送给 <code>slave</code>，<code>slave</code> 执行命令，将数据库状态更新至 <code>master</code> 所处的状态。</p>\n<p>3）否则，如果 <code>master</code> 判断 <code>runid</code> 不相同，或者 <code>offset</code> 已经不在复制积压缓冲区，则执行完整重同步。</p>\n<h2> 主从复制的演变</h2>\n<p>从 Redis 2.* 到现在，开发人员对主从复制流程进行逐步的优化，以下是演进过程：</p>\n<p>1、2.8 版本之前 <code>Redis</code> 复制采用 <code>SYNC</code> 命令，无论是第一次复制还是断线重连后的复制都采用<code>完整重同步</code>，成本高。</p>\n<p>2、2.8 ~ 4.0 之间复制采用 <code>PSYNC</code> 命令，主要优化了 <code>Redis</code> 在断线重连时候可通过 <code>runid</code> 和 <code>offset</code> 信息使用部分重同步。</p>\n<p>3、4.0 版本之后对 <code>PSYNC</code> 进行了优化，通常称为 <code>PSYNC2</code>，主要优化了 <code>PSYNC</code> 在 <code>slave</code> <code>重启和故障切换</code>时的<code>完整重同步问题</code>。</p>\n",
      "date_modified": "2023-08-03T23:47:30.904Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "redis",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/redis/redis.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/redis/redis.html",
      "summary": "参考 Redis6.2.1安装配置 Redis是如何实现高可用的",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.modb.pro/db/57340\" target=\"_blank\" rel=\"noopener noreferrer\">Redis6.2.1安装配置</a>\n<a href=\"https://juejin.cn/post/6997944007812710414\" target=\"_blank\" rel=\"noopener noreferrer\">Redis是如何实现高可用的</a></p>\n</div>\n<h2> 单机安装</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>默认安装在 /usr/local/bin</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 修改 redis.conf</h2>\n<p>创建工作目录</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 启动 redis-server</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 登录</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 设置 redis 服务</h2>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> redi 高可用</h2>\n<p>高可用是通过设计，减少系统不能提供服务的时间，是分布式系统的基础也是保障系统可靠性的重要手段。而 Redis 作为一款普及率最高的内存型中间件，它的高可用技术也非常的成熟。\nRedis 高可用的手段主要有以下四种：</p>\n<p>数据持久化\n主从数据同步（主从复制）\nRedis 哨兵模式（Sentinel）\nRedis 集群（Cluster）</p>\n<h3> 数据持久化</h3>\n<p>持久化功能是 <code>Redis</code> 和 <code>Memcached</code> 的主要区别之一，因为只有 <code>Redis</code> 提供了此功能。\n在 <code>Redis 4.0</code> 之前数据持久化方式有两种：<code>AOF</code> 方式和 <code>RDB</code> 方式。</p>\n<ul>\n<li>RDB（Redis DataBase，快照方式）是将某一个时刻的内存数据，以二进制的方式写入磁盘。<code>AOF（Append Only File，文件追加方式）</code>是指将所有的操作命令，以文本的形式追加到文件中。\n<code>RDB </code>默认的保存文件为 <code>dump.rdb</code>，优点是以二进制存储的，因此占用的空间更小、数据存储更紧凑，并且<u>与 AOF 相比，RDB 具备更快的重启恢复能力</u>。</li>\n<li>AOF 默认的保存文件为 <code>appendonly.aof</code>，它的优点是<u>存储频率更高，因此丢失数据的风险就越低</u>，并且 AOF 并<u>不是以二进制</u>存储的，所以它的存储信息更易懂。缺点是<u>占用空间大，重启之后的数据恢复速度比较慢</u>。\n可以看出 <code>RDB</code> 和 <code>AOF</code> 各有利弊，<code>RDB</code> 具备更快速的数据重启恢复能力，并且占用更小的磁盘空间，但有数据丢失的风险；而 AOF 文件的可读性更高，但却占用了更大的空间，且重启之后的恢复速度更慢，于是在 <code>Redis 4.0</code> 就推出了混合持久化的功能。</li>\n</ul>\n<p>混合持久化的功能指的是 Redis 可以使用 RDB + AOF 两种格式来进行数据持久化，这样就可以做到扬长避短物尽其用了。\n我们可以使用config get aof-use-rdb-preamble的命令来查询 Redis 混合持久化的功能是否开启，执行示例如下：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果执行结果为<code>“no”</code>则表示混合持久化功能关闭，不过我们可以使用c<code>onfig set aof-use-rdb-preamble yes</code>的命令打开此功能。<code>Redis</code> 混合持久化的存储模式是，开始的数据以 <code>RDB </code>的格式进行存储，因此只会占用少量的空间，并且之后的命令会以 <code>AOF</code> 的方式进行数据追加，这样就可以减低数据丢失的风险，同时可以提高数据恢复的速度。</p>\n<h3> Redis 主从同步</h3>\n<p>主从同步是 <code>Redis</code> 多机运行中最基础的功能，它是把多个 <code>Redis</code> 节点组成一个 <code>Redis</code> 集群，在这个集群当中有一个主节点用来进行数据的操作，其他从节点用于同步主节点的内容，并且提供给客户端进行数据查询。\n<code>Redis 主从同步分为：主从模式和从从模式</code>。</p>\n<p>主从模式就是一个主节点和多个一级从节点,而从从模式是指一级从节点下面还可以拥有更多的从节点。</p>\n<p>主从模式可以提高 <code>Redis</code> 的整体运行速度，因为使用<u>主从模式就可以实现数据的读写分离</u>，把<u>写操作的请求分发到主节点上</u>，把其他的<u>读操作请求分发到从节点上</u>，这样就减轻了 <code>Redis</code> 主节点的运行压力，并且提高了 <code>Redis</code> 的整体运行速度。</p>\n<p>不但如此使用主从模式还实现了 Redis 的高可用，当主服务器宕机之后，可以很迅速的把从节点提升为主节点，为 Redis 服务器的宕机恢复节省了宝贵的时间。</p>\n<p>并且主从复制还降低了数据丢失的风险，因为数据是完整拷贝在多台服务器上的，当一个服务器磁盘坏掉之后，可以从其他服务器拿到完整的备份数据。</p>\n<h3> Redis 哨兵模式</h3>\n<p><code>Redis</code> 主从复制模式有那么多的优点，但是有一个致命的缺点，就是当 <code>Redis</code> 的主节点宕机之后，必须人工介入手动恢复，\n那么到特殊时间段，比如公司组织全体团建或者半夜突然发生主节点宕机的问题，此时如果等待人工去处理就会很慢，\n这个时间是我们不允许的，并且我们还需要招聘专职的人来负责数据恢复的事，同时招聘的人还需要懂得相关的技术才能胜任这份工作。既然如此的麻烦，那有没有简单一点的解决方案，这个时候我们就需要用到 <code>Redis</code> 的哨兵模式了。\n<code>Redis</code> 哨兵模式就是用来监视 <code>Redis</code> 主从服务器的，当 <code>Redis</code> 的主从服务器发生故障之后，<code>Redis</code> 哨兵提供了自动容灾修复的功能.\n<code>Redis</code> 哨兵模块存储在 <code>Redis</code> 的 <code>src/redis-sentinel </code>目录.\n我们可以使用命令<code>./src/redis-sentinel sentinel.conf</code>来启动哨兵功能。\n有了哨兵功能之后，就再也不怕 <code>Redis</code> 主从服务器宕机了。</p>\n<p>哨兵的工作原理是每个哨兵会以每秒钟 1 次的频率，向已知的主服务器和从服务器，发送一个 PING 命令。如果最后一次有效回复 PING 命令的时间，超过了配置的最大下线时间（<code>Down-After-Milliseconds</code>）时，默认是 <code>30s</code>，那么这个实例会被哨兵标记为主观下线。\n如果一个主服务器被标记为主观下线，那么正在监视这个主服务器的所有哨兵节点，要以每秒 1 次的频率确认主服务器是否进入了主观下线的状态。如果有足够数量（<code>quorum</code> 配置值）的哨兵证实该主服务器为主观下线，那么这个主服务器被标记为客观下线。此时所有的哨兵会按照规则（协商）自动选出新的主节点服务器，并自动完成主服务器的自动切换功能，而整个过程都是无须人工干预的。</p>\n<h3> Redis 集群</h3>\n<p><code>Redis </code>集群也就是<code> Redis Cluster</code>，它是<code>Redis 3.0</code>版本推出的<code> Redis</code> 集群方案，将数据分布在不同的主服务器上，以此来降低系统对单主节点的依赖，并且可以大大提高 <code>Redis</code> 服务的读写性能。<code>Redis</code> 集群除了拥有<code>主从模式 + 哨兵模式</code>的所有功能之外，还提供了多个主从节点的集群功能，实现了真正意义上的分布式集群服务.\nRedis 集群可以实现数据分片服务，也就是说在 Redis 集群中有 <code>16384</code> 个槽位用来存储所有的数据，当我们有 <code>N</code> 个主节点时，可以把 <code>16384</code> 个槽位平均分配到 N 台主服务器上。当有键值存储时，<code>Redis</code> 会使用 <code>crc16</code> 算法进行 <code>hash</code> 得到一个整数值，然后用这个整数值对 <code>16384</code> 进行取模来得到具体槽位，再把此键值存储在对应的服务器上，读取操作也是同样的道理，这样我们就实现了数据分片的功能。</p>\n<h3> 总结</h3>\n<p>保障 <code>Redis</code> 高可用的 <code>4</code> 种手段：</p>\n<ul>\n<li>数据持久化保证了数据不丢失；</li>\n<li>Redis 主从让 Redis 从单机变成了多机。它有两种模式：主从模式和从从模式，但当主节点出现问题时，需要人工手动恢复系统；</li>\n<li>Redis 哨兵模式用来监控 Redis 主从模式，并提供了自动容灾恢复的功能。</li>\n<li>Redis 集群，除了可以提供主从和哨兵的功能之外，还提供了多个主从节点的集群功能，这样就可以把数据均匀的存储各个主机主节点上，实现了系统的横向扩展，大大提高了 Redis 的并发处理能力。</li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:30.915Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "sentinel 搭建",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/redis/sentinel.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/redis/sentinel.html",
      "summary": "参考 Redis哨兵集群搭建 Redis6.2.1安装配置 Redis是如何实现高可用的 深入理解Redis高可用方案-Sentinel",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.zhangjava.com/Redis%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/\" target=\"_blank\" rel=\"noopener noreferrer\">Redis哨兵集群搭建</a></p>\n<p><a href=\"https://www.modb.pro/db/57340\" target=\"_blank\" rel=\"noopener noreferrer\">Redis6.2.1安装配置</a></p>\n<p><a href=\"https://juejin.cn/post/6997944007812710414\" target=\"_blank\" rel=\"noopener noreferrer\">Redis是如何实现高可用的</a></p>\n<p><a href=\"https://www.cnblogs.com/ivictor/p/9755065.html\" target=\"_blank\" rel=\"noopener noreferrer\">深入理解Redis高可用方案-Sentinel</a></p>\n</div>\n<h2> sentinel 模式</h2>\n<p>哨兵模式是在主从的基础上</p>\n<h3> 单机安装</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>默认安装在 /usr/local/bin</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 修改 redis.conf</h3>\n<p>创建工作目录</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>主从都配置：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> scp w1 w2</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 配置sentinel.conf</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用vim打开sentinel.conf文件，修改如下配置：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其他两台的sentinel配置与此相同。</p>\n<p>注意：配置logfile 和 dir 后，需要手动创建一下目录</p>\n<h3> 启动 redis-server 和 sentinel</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>安装 哨兵服务</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> sentinel 相关操作</h3>\n<p>输出被监控的主节点的状态信息</p>\n<p><code>sentinel masters</code></p>\n<p>也可单独查看某个主节点的状态</p>\n<p><code>sentinel master mymaster</code></p>\n<p><code>sentinel slaves mymaster </code></p>\n<p>查看某个主节点slave的状态</p>\n<h2> 深入 Sentinel</h2>\n<p>failover的流程如下</p>\n<ol>\n<li>\n<p>每隔1秒，每个<code>Sentinel</code>节点会向主节点、从节点、其余<code>Sentinel</code>节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达。当这些节点超过<code>down-after-milliseconds 默认 30s</code>没有进行有效回复，<code>Sentinel</code>节点就会判定该节点为主观下线。</p>\n</li>\n<li>\n<p>如果被判定为主观下线的节点是<code>主节点</code>，该<code>Sentinel</code>节点会通过<code>sentinel is master-down-by-addr</code>命令向\n其他<code>Sentinel</code>节点询问对主节点的判断，当超过<code>&lt;quorum&gt;(法定人数)</code>个数，<code>Sentinel</code>节点会判定该节点为客观下线。如果从节点、<code>Sentinel</code>节点被判定为主观下线，并不会进行后续的故障切换操作。</p>\n</li>\n<li>\n<p>对<code>Sentinel</code>进行领导者选举，由其来进行后续的故障切换<code>（failover）</code>工作。选举算法基于<code>Raft</code>。</p>\n</li>\n<li>\n<p><code>Sentinel</code>领导者节点开始进行故障切换。</p>\n</li>\n<li>\n<p>选择合适的从节点作为新主节点。</p>\n</li>\n<li>\n<p><code>Sentinel</code>领导者节点对上一步选出来的从节点执行<code>slaveof no one</code>命令让其成为主节点。</p>\n</li>\n<li>\n<p>向剩余的从节点发送命令，让它们成为新主节点的从节点，复制规则和<code>parallel-syncs</code>参数有关。</p>\n</li>\n<li>\n<p>将原来的主节点更新为从节点，并将其纳入到Sentinel的管理，让其恢复后去复制新的主节点。</p>\n</li>\n</ol>\n<h3> Sentinel的领导者选举流程。</h3>\n<p><code>Sentinel</code>的领导者选举基于<code>Raft</code>协议。</p>\n<ol>\n<li>\n<p>每个在线的<code>Sentinel</code>节点都有资格成为领导者，当它确认主节点主观下线时候，会向其他Sentinel节点发送<code>sentinel is-master-down-by-addr</code>命令，要求将自己设置为领导者。</p>\n</li>\n<li>\n<p>收到命令的<code>Sentinel</code>节点，如果没有同意过其他<code>Sentinel</code>节点的<code>sentinel is-master-down-by-addr</code>命令，将同意该请求，否则拒绝。</p>\n</li>\n<li>\n<p>如果该<code>Sentinel</code>节点发现自己的票数已经大于等于<code>max（quorum，num（sentinels）/2+1）</code>，那么它将成为领导者。</p>\n</li>\n</ol>\n<h3> 新主节点的选择流程。</h3>\n<ol>\n<li>\n<p>删除所有已经处于下线或断线状态的从节点。</p>\n</li>\n<li>\n<p>删除最近5秒没有回复过领导者Sentinel的INFO命令的从节点。</p>\n</li>\n<li>\n<p>删除所有与已下线主节点连接断开超过down-after-milliseconds*10毫秒的从节点。</p>\n</li>\n<li>\n<p>选择优先级最高的从节点。</p>\n</li>\n<li>\n<p>选择复制偏移量最大的从节点。</p>\n</li>\n<li>\n<p>选择runid最小的从节点。</p>\n</li>\n</ol>\n",
      "date_modified": "2023-08-03T23:47:30.926Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "正则表达式笔记",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/regex/regex.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/regex/regex.html",
      "summary": "参考 推荐学习 https://deerchao.cn/tutorials/regex/regex.htm https://deerchao.cn/tools/wegester/",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p>推荐学习 <br>\n<a href=\"https://deerchao.cn/tutorials/regex/regex.htm\" target=\"_blank\" rel=\"noopener noreferrer\">https://deerchao.cn/tutorials/regex/regex.htm</a>\n<br>\n<a href=\"https://deerchao.cn/tools/wegester/\" target=\"_blank\" rel=\"noopener noreferrer\">https://deerchao.cn/tools/wegester/</a></p>\n</div>\n<h2> 正则符号</h2>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基础正则</td>\n<td>^ &nbsp;&nbsp;&nbsp;<span class=\"katex-error\" title=\"ParseError: KaTeX parse error: Expected 'EOF', got '&amp;' at position 1: &amp;̲nbsp;&amp;nbsp;&amp;nbs…\" style=\"color:#cc0000\">&amp;nbsp;&amp;nbsp;&amp;nbsp; ^</span> &nbsp;&nbsp;&nbsp;. &nbsp;&nbsp;&nbsp;* &nbsp;&nbsp;&nbsp;.* [a-z] &nbsp;&nbsp;&nbsp;[^abc]</td>\n</tr>\n<tr>\n<td>扩展正则</td>\n<td>+ &nbsp;&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp; () &nbsp;&nbsp;&nbsp; {}  &nbsp;&nbsp;&nbsp; ?</td>\n</tr>\n</tbody>\n</table>\n<h2> 常见的元字符</h2>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\d</td>\n<td>匹配数字</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配字母或数字或下划线或汉字</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任意空白符</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配单词的开头或结束</td>\n</tr>\n</tbody>\n</table>\n<h2> 常见的反义代码</h2>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\W</td>\n<td>匹配任意不是字母，数字，下划线，汉字的字符</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任意不是空白符的字符</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配任意非数字的字符</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配不是单词开头或结束的位置</td>\n</tr>\n<tr>\n<td>[^x]</td>\n<td>匹配除了x以外的任意字符</td>\n</tr>\n<tr>\n<td>[aeiou]</td>\n<td>匹配除了aeiou这几个字母以外的任意字符</td>\n</tr>\n</tbody>\n</table>\n<h2> 正则 VS 通配符</h2>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>诞生目标</th>\n<th>支持的命令</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>正则(RE)</td>\n<td>grep awk sed ,高级语言进行过滤（匹配字符）</td>\n<td>grep awk sed find rename,expr</td>\n</tr>\n<tr>\n<td>通配符（global）</td>\n<td>匹配文件（文件名）*.log *.txt</td>\n<td>linux 大部分命令都支持</td>\n</tr>\n</tbody>\n</table>\n<h3> ^ 以... 开头的行</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> $ 以...结尾的行</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> cat -A</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> ^$ 显示空行</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> . 任意一个字符 不包括空行</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> \\ 转义字符</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> * 前一个字符出现0次或者0次以上</h3>\n<p></p>\n<h3> .* 表示所有  包括空行</h3>\n<p></p>\n<h3> [abc] 一次匹配一个字符</h3>\n<ul>\n<li>[a-z]</li>\n<li>[A-Z]</li>\n<li>[0-9]</li>\n</ul>\n<p></p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container warning\">\n<p class=\"hint-container-title\">[] 内没有特殊字符，相当于\\. 转义</p>\n<p>例如  [a.] 匹配的就是a.</p>\n</div>\n<h3> [^abc] 取反</h3>\n<p>排除 以 a 或者b 或者 c 的内容，匹配a或b或c之外的内容</p>\n<p></p>\n<h2> 例子</h2>\n<h3> 排除空行</h3>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 匹配开始 以 o 结尾 的内容</h3>\n<p></p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">对比 $o</p>\n<p>$ 是以... 结尾的行，\n如果适配内容，不加$</p>\n</div>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">正则的贪婪性</p>\n<p>根据上图可知，匹配到第二个o 才结束</p>\n</div>\n<h2> 扩展正则</h2>\n<h3> + 匹配1次或者一次以上</h3>\n<p></p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">扩展正则的支持</p>\n<p>1️⃣ grep -E <br>\n2️⃣ egrep</p>\n</div>\n<h3> | 或者</h3>\n<p></p>\n<h3> [] VS |</h3>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n<th>应用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[]</td>\n<td>一次匹配一个字符[abcs]</td>\n<td>匹配单个字符 或者和 + 配合</td>\n</tr>\n<tr>\n<td>|</td>\n<td>匹配一个字符或者多个 |a|b|c</td>\n<td>匹配单词</td>\n</tr>\n</tbody>\n</table>\n<h3> （）被括起来的内容，表示一个整体（一个字符），可以应用在后向引用（反向引用）sed 使用</h3>\n<p></p>\n<h3> {} 连续出现  o{n,m} 前一个字母o 至少连续出现n次，最多连续出现m次</h3>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>o{n,m}</td>\n<td>前一个字母o 至少连续出现n次，最多连续出现m次</td>\n</tr>\n<tr>\n<td>o{n}</td>\n<td>前一个字母o 连续出现n次</td>\n</tr>\n</tbody>\n</table>\n<p>0 连续出现4次</p>\n<p></p>\n<p>0 出现一次，最多出现4次</p>\n<p></p>\n<h3> ？ 连续出现0次或者1次</h3>\n<p></p>\n<p></p>\n<h2> 例子</h2>\n<h3> 匹配连续的字母 数字</h3>\n<p></p>\n<h2> 高级 （）分组的使用</h2>\n<p></p>\n<table>\n    <tbody><tr>\n        <th>分类</th><th>代码/语法</th><th>说明\n</th>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">捕获</td><td>(exp)</td><td>匹配exp,并捕获文本到自动命名的组里</td>\n    </tr>\n    <tr>\n        <td>(?&lt;name&gt;exp)</td><td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)</td>\n    </tr>\n    <tr>\n        <td>(?:exp)</td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>\n    </tr>\n    <tr>\n        <td rowspan=\"4\">零宽断言</td><td>(?=exp)</td><td>匹配exp前面的位置</td>\n    </tr>\n    <tr>\n        <td>(?&lt;=exp)</td><td>匹配exp后面的位置</td>\n    </tr>\n    <tr>\n        <td>(?!exp)</td><td>匹配后面跟的不是exp的位置</td>\n    </tr>\n      <tr>\n        <td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td>\n    </tr>\n   <tr>\n       <td>注释</td> <td>(?#comment)</td><td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>\n    </tr>\n</tbody></table>\n<h3> 后向引用</h3>\n<p>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p>\n<p>后向引用用于重复搜索前面某个分组匹配的文本。例如，<code>\\1</code>代表分组1匹配的文本。难以理解？请看示例：</p>\n可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字<code>(\\b(\\w+)\\b)</code>，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符<code>(\\s+)</code>，最后是分组1中捕获的内容（也就是前面匹配的那个单词）<code>(\\1)</code>。<p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：<code>(?&lt;Word&gt;\\w+)</code> <code>( </code> 或者把尖括号换成'也行：<code>(?'Word'\\w+))</code>,这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用<code>\\k&lt;Word&gt;</code>,所以上一个例子也可以写成这样：。</p>\n<h2> 零宽断言</h2>\n<p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言</p>\n<h3> 零宽度正预测先行断言</h3>\n<p><code>(?=exp)</code>，它断言自身出现的位置的后面能匹配表达式exp。比如\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找<code>I'm singing while you're dancing.</code>时，它会匹配 <code>sing</code> 和 <code>sing</code>。</p>\n<h3> 零宽度正回顾后发断言</h3>\n<p><code>(?&lt;=exp)</code>，它断言自身出现的位置的前面能匹配表达式exp。比如<code>(?&lt;=\\bre)\\w+\\b</code>会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找 <code>reading a book</code> 时，它匹配 <code>ading</code>.</p>\n<p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：<code>((?&lt;=\\d)\\d{3})+\\b</code>，用它对1234567890进行查找时结果是234567890。</p>\n<p>下面这个例子同时使用了这两种断言：<code>(?&lt;=\\s)\\d+(?=\\s)</code>匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>\n<h2> 负向零宽断言</h2>\n<p>前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：</p>\n<p><code>\\b\\w*q[^u]\\w*\\b</code>匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[<sup>u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[</sup>u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w*\\b将会匹配下一个单词，于是\\b\\w<em>q[^u]\\w</em>\\b就能匹配整个<code> Iraq fighting</code>。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：<code>\\b\\w*q(?!u)\\w*\\b</code>。</p>\n&gt;，断言此位置的后面不能匹配表达式exp。例如：<code>\\d{3}(?!\\d)</code>匹配三位数字，而且这三位数字的后面不能是数字；<code>\\b((?!abc)\\w)+\\b</code>匹配不包含连续字符串abc的单词。<p>同理，我们可以用来断言此位置的前面不能匹配表达式exp：<code>(?&lt;![a-z])\\d{7}</code>匹配前面不是小写字母的七位数字。</p>\n<p>一个更复杂的例子：<code>(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;)</code>匹配不包含属性的简单HTML标签内里的内容。<code>(?&lt;=&lt;(\\w+)&gt;)</code>指定了这样的前缀：被尖括号括起来的单词(比如可能是<code>&lt;b&gt;</code>)，然后是.*(任意的字符串),最后是一个后缀<code>(?=&lt;\\/\\1&gt;)</code>。注意后缀里的/，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的(\\w+)匹配的内容，这样如果前缀实际上是<code>&lt;b&gt;</code>的话，后缀就是<code>&lt;/b&gt;</code>了。整个表达式匹配的是<code>&lt;b&gt;</code>和<code>&lt;/b&gt;</code>之间的内容(再次提醒，不包括前缀和后缀本身)。</p>\n<h2> 注释</h2>\n<p>小括号的另一种用途是通过语法来包含注释。例如：<code>2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)</code>。</p>\n<p>要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略</p>\n<h2> 贪婪与懒惰</h2>\n<table>\n<thead>\n<tr>\n<th>代码/语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*?</td>\n<td>重复任意次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>+?</td>\n<td>重复1次或更多次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>??</td>\n<td>重复0次或1次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,m}?</td>\n<td>重复n到m次，但尽可能少重复</td>\n</tr>\n<tr>\n<td>{n,}?</td>\n<td>重复n次以上，但尽可能少重复</td>\n</tr>\n</tbody>\n</table>\n<p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索 <code>aabab</code> 的话，它会匹配整个字符串 <code>aabab</code> 。这被称为贪婪匹配。</p>\n<p>有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p>\n<p><code>a.*?b</code> 匹配最短的，以a开始，以b结束的字符串。如果把它应用于 <code>aabab</code> 的话，它会匹配 <code>aab</code>（第一到第三个字符）和 <code>ab</code>（第四到第五个字符）。</p>\n<h2> 还有些什么东西没提到</h2>\n<p></p>\n",
      "date_modified": "2023-08-03T23:47:30.965Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "spring",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/spring/spring.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/spring/spring.html",
      "summary": "参考",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n</div>\n",
      "date_modified": "2023-08-03T23:47:30.966Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "spring常用总结",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/spring/spring%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/spring/spring%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93.html",
      "summary": "参考 源码 spring webmvc HandlerInterceptor org.springframework.web.servlet.HandlerInterceptor",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://github.com/lojzes/spring-family\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a></p>\n</div>\n<h2> spring</h2>\n<h2> webmvc</h2>\n<h3> HandlerInterceptor</h3>\n<p><code>org.springframework.web.servlet.HandlerInterceptor</code></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> HandlerMethodArgumentResolver</h3>\n<p><code>org.springframework.web.method.support.HandlerMethodArgumentResolver</code></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 案例总结：</h3>\n<p>1、</p>\n<p>可以实现 统一获取当前用户信息的公共方法， 在 controller 中添加相应的自定义注解和用户信息DTO，在 handler 中在 header 中获取</p>\n<p>用户唯一标识，进行用户信息转换，放入request 中，在 HandlerMethodArgumentResolver 中 把用户新转换为用户dto</p>\n<p><a href=\"https://github.com/lojzes/spring-family/blob/master/spring-boot/src/main/java/com/lojzes/spring/famliy/springboot/resolve/CurrentUserMethodArgumentResolver.java\" target=\"_blank\" rel=\"noopener noreferrer\">CurrentUserMethodArgumentResolver</a></p>\n<p>2、对请求的参数进行非法字符进行校验，如数据库相关敏感字符校验</p>\n<p><a href=\"https://github.com/lojzes/workmanagement/blob/master/wanhuayun-common/wanhuayun-common-data/src/main/java/com/wanhuayun/framework/common/data/resolver/SqlFilterArgumentResolver.java\" target=\"_blank\" rel=\"noopener noreferrer\">SqlFilterArgumentResolver</a></p>\n",
      "date_modified": "2023-08-03T23:47:30.970Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "注解",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/spring/%E6%B3%A8%E8%A7%A3.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/spring/%E6%B3%A8%E8%A7%A3.html",
      "summary": "参考 Spring 注解（一）Spring 注解编程模型",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.cnblogs.com/binarylei/p/10415539.html\" target=\"_blank\" rel=\"noopener noreferrer\">Spring 注解（一）Spring 注解编程模型</a></p>\n</div>\n",
      "date_modified": "2023-08-03T23:47:30.971Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "web类型推断",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springboot/web%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springboot/web%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD.html",
      "summary": "参考 https://ost.51cto.com/posts/20652 WebApplicationType 官方的介绍 ​​SpringBoot​​​ 的 ​​web​​​ 类型有三种，分别是，​​NONE​​​、​​SERVLET​​​ 和 ​​REACTIVE​​​，定义在枚举 ​​WebApplicationType​​ 中，这三种类型分别代表了三种含义：",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://ost.51cto.com/posts/20652\" target=\"_blank\" rel=\"noopener noreferrer\">https://ost.51cto.com/posts/20652</a></p>\n</div>\n<h2> WebApplicationType</h2>\n<p>官方的介绍 <code>​​SpringBoot​​​</code> 的 ​<code>​web</code>​​​ 类型有三种，分别是，<code>​​NONE​​​、​​SERVLET​​​ 和 ​​REACTIVE​​</code>​，定义在枚举 ​​WebApplicationType​​ 中，这三种类型分别代表了三种含义：</p>\n\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 类型推断原理</h2>\n<p>在构造函数中我们可以看到其中有这么一行 ​<code>​this.webApplicationType = WebApplicationType.deduceFromClasspath();​​</code>​根据属性名称我们可以推断，<code>​​web​​</code>​ 类型就是根据 ​<code>​WebApplicationType.deduceFromClasspath();​</code>​ 这个静态方法来判断的。接下来我们看下这个方法的细节。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>WebApplicationType</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到 <code>​​SpringBoot​​​</code> 底层是通过 <code>​​ClassUtils.isPresent()​​</code>​ 方法来判断对应的 <code>​​web​​​</code> 类型类是否存在来判断 <code>​​web​​</code> 类型的。</p>\n<p>在前类路径下面如果当 ​<code>​org.springframework.web.reactive.DispatcherHandler​​</code>​ 存在而且 ​<code>​org.springframework.web.servlet.DispatcherServlet</code>​​​ 和 ​<code>​org.glassfish.jersey.servlet.ServletContainer​​</code>​ 都不存在的时候说明当前应用 <code>​​web​​</code>​ 类型为 <code>​​Reactive​​。</code></p>\n<p>当 ​<code>​javax.servlet.Servlet</code>​​​ 和 ​<code>​org.springframework.web.context.ConfigurableWebApplicationContext​​</code>​ 任何一个不存在的时候，就说明当前应用是 <code>​​None​​​</code> 类型非 <code>​​web​​​</code> 应用。否则当前应用就为 ​​Servlet​​ 类型。</p>\n<p>而我们再看这个 <code>​​ClassUtils.isPresent()</code>​​​ 方法，可以发现底层是通过 <code>​​className​​​</code> 在类路径上加载对应的类，如果存在则返回 <code>​​true​​</code>​，如果不存在则返回 <code>​​false​​。</code></p>\n<h2> ClassUtils</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>因此这也解释了为什么我们在 <code>​​pom​​​</code> 文件中只要加入对应的依赖就可以直接得到相应的 <code>​​web​​​</code> 类型了，因为当我们在 <code>​​pom​​​</code> 中加入相应的依赖过后，类路径里面就存在了前面判断的对应的类，再通过 <code>​​ClassUtils.isPresent()</code>​​​ 就判断出来当前应用属于那种 <code>​​web​​</code> 类型了。</p>\n",
      "date_modified": "2023-08-03T23:47:30.980Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "外部化配置",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springboot/%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springboot/%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE.html",
      "summary": "参考 https://www.cnblogs.com/summerday152/p/13954046.html SpringBoot约定大于配置到底是什么意思？",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.cnblogs.com/summerday152/p/13954046.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/summerday152/p/13954046.html</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1475163\" target=\"_blank\" rel=\"noopener noreferrer\">SpringBoot约定大于配置到底是什么意思？</a></p>\n</div>\n<h2> SpringBoot约定大于配置到底是什么意思？</h2>\n<p><code>Spring Boot</code> 是由 <code>Pivotal</code> 团队提供的全新框架，其设计目的是用来简化新 <code>Spring</code> 应用的初始搭建以及开发过程。\n该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。<code>spring Boot</code>采用约定大约配置的方式，\n大量的减少了配置文件的使用。</p>\n<p><code>约定优于配置（convention over configuration）</code>，也称作<code>按约定编程</code>，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，\n获得简单的好处，而又不失灵活性。</p>\n<p>在<code>SpringBoot</code>中，约定大于配置可以从以下两个方面来理解：</p>\n<ul>\n<li>开发人员仅需规定应用中不符合约定的部分</li>\n<li>在没有规定配置的地方，采用默认配置，以力求最简配置为核心思想</li>\n</ul>\n<p>总的来说，上面两条都遵循了<code>推荐默认配置</code>的思想。当存在特殊需求的时候，自定义配置即可。这样可以大大的减少配置工作，这就是所谓的“约定”。</p>\n<p>那么SpringBoot中有哪些约定呢？</p>\n<ul>\n<li>Maven的目录结构。默认有resources文件夹,存放资源配置文件。<code>src-main-resources,src-main-java</code>。默认的编译生成的类都在<code>target</code>文件夹下面</li>\n<li><code>spring boot</code>默认的配置文件必须是，也只能是<code>application.命名的yml文件</code>或者<code>properties</code>文件，且唯一\n<code>application.yml</code>中默认属性。</li>\n<li>数据库连接信息必须是以<code>spring: datasource:</code> 为前缀；多环境配置。该属性可以根据运行环境自动读取不同的配置文件；端口号、请求路径等</li>\n</ul>\n<h2> SpringBoot官方文档对于外部化配置的介绍及作用顺序</h2>\n<p><code>SpringBoot</code>支持多种外部化配置，以便于开发者能够在不同的环境下，使用同一套应用程序代码。外部化配置的方式有多种：<code>properties</code>文件，<code>yaml</code>文件，<code>Environment</code>变量已经命令行参数等等。</p>\n<p>外部化配置的属性值可以通过<code>@Value</code>注解自动注入，亦可以通过<code>Spring</code>的<code>Environment</code>抽象访问，也可以通过<code>@ConfigurationProperties</code>注解绑定到结构化对象上。</p>\n<p>SpringBoot支持很多种的外部化配置，待会我们会介绍到。在这之前，我们必须要知道如果多种配置同时出现，一定是按照特定的顺序生效的。规则如下：</p>\n\n<p>这里列表按组优先级排序，也就是说，任何在高优先级属性源里设置的属性都会覆盖低优先级的相同属性，列如我们上面提到的命令行属性就覆盖了<code>application.properties</code>的属性。</p>\n<p>如果在<code>application.properties</code>中设置name=天乔巴夏，此时我用命令行设置java -jar hyh.jar --author.name=summerday，最终的name值将会是summerday，因为命令行属性优先级更高。</p>\n<h2> 各种外部化配置举例</h2>\n<p>随机值配置</p>\n<p>配置文件中${random} 可以用来生成各种不同类型的随机值，从而简化了代码生成的麻烦，例如 生成 int 值、long 值或者 string 字符串。原理在于，RandomValuePropertySource类重写了getProperty方法，判断以random.为前缀之后，进行了适当的处理。</p>\n<div class=\"language-properties line-numbers-mode\" data-ext=\"properties\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 命令行参数配置</h2>\n<p>默认情况下，<code>SpringApplication</code> 将所有的命令行选项参数<code>【以--开头的参数，如--server.port=9000】</code>转换为属性，并将它们加入 <code>SpringEnvironment</code> 中，命令行属性的配置始终优先于其他的属性配置。</p>\n<p>如果你不希望将命令行属性添加到 <code>Environment</code> 中，可以使用<code>SpringApplication.setAddCommandLineProperties(false)</code>禁用它。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> 属性文件配置</h2>\n<p>属性文件配置这一部分是我们比较熟悉的了，我们在快速创建SpringBoot项目的时候，默认会在resources目录下生成一个application.properties文件。SpringApplication都会从配置文件加载配置的属性，并最终加入到Spring的Environment中。除了resources目录下，还有其他路径，SpringBoot默认是支持存放配置文件的。</p>\n\n<p>以上四个，优先级从上往下依次降低，也就是说，如果同时出现，上面配置的属性将会覆盖下面的。</p>\n<p>当然，这些配置都是灵活的，如果你不喜欢默认的配置文件命名或者默认的路径，你都可以进行配置：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 指定profile属性</h2>\n<p>通常情况下，我们开发的应用程序需要部署到不同的环境下，属性的配置自然也需要不同。如果每次在发布的时候替换配置文件，过于麻烦。<code>SpringBoot</code>的多环境配置为此提供了便利。具体做法如下：</p>\n<p>我们之前在介绍各种配置的优先级的时候说过，<code>application-{profile}.properties</code>或者<code>application-{profile}.yml</code>文件的优先级高于<code>application.properties</code>或<code>application.yml</code>配置，这里的 <code>profile</code> 就是我们定义的环境标识：</p>\n<p>我们在resource目录下创建三个文件：</p>\n\n<p>我们可以通过指定spring.profiles.active属性来激活对应的配置环境：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>如果没有profile指定的文件于profile指定的文件的配置属性同时定义，那么指定profile的配置优先。</p>\n<h2> 使用占位符</h2>\n<p>在使用application.properties中的值的时候，他们会从Environment中获取值，那就意味着，可以引用之前定义过的值，比如引用系统属性。具体做法如下：</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 加密属性</h2>\n<p>Spring Boot不提供对加密属性值的任何内置支持，但是，它提供了修改Spring环境中的值所必需的挂钩点。我们可以通过实现EnvironmentPostProcessor接口在应用程序启动之前操纵Environment。</p>\n<p>可以参考<a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.application.customize-the-environment-or-application-context\" target=\"_blank\" rel=\"noopener noreferrer\">howto.html</a>，查看具体使用方法。</p>\n<h2> 使用YAML代替properties</h2>\n<p>只要在类路径上具有SnakeYAML库，SpringApplication类就会自动支持YAML作为属性配置的方式。SpringBoot项目中的spring-boot-starter已经提供了相关类库：org.yaml.snakeyaml，因此SpringBoot天然支持这种方式配置。</p>\n<h2> 类型安全的属性配置</h2>\n<p>上面说到通过@Value(\"${property}\") 注解来注入配置有时会比较麻烦，特别是当多个属性本质上具有层次结构的时候。SpringBoot提供了一种解决方案：让强类型的bean管理和验证你的配置。</p>\n<p>直接来看具体的使用叭：\n@ConfigurationPropertie定义一个绑定配置的JavaBean</p>\n\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>\n<h2> 通过@ContructorBinding注解使用构造器绑定的方式：</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果没有配置Security实例属性，那么最后结果：Security=null。如果我们想让Security={username=null,password=null,roles=[USER]}，可以在Security上加上@DefaultValue。public AcmeProperties(boolean enabled, InetAddress remoteAddress, @DefaultValue Security security)</p>\n<p>通过<code>@EnableConfigurationProperties</code>注册</p>\n<p>已经定义好了JavaBean，并与配置属性绑定完成，接着需要注册这些bean。我们通常用的<code>@Component或@Bean</code>，<code>@Import</code>加载<code>bean</code>的方式在这里是不可取的，SpringBoot提供了解决方案：使用<code>@EnableConfigurationProperties</code>，我们既可以一一指定配置的类，也可以按照组件扫描的方式进行配置。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>宽松绑定</p>\n<p>SpringBoot采用宽松的规则进行Environment和@ConfigurationProperties标注bean的匹配。如：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面表格中的属性名都可以匹配：</p>\n<p></p>\n<p>@ConfigurationProperties注解中的prefix值必须是kebab case形式的，以-为分割符。</p>\n<p>Spring官方建议，属性尽可能以lower-case kebab的形式：my.property-name=acme</p>\n<h2> Map如何绑定</h2>\n<p>绑定到Map属性时，如果key包含小写字母数字字符或-以外的任何其他字符，则需要使用方括号包围key，以便保留原始值。 如果键没有被[]包围，则所有非字母数字或-的字符都将被删除。如下：</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 环境变量如何绑定</h2>\n<p>遵循三条原则：</p>\n\n<p>如：spring.main.log-startup-info转为：SPRING_MAIN_LOGSTARTUPINFO，my.acme[0].other转为MY_ACME_0_OTHER。</p>\n<h2> 复杂类型</h2>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-properties line-numbers-mode\" data-ext=\"properties\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参数校验</h2>\n<p>对<code>@ConfigurationProperties</code>类使用Spring的@Valid注解时，Spring Boot就会尝试对其进行验证。</p>\n<p>你可以直接在配置类上使用<code>JSR-303 javax.validation</code>约束注解。这个做法的前提是，你的类路径上有兼容的<code>JSR-303</code>实现：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-log line-numbers-mode\" data-ext=\"log\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> @ConfigurationProperties与@Value的区别</h2>\n<p><code>@Value</code>注解是一个核心容器功能，它没有提供和type-safe配置属性相关的功能，下面这个表格总结了两者分别支持的功能：</p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>@ConfigurationProperties</th>\n<th>@Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>宽松绑定</td>\n<td>Yes</td>\n<td>Limited (see note below)</td>\n</tr>\n<tr>\n<td>元数据支持</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>SpEL 表达式</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n</tbody>\n</table>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">建议</p>\n<p>官方建议：\n如果你为自己的组件定义了一套配置，建议使用@ConfigurationProperties和POJO绑定，这样做能够提供结构化且类型安全的对象。\n如果硬要使用@Value，建议使用kebab-case形式，如@Value(\" ${demo.item-price}\")</p>\n</div>\n",
      "date_modified": "2023-08-03T23:47:31.004Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "多数据源",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springboot/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springboot/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90.html",
      "summary": "参考 源码 SpringBoot+MyBatis+MySQL读写分离 Spring Boot 整合 Mybatis 实现 Druid 多数据源",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://github.com/lojzes/middle-study/tree/master/mysql-rw\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a></p>\n<p><a href=\"https://www.cnblogs.com/cjsblog/p/9712457.html\" target=\"_blank\" rel=\"noopener noreferrer\">SpringBoot+MyBatis+MySQL读写分离</a></p>\n<p><a href=\"https://netfilx.github.io/spring-boot/5.mybatis%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90/muilt-data-source\" target=\"_blank\" rel=\"noopener noreferrer\">Spring Boot 整合 Mybatis 实现 Druid 多数据源</a></p>\n</div>\n<h2> 引言</h2>\n<p>读写分离要做的事情就是对于一条SQL该选择哪个数据库去执行，至于谁来做选择数据库这件事儿，无非两个，要么中间件帮我们做，要么程序自己做。因此，一般来讲，读写分离有两种实现方式。第一种是依靠中间件（比如：MyCat），也就是说应用程序连接到中间件，中间件帮我们做SQL分离；第二种是应用程序自己去做分离。这里我们选择程序自己来做，主要是利用Spring提供的路由数据源，以及AOP</p>\n<p>然而，应用程序层面去做读写分离最大的弱点（不足之处）在于无法动态增加数据库节点，因为数据源配置都是写在配置中的，新增数据库意味着新加一个数据源，必然改配置，并重启应用。当然，好处就是相对简单。</p>\n<p></p>\n<h2> AbstractRoutingDataSource</h2>\n<p>基于特定的查找key路由到特定的数据源。它内部维护了一组目标数据源，并且做了路由key与目标数据源之间的映射，提供基于key查找数据源的方法。</p>\n<p></p>\n<h2> 相关配置</h2>\n<h3> DataSourceConfig</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> DataSourceAop</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>MyRoutingDataSource</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:31.030Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "微服务拆分原则",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springboot/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springboot/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99.html",
      "summary": "参考 微服务拆分规范 微服务拆分原则 高内聚、低耦合 紧密关联的事物应该放在一起，每个服务是针对一个单一职责的业务能力的封装，专注做好一件事情（每次只有一个更改它的理由)",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/333393446\" target=\"_blank\" rel=\"noopener noreferrer\">微服务拆分规范</a></p>\n</div>\n<h2> 微服务拆分原则</h2>\n<h3> 高内聚、低耦合</h3>\n<p>紧密关联的事物应该放在一起，每个服务是针对一个<code>单一职责</code>的业务能力的封装，专注做好一件事情（每次只有一个更改它的理由)</p>\n<p>通用拆分方式：</p>\n<p>先按业务领域拆，如 社区、用户、商城、慢病、工单，如果有相同功能需要聚合，则进行下沉（垂直）。再按功能定位拆（水平），如商城业务复杂度提高之后可进一步拆分为商品、订单、物流、支付。按重要程度拆，区分核心与非核心，如订单核心，订单非核心。</p>\n<h3> 服务拆分正交性原则</h3>\n<p>两条直线相交成直角，就是正交的。正交也就是两条直线互不依赖。<u>如果一个系统的变化不影响另一个系统这些系统就是正交的</u>。</p>\n<p>直接应用正交性原则，构建的系统的质量可以得到很大提高，可以让你的系统<u>易于设计、开发、测试及扩展上线。提高开发效率，降低风险。</u></p>\n<h3> 服务拆分层级最多三层</h3>\n<p>服务拆分是为了<code>横向扩展</code>，因而应该<code>横向拆分</code>，而非纵向拆成一串的。也即应该将商品和订单拆分，而非下单的十个步骤拆分，然后一个调用一个。</p>\n<p>人们经常问的一个问题是，服务拆分之后，原来都在一个进程里面的函数调用，现在变成了A调用B调用C调用D调用E，会不会因为调用链路过长而使得相应变慢呢？这里纵向的拆分最多三层，大部分情况下只有两次调用</p>\n<h3> 服务粒度适中、演进式拆分</h3>\n<p>微服务拆分并不是一步到位的，应当根据实际情况逐步展开。如果一开始不知道应该划分多细，完全可以先粗粒度划分，然后随着需要，初步拆分</p>\n<h3> 避免环形依赖、双向依赖</h3>\n<p>服务之间的<code>环形/双向依赖</code>会使得服务间耦合加重，在服务升级的的时候会比较头疼，不知道应该先升级哪个，后升级哪个，难以维护。因此我们需要极力避免服务间的这种复杂依赖关系。</p>\n<h3> 通用化接口设计，减少定制化设计</h3>\n<p>提微服务提供的服务一定是尽可能通用的，面向功能来开发的，而不是面向调用方来开发的。比如某个调用方提出了一个需求：调用方B希望A服务提供一个获取订单列表的接口，那么A服务设计的接口就应该是GetOrderList()，而不是GetOrderListForA()</p>\n<h3> 避免服务间共享数据库</h3>\n<p>数据库包括任意的数据存储服务，例如：<code>MySQL、Redis、MongoDB</code>等。如果服务间共享数据库，会造成：</p>\n<p>强耦合：为多个服务提供单个数据库会造成服务间紧密耦合，也会造成服务独立部署困难。扩展性差：使用这种设计很难扩展单个服务，因为这样只能选择扩展整个单个数据库。性能问题：使用一个共享数据库（不是数据库服务器），在一段时间内，你可能最终会得到一个巨大的表。</p>\n<p>因此，对于现有共享庞大数据库的微服务，建议是按照业务维度拆分成多个小的数据库，分开独立维护。此外，再次提醒，禁止跨库联表查询。</p>\n<h3> 同时应当考虑团队结构</h3>\n<p>前面讲的都是技术因素的划分原则，其实微服务拆分时也应当考虑团队组织结构。</p>\n<p>团队足够轻量级，2 pizza原则，保证团队内部能够高效沟通。团队的职责足够明确，保证能够独立维护，减少团队间工作耦合度，降低跨团队协作成本。</p>\n<h2> 微服务拆分时机</h2>\n<p>微服务拆分绝非一个大跃进运动，由高层发起，把一个应用拆分的七零八落的，最终大大增加运维成本，但是并不会带来收益。微服务拆分的过程，应该是一个由痛点驱动的，是业务真正遇到了快速迭代和高并发的问题，如果不拆分，将对于业务的发展带来影响，只有这个时候，微服务的拆分是有确定收益的，增加的运维成本才是值得的。</p>\n<h3> 快速迭代</h3>\n<p>使用微服务架构的目的就是为了快速迭代，快速上线，这也是微服务架构的最大特点。</p>\n<h3> 高并发、性能要求</h3>\n<p>对于微服务化拆分后的服务，可以轻松地进行水平扩容，进行服务优化，满足更多的并发和性能需求。</p>\n<p>在高并发场景下（或者资源紧张的场景下），我们希望一个请求如果不成功，不要占用资源，应该尽快失败，尽快返回，而且希望当一些边角的业务不正常的情况下，主要业务流程不受影响。这就需要熔断策略，也即当A调用B，而B总是不正常的时候，为了让B不要波及到A，可以对B的调用进行熔断，也即A不调用B，而是返回暂时的fallback数据，当B正常的时候，再放开熔断，进行正常的调用。</p>\n<p>如果核心业务流程和普通业务流程在同一个服务中，就需要使用大量的if-else语句，根据下发的配置来判断是否熔断或者降级，这会使得配置异常复杂，难以维护。如果核心业务和普通业务分成两个服务，就可以使用标准的熔断降级策略，配置在某种情况下，放弃对另一个服务的调用，可以进行统一的维护。</p>\n<h3> 提交代码频繁出现大量冲突</h3>\n<p>微服务对于快速迭代的效果，首先是开发独立，如果是一单体应用，几十号人开发一个模块，如果使用GIT做代码管理，则经常会遇到的事情就是代码提交冲突。同样一个模块，你也改，他也改，几十号人根本没办法沟通。所以当你想提交一个代码的时候，发现和别人提交的冲突了，于是因为你是后提交的人，你有责任去merge代码，好不容易merge成功了，等再次提交的时候，发现又冲突了，你是不是很恼火。随着团队规模越大，冲突概率越大。</p>\n<p>所以应该拆分成不同的模块，每十个人左右维护一个模块，也即一个工程，首先代码冲突的概率小多了，而且有了冲突，一个小组一吼，基本上问题就解决了。每个模块对外提供接口，其他依赖模块可以不用关注具体的实现细节，只需要保证接口正确就可以。</p>\n<h3> 小功能要积累到大版本才能上线</h3>\n<p>微服务对于快速迭代的效果，首先是上线独立。如果没有拆分微服务，每次上线都是一件很痛苦的事情。当你修改了一个边角的小功能，但是你不敢马上上线，因为你依赖的其他模块才开发了一半，你要等他，等他好了，也不敢马上上线，因为另一个被依赖的模块也开发了一半，当所有的模块都耦合在一起，互相依赖，谁也没办法独立上线，而是需要协调各个团队，大家开大会，约定一个时间点，无论大小功能，死活都要这天上线。</p>\n<p>这种模式导致上线的时候，单次上线的需求列表非常长，这样风险比较大，可能小功能的错误会导致大功能的上线不正常，将如此长的功能，需要一点点check，非常小心，这样上线时间长，影响范围大。</p>\n<p>服务拆分后，在团队职责明确、应用边界明确、接口稳定的情况下，不同的模块可以独立上线。这样上线的次数增多，单次上线的需求列表变小，可以随时回滚，风险变小，时间变短，影响面小，从而迭代速度加快。对于接口要升级部分，保证灰度，先做接口新增，而非原接口变更，当注册中心中监控到的调用情况，发现接口已经不用了，再删除。</p>\n",
      "date_modified": "2023-08-03T23:47:31.032Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "注入bean的方式",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springboot/%E6%B3%A8%E5%85%A5bean%E7%9A%84%E6%96%B9%E5%BC%8F.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springboot/%E6%B3%A8%E5%85%A5bean%E7%9A%84%E6%96%B9%E5%BC%8F.html",
      "summary": "参考 【SpringBoot】浅谈向容器注入Bean有几种方式 @Component + @ComponentScan SpringBoot启动类的@SpringBootApplication注解中就标注了 @ComponentScan注解，这个注解默认扫描当前包及其子包下的标注有@Component、@Controller、@Service、@Repository等的类加载到容器中。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://developer.aliyun.com/article/1040654\" target=\"_blank\" rel=\"noopener noreferrer\">【SpringBoot】浅谈向容器注入Bean有几种方式</a></p>\n</div>\n<h2> @Component + @ComponentScan</h2>\n<p><code>SpringBoot</code>启动类的<code>@SpringBootApplication</code>注解中就标注了 <code>@ComponentScan</code>注解，这个注解默认扫描当前包及其子包下的标注有<code>@Component、@Controller、@Service、@Repository</code>等的类加载到容器中。</p>\n<h2> @Import注解</h2>\n<p>了解过<code>SpringBoot</code>源码的掘友应该对这个注解不陌生，<code>SpringBoot</code>之所以拥有自动装配能力，全依仗于启动类<code>@SpringBootApplication</code>注解中的另一个核心注解<code>@EnableAutoConfiguration</code>。\n点进去这个注解会发现 <code>@Import(AutoConfigurationImportSelector.class)</code>,也就是通过将<code>AutoConfigurationImportSelector</code>类加载到容器中。\n并通过此类的<code>getAutoConfigurationEntry()</code>方法，查找并筛选出位于<code>META-INF/spring.factories</code>文件中的所有需要注入的自动配置类并加载。\n这个注解也可以直接注入<code>class</code>，<code>SpringBoot</code>默认是注入<code>ImportSelector</code>接口，重写<code>selectImports</code>规则实现，本质上都是将外部类加载到当前<code>classpath</code>中并注入成<code>bean</code>。</p>\n<p><code>@Import</code> 支持 <code>Configuration</code>、<code>ImportSelector</code>、<code>ImportBeanDefinitionRegistrar</code>、 <code>component classes</code></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> @Configuration + @Bean</h2>\n<p>这个组合相信大家都有用过，比如想利用<code>ioc</code>容器管理一个<code>map</code>容器，只需要在配置类上标注上<code>@Configuration</code>声明配置类，在某个方法上标注<code>@Bean</code>并返回一个<code>new </code>即可。</p>\n<h2> BeanDefinitionRegistryPostProcessor</h2>\n<p>万变不离其宗，掌握<code>SpringBoot</code>启动流程和<code>SpringBean</code>的生命周期，很多问题就能连点成线的串起来。\n我们知道<code>SpringBean</code>的生命周期中有很多前后置方法，整体上可以概括为普通类对象转化为<code>beanDefinition</code>再转化为<code>spring</code>中的<code>bean</code>这么三个阶段。\n而<code>Spring</code>会在启动的<code>AbstratApplicationContxt</code>类中的<code>refresh</code>方法中执行\n<code>invokeBeanFactoryPostProcessors</code>，这个方法中会回调所有实现\n<code>BeanDefinitionRegistryPostProcessor</code>接口的钩子方法。\n可以简单理解成<code>beanDefinition</code>加载完毕之后，会对<code>beanDefinition</code>进行后置处理。所以理论上实现<code>BeanDefinitionRegistryPostProcessor</code>接口就可以手动将<code>bean</code>注入到容器中。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 总结</h2>\n<ul>\n<li>按照SpringBoot启动原理和SpringBean的生命周期为思路</li>\n<li>@Component + @ComponentScan</li>\n<li>@Bean + @Configuration</li>\n<li>@Import</li>\n<li>BeanDefinitionRegistryPostProcessor接口实现postProcessBeanDefinitionRegistry后置函数</li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:31.035Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "自动装配",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springboot/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springboot/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.html",
      "summary": "参考 SpringBoot 自动装配原理 SpringBoot的starter到底是什么？",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://juejin.cn/post/7162568709955911717\" target=\"_blank\" rel=\"noopener noreferrer\"> SpringBoot 自动装配原理 </a></p>\n<p><a href=\"https://juejin.cn/post/7149896017574363166\" target=\"_blank\" rel=\"noopener noreferrer\">SpringBoot的starter到底是什么？ </a></p>\n</div>\n<blockquote>\n<p>早期的Spring项目需要添加需要配置繁琐的xml,比如MVC、事务、数据库连接等繁琐的配置。Spring Boot的出现就无需这些繁琐的配置，因为Spring Boot基于约定大于配置的理念，在项目启动时候，将约定的配置类自动配置到IOC容器里。这些都因为Spring Boot有自动配置的特性。</p>\n</blockquote>\n<p>自动配置主要由 <code>@EnableAutoConfiguration</code> 实现，添加了 <code>@EnableAutoConfiguration</code> 注解，\n会导入 <code>AutoConfigurationImportSelector</code> 类，里面的 <code>selectImports</code> 方法通过 <code>SpringFactoriesLoader.loadFactoryNames()</code>\n扫描所有含有 <code>META-INF/spring.factories</code> 的 <code>jar</code> 包,将对应 <code>key</code> 为 <code>@EnableAutoConfiguration</code> 注解全名对应的\n<code>value</code> 类全部装配到 <code>IOC</code> 容器中。</p>\n<h2> 总结</h2>\n<p>Spring Boot自动配置原理</p>\n<p>1、<code>@SpringBootApplication</code> 的 <code>@EnableAutoConfiguration</code>注解导入<code>AutoConfigurationImportSelector</code>类。</p>\n<p>2、执行<code>selectImports</code>方法调用<code>SpringFactoriesLoader.loadFactoryNames()</code>扫描</p>\n<p>所有<code>jar</code>下面的对应的<code>META-INF/spring.factories</code>文件.</p>\n<p>3、限定为<code>@EnableAutoConfiguration</code>对应的<code>value</code>，将这些装配条件的装配到IOC容器中。</p>\n<p>自动装配简单来说就是自动将第三方的组件的bean装载到IOC容器内，不需要再去写bean相关的配置，符合约定大于配置理念。</p>\n<p><code>Spring Boot</code>基于约定大于配置的理念，配置如果没有额外的配置的话，就给按照默认的配置使用约定的默认值，</p>\n<p>按照约定配置到<code>IOC</code>容器中，无需开发人员手动添加配置，加快开发效率。</p>\n<h2> 常用注解</h2>\n<p><code>@ConditionalOnBean</code>：当SpringIoc容器内存在指定Bean的条件</p>\n<p><code>@ConditionalOnSingleCandidate</code>：当指定Bean在SpringIoc容器内只有一个，或者虽然有多个但是指定首选的Bean</p>\n<p><code>@ConditionalOnMissingBean</code>：当SpringIoc容器内不存在指定Bean的条件</p>\n<p><code>@ConditionalOnClass</code>：当SpringIoc容器内存在指定Class的条件</p>\n<p><code>@ConditionalOnMissingClass</code>：当SpringIoc容器内不存在指定Class的条件</p>\n<p><code>@ConditionalOnExpression</code>：基于SpEL表达式作为判断条件</p>\n<p><code>@ConditionalOnJava</code>：基于JVM版本作为判断条件</p>\n<p><code>@ConditionalOnJndi</code>：在JNDI存在时查找指定的位置</p>\n<p><code>@ConditionalOnResource</code>：类路径是否有指定的值</p>\n<p><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>@ConditionalOnNotWebApplication</code>：当前项目不是Web项目的条件</p>\n<p><code>@ConditionalOnWebApplication</code>：当前项目是Web项目的条件</p>\n<p><code>@AutoConfigureBefore</code></p>\n<p><code>@AutoConfigureAfter</code></p>\n<p><code>@AutoConfigureOrder</code></p>\n<p><code>@EnableConfigurationProperties</code></p>\n<p><code>@ConfigurationProperties</code></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> starter</h2>\n<p><code>starter</code> 就是整理了依赖的 <code>maven</code> 配置，主要指 <code>maven</code> 相关依赖配置到单独的一个工程以避免引入过多的 <code>maven</code> 配置</p>\n<h3> 为什么要用starter？</h3>\n<p>开发具体的操作步骤如下：</p>\n<ul>\n<li>到maven仓库去找需要引入的<code>mybatis jar</code>包，选取合适的版本。</li>\n<li>到maven仓库去找 <code>mybatis-spring</code> 整合的<code>jar</code>包，选取合适的版本。</li>\n<li>在<code>spring</code>的<code>applicationContext.xml</code>文件中配置<code>dataSource</code>和<code>mybatis</code>相关信息。</li>\n</ul>\n<p>需要再把上面的<code>步骤再重复</code>一次，工作量无形当中增加了不少，而且有很多重复的工作。</p>\n<p>另外，还是有个问题，每次到要到maven中找合适的版本，如果哪次找的mybatis.jar包 和 mybatis-spring.jar包<code>版本不兼容</code>，程序不是会出现问题？</p>\n<p>SpringBoot为了解决以上两个问题引入了starter机制。</p>\n<h3> starter有哪些要素？</h3>\n<p><code>mybatis-spring-boot-starter.jar</code>是如何定义的</p>\n\n<p><code>mybatis-spring-boot-autoconfigure.jar</code></p>\n\n<p><code>spring-configuration-metadata.json</code> 和 <code>additional-spring-configuration-metadata.json</code> 的功能差不多，我们在<code>applicationContext.properties</code>文件中输入<code>spring</code>时，会自动出现下面的配置信息可供选择，就是这个功能了。</p>\n<p>这两个文件有什么区别?</p>\n<p>答：如果 <code>pom.xml </code>中引入了 <code>spring-boot-configuration-processor </code>包，则会自动生成<code>spring-configuration-metadata.json</code>。</p>\n<p>如果需要<code>手动修改里面的元数据</code>，则可以在<code>additional-spring-configuration-metadata.json</code>中编辑，最终两个文件中的元数据会合并到一起。</p>\n<h2> 如何定义自己的starter？</h2>\n<p>1 创建一个空的项目</p>\n<p>命名规则： xxx-spring-boot-starter.jar</p>\n<p>2 pom 引用 xxx-spring-boot-autoconfigure</p>\n<p>3 创建 xxx-spring-boot-autoconfigure 项目</p>\n<p>使用 引用 xxx-spring-boot-starter.jar</p>\n",
      "date_modified": "2023-08-03T23:47:31.039Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "sprinmvc",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springmvc/%E5%9F%BA%E7%A1%80.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/springmvc/%E5%9F%BA%E7%A1%80.html",
      "summary": "参考 https://pdai.tech/md/spring/spring-x-framework-springmvc.html 执行流程 核心架构的具体流程步骤如下：",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://pdai.tech/md/spring/spring-x-framework-springmvc.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://pdai.tech/md/spring/spring-x-framework-springmvc.html</a></p>\n</div>\n<h2> 执行流程</h2>\n<p></p>\n<p>核心架构的具体流程步骤如下：</p>\n<p>1 首先用户发送请求<code>——&gt;DispatcherServlet</code>，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行 处理，作为统一访问点，进行全局的流程控制；</p>\n<p>2 <code>DispatcherServlet——&gt; HandlerMapping</code>，<code>HandlerMapping</code> 将会把请求映射为 <code>HandlerExecutionChain</code> 对象（包含一 个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新 的映射策略；</p>\n<p>3 <code>DispatcherServlet——&gt;HandlerAdapter</code>，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器， 即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p>\n<p>4 <code>HandlerAdapter——&gt;</code>处理器功能处理方法的调用，<code>HandlerAdapter</code>将会根据适配的结果调用真正的处理器的功能处 理方法，完成功能处理；并返回一个<code>ModelAndView </code>对象（包含模型数据、逻辑视图名）；</p>\n<p>5 <code>ModelAndView</code> 的逻辑视图名——&gt; <code>ViewResolver</code>，<code>ViewResolver</code>将把逻辑视图名解析为具体的<code>View</code>，通过这种策 略模式，很容易更换其他视图技术；</p>\n<p>6 <code>View——&gt;</code>渲染，View 会根据传进来的Model 模型数据进行渲染，此处的 <code>Model</code> 实际是一个 <code>Map</code> 数据结构，因此 很容易支持其他视图技术；</p>\n<p>7 返回控制权给<code>DispatcherServlet</code>，由<code>DispatcherServlet</code>返回响应给用户，到此一个流程结束。</p>\n<h2> HandlerInterceptor 拦截器</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:31.040Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "tomcat调优",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/study/tomcat/%E5%9F%BA%E7%A1%80.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/study/tomcat/%E5%9F%BA%E7%A1%80.html",
      "summary": "参考 实战Springboot内置Tomcat配置调优 一个Tomcat最多支持多少用户的并发？ 服务端优化-Tomcat调优",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.cnblogs.com/lys_013/p/13185940.html\" target=\"_blank\" rel=\"noopener noreferrer\">实战Springboot内置Tomcat配置调优</a></p>\n<p><a href=\"https://www.cnblogs.com/zhaosq/p/10870762.html\" target=\"_blank\" rel=\"noopener noreferrer\">一个Tomcat最多支持多少用户的并发？</a></p>\n<p><a href=\"https://juejin.cn/post/7130909498285228040\" target=\"_blank\" rel=\"noopener noreferrer\">服务端优化-Tomcat调优 </a></p>\n</div>\n<p>1、方便微服务部署，减少繁杂的配置</p>\n<p>2、方便项目启动，不需要单独下载web容器，如Tomcat，jetty等。</p>\n<p>#云服务器配置12核心，24G内存，java启动jar命令：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>针对目前的容器优化，可以从以下几点考虑：</p>\n<p>1、线程数</p>\n<p>2、超时时间</p>\n<p>3、JVM优化</p>\n<p>首先，线程数是一个重点，每一次HTTP请求到达Web服务器，Web服务器都会创建一个线程来处理该请求，该参数决定了应用服务同时可以处理多少个HTTP请求。</p>\n<p>比较重要的有两个：初始线程数 和 最大线程数。</p>\n<p><u>初始线程数</u>：保障启动的时候，如果有大量用户访问，能够很稳定的接受请求。最大线程数：用来保证系统的稳定性。</p>\n<p><u>超时时间</u>：用来保障连接数不容易被压垮。如果大批量的请求过来，延迟比较高，很容易把线程数用光，这时就需要提高超时时间。这种情况在生产中是比较常见的 ，一旦网络不稳定，宁愿丢包也不能把服务器压垮。</p>\n<p><u><code>min-spare-threads</code>：最小备用线程数，tomcat启动时的初始化的线程数。</u></p>\n<p><code>max-threads</code>：Tomcat可创建的最大的线程数，每一个线程处理一个请求，超过这个请求数后，客户端请求只能排队，等有线程释放才能处理。\n（）</p>\n<p><code>accept-count</code>：当调用Web服务的HTTP请求数达到tomcat的最大线程数时，还有新的HTTP请求到来，这时tomcat会将该请求放在等待队列中，这个<code>acceptCount</code>就是指能够接受的最大等待数，默认100。如果等待队列也被放满了，这个时候再来新的请求就会被tomcat拒绝（<code>connection refused</code>）。</p>\n<p><code>max-connections</code>：这个参数是指在同一时间，tomcat能够接受的最大连接数。一般这个值要大于<code>(max-threads)+(accept-count)</code>。</p>\n<p><code>connection-timeout</code>：最长等待时间，如果没有数据进来，等待一段时间后断开连接，释放线程。</p>\n<p>在<code>spring boot</code>配置文件中<code>application.yml</code>，添加以下配置：</p>\n<p>这块对tomcat进行了一个优化配置，最大线程数是<code>2500</code>，初始化线程是<code>500</code>，超时时间是<code>12000ms</code>；</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>JVM优化一般来说没有太多场景，无非就是加大初始的堆，和最大限制堆,当然也不能无限增大，要根据实际情况优化。</p>\n<p>初始内存和最大内存基本会设置成一样的，具体大小根据场景设置，-server是一个必须要用的参数，至于收集器这些使用默认的就可以了，除非有特定需求。</p>\n<p>1.使用-server模式：设置JVM使用server模式。64位JDK默认启动该模式。</p>\n<p>2.指定堆参数：这个根据服务器的内存大小，来设置堆参数。</p>\n<p>-Xms :设置Java堆栈的初始化大小</p>\n<p>-Xmx :设置最大的java堆大小</p>\n<p>设置初始化堆内存为10240MB，最大为14336MB。</p>\n<h2> tomcat 配置</h2>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 参数说明</h2>\n<p><code>maxIdleTime：</code> 最大空闲时间，超过这个空闲时间，且线程数大于minSpareThreads的，都会被回收，默认值1分钟（60000ms）；</p>\n<p><code>minSpareThreads：</code>最小空闲线程数，任何情况都会存活的线程数，即便超过了最大空闲时间，也不会被回收，默认值4；</p>\n<p><code>maxSpareThreads</code>：最大空闲线程数，在最大空闲时间（maxIdleTime）内活跃过，此时空闲，当空闲时间大于maxIdleTime则被回收，小则继续存活，等待被调度，默认值50；</p>\n<p><code>maxThreads：</code>最大线程数，大并发请求时，tomcat能创建来处理请求的最大线程数，超过则放入请求队列中进行排队，默认值为200；</p>\n<p><code>acceptCount：</code>当最大线程数（maxThreads）被使用完时，可以放入请求队列排队个数，超过这个数返回connection refused（请求被拒绝），一般设置和maxThreads一样，不过这个具体需要根据自己的应用实际访问峰值和平均值来权衡，默认值为100；</p>\n<p><code>connectionTimeout</code>：网络连接超时，假设设置为0表示永不超时，这样设置隐患巨大，通常可设置为30000ms，默认60000ms。</p>\n\n<h2> springboot</h2>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> accept-count：最大等待数</h3>\n<p>当调用HTTP请求数达到tomcat的最大线程数时，还有新的请求进来，这时tomcat会将该剩余请求放到等待队列中，acceptCount就是指队列能够接受的最大等待数。默认 100 ，如果等待队列超了，新的请求就会被拒绝（connection refused）。</p>\n<h3> maxThreads：最大线程数</h3>\n<p>每一次HTTP请求到达Web服务，tomcat都会创建一个线程来处理该请求。\n最大线程数决定了Web服务容器可以同时处理多少个请求。默认是 200 。\n当然最大线程数肯定建议增加越大越好。但是增加线程是有成本的，不能无限制增大。线程多不仅仅会带来线程上下文切换的成本，而且线程也需要消耗内存资源。JVM中默认情况下在创建新线程时会分配大小为1M的线程栈，所以，更多的线程异味着需要更多的内存。\n线程数的经验值为： 1 核2g内存为 200 ，线程数经验值 200 ； 4 核8g内存，线程数经验值 1000 。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Max Connections：最大连接数</h3>\n<p>最大连接数是指在同一时间，tomcat能够接受的最大连接数。如果设置为-1，则禁用Max Connections功能，不限制连接</p>\n<p>对于Java的阻塞式BIO默认值是Max Threads的值；如果在BIO模式使用定制的Executor执行器，默认值将是执行器中Max Threads的值。\n对于Java 新的NIO模式，Max Connections 默认值是 10000\n对于Windows上APR/native IO模式，Max Connections默认值为 8192 ，这是出于性能原因，如果配置的值不是 1024 的倍数，Max Connections的实际值将减少到 1024 的最大倍数。</p>\n<p>Max Connections和accept-count关系：当连接数达到最大值Max Connections后系统会继续接收连接，但不会超过acceptCount的限制。</p>\n",
      "date_modified": "2023-08-03T23:47:31.044Z",
      "authors": [],
      "tags": [
        "学习笔记"
      ]
    },
    {
      "title": "数据库基础知识",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/basic/basic.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/basic/basic.html",
      "summary": "数据库范式了解吗? 数据库范式有 3 种： 1NF(第一范式)：属性不可再分。 2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。 3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。 什么是 ER 图？ 我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问到的。 ER 图 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。",
      "content_html": "<h2> 数据库范式了解吗?</h2>\n<p>数据库范式有 3 种：</p>\n<ul>\n<li>1NF(第一范式)：属性不可再分。</li>\n<li>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>\n<li>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li>\n</ul>\n<h2> 什么是 ER 图？</h2>\n<p>我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问到的。</p>\n<p><strong>ER 图</strong> 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。</p>\n<p>ER 图由下面 3 个要素组成：</p>\n<ul>\n<li><strong>实体</strong> ：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li>\n<li><strong>属性</strong> ：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用椭圆形表示。</li>\n<li><strong>联系</strong> ：即实体与实体之间的关系，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li>\n</ul>\n<p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1: N）。</p>\n<p></p>\n<h2> 主键和外键有什么区别?</h2>\n<ul>\n<li><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li>\n<li><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li>\n</ul>\n<h2> 为什么不推荐使用外键与级联？</h2>\n<p>对于外键和级联，阿里巴巴开发手册这样说到：</p>\n<blockquote>\n<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>\n<p>说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度</p>\n</blockquote>\n<p>为什么不要用外键呢？大部分人可能会这样回答：</p>\n<ol>\n<li><strong>增加了复杂性：</strong> a. 每次做 DELETE 或者 UPDATE 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li>\n<li><strong>增加了额外工作</strong>： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li>\n<li><strong>对分库分表不友好</strong> ：因为分库分表下外键是无法生效的。</li>\n<li>......</li>\n</ol>\n<p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p>\n<ol>\n<li>保证了数据库数据的一致性和完整性；</li>\n<li>级联操作方便，减轻了程序代码量；</li>\n<li>......</li>\n</ol>\n<p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p>\n<h2> 什么是存储过程?</h2>\n<p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p>\n<p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p>\n<p>阿里巴巴 Java 开发手册里要求禁止使用存储过程。</p>\n<h2> drop、delete 与 truncate 区别？</h2>\n<h3> 用法不同</h3>\n<ul>\n<li><code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>\n<li><code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>\n<li><code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li>\n</ul>\n<p><code>truncate</code> 和不带 where``子句的 <code>delete</code>、以及 <code>drop</code> 都会删除表内的数据，但是 <strong><code>truncate</code> 和 <code>delete</code> 只删除数据不删除表的结构(定义)，执行 <code>drop</code> 语句，此表的结构也会删除，也就是执行 <code>drop</code> 之后对应的表不复存在。</strong></p>\n<h3> 属于不同的数据库语言</h3>\n<p><code>truncate</code> 和 <code>drop</code> 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 <code>delete</code> 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。</p>\n<p><strong>DML 语句和 DDL 语句区别：</strong></p>\n<ul>\n<li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li>\n<li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li>\n</ul>\n<p>另外，由于<code>select</code>不会对表进行破坏，所以有的地方也会把<code>select</code>单独区分开叫做数据库查询语言 DQL（Data Query Language）。</p>\n<h3> 执行速度不同</h3>\n<p>一般来说：<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code>（这个我没有设计测试过）。</p>\n<ul>\n<li><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li>\n<li><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</li>\n<li><code>drop</code>命令会把表占用的空间全部释放掉。</li>\n</ul>\n<p>Tips：你应该更多地关注在使用场景上，而不是执行效率。</p>\n<h2> 数据库设计通常分为哪几步?</h2>\n<ol>\n<li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li>\n<li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li>\n<li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>\n<li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li>\n<li><strong>数据库实施</strong> : 包括编程、测试和试运行</li>\n<li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li>\n</ol>\n",
      "date_modified": "2023-08-03T23:47:31.046Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "字符集知识",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/basic/charset.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/basic/charset.html",
      "summary": "MySQL 字符编码集中有两套 UTF-8 编码实现：utf8 和 utf8mb4。 如果使用 utf8 的话，存储emoji 符号和一些比较复杂的汉字、繁体字就会出错。 为什么会这样呢？这篇文章可以从源头给你解答。 何为字符集？ 字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 字符集 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。",
      "content_html": "<p><code>MySQL</code> 字符编码集中有两套 UTF-8 编码实现：<strong><code>utf8</code></strong> 和 <strong><code>utf8mb4</code></strong>。</p>\n<p>如果使用 <strong><code>utf8</code></strong>  的话，存储emoji 符号和一些比较复杂的汉字、繁体字就会出错。</p>\n<p>为什么会这样呢？这篇文章可以从源头给你解答。</p>\n<h2> 何为字符集？</h2>\n<p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 <strong>字符集</strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。</p>\n<p><strong>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</strong></p>\n<p>我们要将这些字符和二进制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。我们将字符对应二进制数据的过程称为\"<strong>字符编码</strong>\"，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</p>\n<h2> 有哪些常见的字符集？</h2>\n<p>常见的字符集有<code> ASCII、GB2312、GBK、UTF-8</code>......。</p>\n<p>不同的字符集的主要区别在于：</p>\n<ul>\n<li>可以表示的字符范围</li>\n<li>编码方式</li>\n</ul>\n<h3> ASCII</h3>\n<p><strong>ASCII</strong> (<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</p>\n<p><strong>为什么 ASCII 字符集没有考虑到中文等其他字符呢？</strong> 因为计算机是美国人发明的，当时，计算机的发展还处于比较雏形的时代，还未在其他国家大规模使用。因此，美国发布 ASCII 字符集的时候没有考虑兼容其他国家的语言。</p>\n<p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。</p>\n<p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII 码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集可以定义 128（2<sup>7</sup>）个字符。</p>\n<p>由于，ASCII 码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了 <strong>ASCII 扩展字符集</strong> 。ASCII 扩展字符集使用 8 位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义 256（2<sup>8</sup>）个字符。</p>\n<h3> GB2312</h3>\n<p>我们上面说了，<code>ASCII</code> 字符集是一种现代美国英语适用的字符集。因此，很多国家都捣鼓了一个适合自己国家语言的字符集。</p>\n<p><code>GB2312</code> 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，<code>GB2312 </code>字符集不支持绝大部分的生僻字和繁体字。</p>\n<p>对于英语字符，<code>GB2312</code> 编码和 <code>ASCII</code> 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。</p>\n<h3> GBK</h3>\n<p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 <code>GB2312 </code>字符集，共收录了 <code>20000</code> 多个汉字。</p>\n<p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。</p>\n<h3> GB18030</h3>\n<p><code>GB18030</code> 完全兼容 <code>GB2312 </code>和 <code>GBK</code> 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 <code>70000</code> 多个。</p>\n<h3> BIG5</h3>\n<p><code>BIG5 </code>主要针对的是繁体中文，收录了 <code>13000</code> 多个汉字。</p>\n<h3> Unicode &amp; UTF-8编码</h3>\n<p>为了更加适合本国语言，诞生了很多种字符集。</p>\n<p>我们上面也说了不同的字符集可以表示的字符范围以及编码规则存在差异。这就导致了一个非常严重的问题：<strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p>\n<p>就比如说你使用 UTF-8 编码方式打开 GB2312 编码格式的文件就会出现乱码。示例：“牛”这个汉字 GB2312 编码后的十六进制数值为 “C5A3”，而 “C5A3” 用 UTF-8 解码之后得到的却是 “ţ”。</p>\n<p>你可以通过这个网站在线进行编码和解码：</p>\n<p>https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan</p>\n",
      "date_modified": "2023-08-03T23:47:31.048Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "NoSql基础知识",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/basic/nosql.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/basic/nosql.html",
      "summary": "NoSQL 是什么？ NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。 一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。 NoSQL 数据库代表：HBase 、Cassandra、MongoDB、Redis。",
      "content_html": "<h2> NoSQL 是什么？</h2>\n<p><code>NoSQL</code>（<code>Not Only SQL</code> 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p>\n<p>一个常见的误解是 <code>NoSQL</code> 数据库或非关系型数据库不能很好地存储关系型数据。<code>NoSQL </code>数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。</p>\n<p><code>NoSQL</code> 数据库代表：<code>HBase 、Cassandra、MongoDB、Redis</code>。</p>\n<h2> SQL 和 NoSQL 有什么区别？</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th>SQL 数据库</th>\n<th>NoSQL 数据库</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">数据存储模型</td>\n<td>结构化存储，具有固定行和列的表格</td>\n<td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">发展历程</td>\n<td>开发于 1970 年代，重点是减少数据重复</td>\n<td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">例子</td>\n<td>Oracle、MySQL、Microsoft SQL Server 、PostgreSQL</td>\n<td>文档：MongoDB、CouchDB，键值：Redis 、DynamoDB，宽列：Cassandra 、 HBase，图表：Neo4j 、 Amazon Neptune、Giraph</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ACID 属性</td>\n<td>提供原子性、一致性、隔离性和持久性 (ACID) 属性</td>\n<td>通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">性能</td>\n<td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。</td>\n<td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">扩展</td>\n<td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td>\n<td>横向（增加服务器的方式横向扩展，通常是基于分片机制）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">用途</td>\n<td>普通企业级的项目的数据存储</td>\n<td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查询语法</td>\n<td>结构化查询语言 (SQL)</td>\n<td>数据访问语法可能因数据库而异</td>\n</tr>\n</tbody>\n</table>\n<h2> NoSQL 数据库有什么优势？</h2>\n<p><code>NoSQL</code> 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p>\n<ul>\n<li><strong>灵活性：</strong> <code>NoSQL</code> 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 <code>NoSQL</code> 数据库成为半结构化和非结构化数据的理想之选。</li>\n<li><strong>可扩展性：</strong> <code>NoSQL</code> 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li>\n<li><strong>高性能：</strong> <code>NoSQL</code> 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li>\n<li><strong>强大的功能：</strong> <code>NoSQL</code> 数据库提供功能强大的 <code>API</code> 和数据类型，专门针对其各自的数据模型而构建。</li>\n</ul>\n<h2> NoSQL 数据库有哪些类型？</h2>\n<p>NoSQL 数据库主要可以分为下面四种类型：</p>\n<ul>\n<li><strong>键值</strong> ：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。<code>Redis</code> 和 <code>DynanoDB</code> 是两款非常流行的键值数据库。</li>\n<li><strong>文档</strong> ：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。<code>MongoDB</code> 就是一款非常流行的文档数据库。</li>\n<li><strong>图形</strong> ：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。<code>Neo4j</code> 和 <code>Giraph</code> 是两款非常流行的图形数据库。</li>\n<li><strong>宽列</strong> ：宽列存储数据库非常适合需要存储大量的数据。<code>Cassandra</code> 和<code> HBase</code> 是两款非常流行的宽列存储数据库。</li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:31.050Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "mysql常用函数",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/mysql-function.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/mysql-function.html",
      "summary": "参考 MySQL常用函数介绍 聚合函数 聚合函数是平时比较常用的一类函数，这里列举如下： COUNT(col)&nbsp; &nbsp;统计查询结果的行数 MIN(col)&nbsp; &nbsp;查询指定列的最小值 MAX(col)&nbsp; &nbsp;查询指定列的最大值 SUM(col)&nbsp; &nbsp;求和，返回指定列的总和 AVG(col)&nbsp; &nbsp;求平均值，返回指定列数据的平均值",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://juejin.cn/post/6844903977830580231\" target=\"_blank\" rel=\"noopener noreferrer\"> MySQL常用函数介绍  </a></p>\n</div>\n<h2> 聚合函数</h2>\n<p>聚合函数是平时比较常用的一类函数，这里列举如下：</p>\n\n<h2> 数值型函数</h2>\n\n<h2> 字符串函数</h2>\n\n<h2> 日期和时间函数</h2>\n<h2> 流程控制函数</h2>\n\n",
      "date_modified": "2023-08-03T23:47:31.051Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "mysql索引",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/mysql-index.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/mysql-index.html",
      "summary": "参考 索引失效场景 Mysql5.7及8.0版本索引失效情况汇总 MySQL 的覆盖索引与回表",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://segmentfault.com/a/1190000021464570\" target=\"_blank\" rel=\"noopener noreferrer\"> 索引失效场景 </a></p>\n<p><a href=\"https://blog.csdn.net/qq_38688267/article/details/104900507\" target=\"_blank\" rel=\"noopener noreferrer\">Mysql5.7及8.0版本索引失效情况汇总</a></p>\n<p><a href=\"https://juejin.cn/post/6844904062329028621\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 的覆盖索引与回表 </a></p>\n</div>\n<h2> 回表</h2>\n<p>使用的存储引擎：MySQL5.7 InnoDB</p>\n<h3> 聚簇索引</h3>\n<ul>\n<li>如果表设置了主键，则主键就是聚簇索引</li>\n<li>如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引</li>\n<li>以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引</li>\n</ul>\n<blockquote>\n<p>InnoDB的聚簇索引的叶子节点存储的是行记录（其实是页结构，一个页包含多行数据），InnoDB必须要有至少一个聚簇索引。\n由此可见，使用聚簇索引查询会很快，因为可以直接定位到行记录。</p>\n</blockquote>\n<h3> 普通索引</h3>\n\n<h2> 索引存储结构</h2>\n<p>id 是主键，所以是聚簇索引，其叶子节点存储的是对应行记录的数据</p>\n<p></p>\n<p>age 是普通索引（二级索引），非聚簇索引，其叶子节点存储的是聚簇索引的的值</p>\n<p></p>\n<h3> 聚簇索引查找过程</h3>\n<p>如果查询条件为普通索引（非聚簇索引），需要扫描两次B+树，第一次扫描通过普通索引定位到聚簇索引的值，\n然后第二次扫描通过聚簇索引的值定位到要查找的行记录数据。 如：<code>select * from user where age = 30;</code></p>\n<ol>\n<li>先通过普通索引 age=30 定位到主键值 id=1</li>\n<li>再通过聚集索引 id=1 定位到行记录数据</li>\n</ol>\n<p></p>\n<p>普通索引查找过程第一步</p>\n<p></p>\n<h3> 回表</h3>\n<p>先通过普通索引的值定位聚簇索引值，再通过聚簇索引的值定位行记录数据，需要扫描两次索引B+树，它的性能较扫一遍索引树更低。</p>\n<h2> 索引失效</h2>\n<p></p>\n<h2> 测试数据</h2>\n<p>默认 mysql8</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 一个独立索引</h2>\n<h3> like</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 条件中对索引列进行运算或使用函数</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 不可空索引使用 is not null，仅当查询列只有该索引列时会使用索引</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用OR且存在非索引列</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 使用 NOT IN、IN、IS NULL、IS NOT NULL，且返回值中不止包含条件索引列。</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container info\">\n<p class=\"hint-container-title\">拓展</p>\n<p>MySQL环境变量<code>eq_range_index_dive_limit</code>的值对IN语法有很大影响，该参数表示使用索引情况下IN中参数的最大数量。\nMySQL 5.7.3以及之前的版本中，<code>eq_range_index_dive_limit</code> 的默认值为10，之后的版本默认值为<code>200</code>。\n我们拿MySQL8.0.19举例，<code>eq_range_index_dive_limit=200</code>表示当IN (...)中的值 &gt;200个时，该查询一定不会走索引。\n&lt;=200则可能用到索引。</p>\n</div>\n<h3> 使用非主键范围条件查询时，部分情况索引失效。</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> MySQL5.7，使用 IS NOT NULL或 IS NULL 部分情况下索引失效。</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> MySQL5.7，使用 != 或 IN 或 NOT IN 部分情况下索引失效</h2>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> MySQL5.7，表关联时，关联字段字符集不一致会导致索引失效。</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> MySQL5.7，表关联时，关联字段字符集排序规则不一致会导致索引失效。</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 多个独立索引</h2>\n<h3> 使用OR且第一个条件是范围查询，且返回值中不止包含条件索引列。</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> MySQL5.7，使用OR且存在条件是范围查询，且返回值中不止包含条件索引列。</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 组合索引</h3>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>扩展：</p>\n<p>SELECT col2,col3 FROM test_idx4</p>\n<p>SELECT col2,col3 FROM test_idx4 WHERE col2 = '1' AND col3='2'</p>\n<p>以上两条SQL是可以使用到索引的，原理就是上面提到的索引覆盖，</p>\n<p>虽然根据最左匹配原则是没法使用索引去快速检索数据的；</p>\n<p>但是因为该查询中所查询的列是col1,col2，而该索引只包含col1,col2,col3三个字段信息，</p>\n<p>而主键索引中包含所有字段信息，用该索引做全表扫描的效率更高，所以还是会使用到该索引！</p>\n<h2> 总结</h2>\n\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">拓展：</p>\n<p>为什么只要返回值只包含索引和主键就会用到索引？</p>\n\n</div>\n<p>在复制其他地方提供的sql建表脚本时，注意其字符集和排序规则是否跟自己数据库默认的一致，否则可能出现索引失效的问题。</p>\n<p>不同版本不同情况下，索引的使用情况不一致。上文提到的可能使用可能不使用的情况是由MySQL的优化器决定的，可能还会有其他情况下优化器也不使用索引，此时我们可以强制指定需要使用的索引：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:31.065Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "mysql8 安装",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/mysql-install.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/mysql-install.html",
      "summary": "参考 centos7 安装mysql8",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.cnblogs.com/secretmrj/p/15600144.html\" target=\"_blank\" rel=\"noopener noreferrer\">centos7 安装mysql8</a></p>\n</div>\n",
      "date_modified": "2023-08-03T23:47:31.066Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "mysql锁",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/mysql-lock.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/mysql-lock.html",
      "summary": "参考 mysql next-key lock 枷锁范围 MySQL 锁 锁是一种常见的并发事务的控制方式。 表级锁和行级锁了解吗？有什么区别？ MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://segmentfault.com/a/1190000040129107\" target=\"_blank\" rel=\"noopener noreferrer\"> mysql next-key lock 枷锁范围 </a></p>\n</div>\n<h2> MySQL 锁</h2>\n<p>锁是一种常见的并发事务的控制方式。</p>\n<h3> 表级锁和行级锁了解吗？有什么区别？</h3>\n<p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p>\n<p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p>\n<p><strong>表级锁和行级锁对比</strong> ：</p>\n<ul>\n<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li>\n<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li>\n</ul>\n<h3> 行级锁的使用有什么注意事项？</h3>\n<p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p>\n<p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p>\n<h3> InnoDB 有哪几类行锁？</h3>\n<p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>\n<ul>\n<li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li>\n<li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li>\n<li><strong>临键锁（Next-Key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>\n</ul>\n<p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p>\n<p>一些大厂面试中可能会问到 Next-Key Lock 的加锁范围，这里推荐一篇文章：<a href=\"https://segmentfault.com/a/1190000040129107\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL next-key lock 加锁范围是什么？ - 程序员小航 - 2021</a> 。</p>\n<h3> 共享锁和排他锁呢？</h3>\n<p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p>\n<p><u>共享锁（S 锁） ：又称读锁</u>，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。\n<u>排他锁（X 锁） ：又称写锁/独占锁</u>，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</p>\n<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">S 锁</th>\n<th style=\"text-align:left\">X 锁</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">S 锁</td>\n<td style=\"text-align:left\">不冲突</td>\n<td style=\"text-align:left\">冲突</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">X 锁</td>\n<td style=\"text-align:left\">冲突</td>\n<td style=\"text-align:left\">冲突</td>\n</tr>\n</tbody>\n</table>\n<p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 意向锁有什么作用？</h3>\n<p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p>\n<p>意向锁是表级锁，共有两种：</p>\n<ul>\n<li>意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li>\n<li>意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li>\n</ul>\n<p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p>\n<p>意向锁之间是互相兼容的。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>IS 锁</th>\n<th>IX 锁</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IS 锁</td>\n<td>兼容</td>\n<td>兼容</td>\n</tr>\n<tr>\n<td>IX 锁</td>\n<td>兼容</td>\n<td>兼容</td>\n</tr>\n</tbody>\n</table>\n<p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>IS 锁</th>\n<th>IX 锁</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>S 锁</td>\n<td>兼容</td>\n<td>互斥</td>\n</tr>\n<tr>\n<td>X 锁</td>\n<td>互斥</td>\n<td>互斥</td>\n</tr>\n</tbody>\n</table>\n<p>《MySQL 技术内幕 InnoDB 存储引擎》这本书对应的描述应该是笔误了。</p>\n<h3> 当前读和快照读有什么区别？</h3>\n<p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p>\n<p>快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p>\n<p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p>\n<ul>\n<li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li>\n<li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li>\n</ul>\n<p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p>\n<p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p>\n<p>当前读的一些常见 SQL 语句类型如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 自增锁有了解吗？</h3>\n<blockquote>\n<p>不太重要的一个知识点，简单了解即可。</p>\n</blockquote>\n<p>关系型数据库设计表的时候，通常会有一列作为自增主键。InnoDB 中的自增主键会涉及一种比较特殊的表级锁— <strong>自增锁（AUTO-INC Locks）</strong> 。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>更准确点来说，不仅仅是自增主键，<code>AUTO_INCREMENT</code>的列都会涉及到自增锁，毕竟非主键也可以设置自增长。</p>\n<p>如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能会被阻塞住。这里的阻塞行为只是自增锁行为的其中一种，可以理解为自增锁就是一个接口，其具体的实现有多种。具体的配置项为 <code>innodb_autoinc_lock_mode</code> （MySQL 5.1.22 引入），可以选择的值如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">innodb_autoinc_lock_mode</th>\n<th style=\"text-align:left\">介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">传统模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">连续模式（MySQL 8.0 之前默认）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">交错模式(MySQL 8.0 之后默认)</td>\n</tr>\n</tbody>\n</table>\n<p>交错模式下，所有的“INSERT-LIKE”语句（所有的插入语句，包括： <code>INSERT</code>、<code>REPLACE</code>、<code>INSERT…SELECT</code>、<code>REPLACE…SELECT</code>、<code>LOAD DATA</code>等）都不使用表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行，速度更快，扩展性也更好。</p>\n<p>不过，如果你的 MySQL 数据库有主从同步需求并且 Binlog 存储格式为 Statement 的话，不要将 InnoDB 自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序就无法得到保障。</p>\n<blockquote>\n<p>如果 MySQL 采用的格式为 Statement ，那么 MySQL 的主从同步实际上同步的就是一条一条的 SQL 语句。</p>\n</blockquote>\n<p>最后，再推荐一篇文章： <a href=\"https://draveness.me/whys-the-design-mysql-auto-increment/\" target=\"_blank\" rel=\"noopener noreferrer\">为什么 MySQL 的自增主键不单调也不连续</a> 。</p>\n<h2> </h2>\n<p>此时数据库的数据如图所示，对主键索引来说此时数据间隙如下：</p>\n<p></p>\n<h3> 主键等值查询 —— 数据存在</h3>\n<div class=\"language-mysql line-numbers-mode\" data-ext=\"mysql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>结果很明显，这里是对表添加了一个 IX 锁 并对主键索引 id = 10 的记录，添加了一个 X,REC_NOT_GAP 锁，表示只锁定了记录。</p>\n<p>同样 for share 是对表添加了一个 IS 锁并对主键索引 id = 10 的记录，添加了一个 S 锁。</p>\n<p>可以得出结论：</p>\n<p>对主键等值加锁，且值存在时，会对表添加意向锁，同时会对主键索引添加行锁。</p>\n<h3> 主键等值查询 —— 数据不存在</h3>\n<div class=\"language-mysql line-numbers-mode\" data-ext=\"mysql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果是数据不存在的时候，会加什么锁呢？锁的范围又是什么？</p>\n<p>在验证之前，分析一下数据的间隙。</p>\n\n<h3> 主键范围查询（重点）</h3>\n<div class=\"language-mysql line-numbers-mode\" data-ext=\"mysql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>\n<p>结论一：</p>\n\n",
      "date_modified": "2023-08-03T23:47:31.071Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "MySQL高性能优化",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/mysql-optimization.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/mysql-optimization.html",
      "summary": "数据库命名规范 所有数据库对象名称必须使用小写字母并用下划线分割 所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来） 数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符 临时库表必须以 tmp_ 为前缀并以日期为后缀，备份表必须以 bak_ 为前缀并以日期 (时间戳) 为后缀 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）",
      "content_html": "<h2> 数据库命名规范</h2>\n<ul>\n<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>\n<li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>\n<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>\n<li>临时库表必须以 <code>tmp_</code> 为前缀并以日期为后缀，备份表必须以 <code>bak_</code> 为前缀并以日期 (时间戳) 为后缀</li>\n<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>\n</ul>\n<h2> 数据库基本设计规范</h2>\n<h3> 所有表必须使用 InnoDB 存储引擎</h3>\n<p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。</p>\n<p>InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>\n<h3> 数据库和表的字符集统一使用 UTF8</h3>\n<p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p>\n<h3> 所有表和字段都需要添加注释</h3>\n<p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p>\n<h3> 尽量控制单表数据量的大小，建议控制在 500 万以内</h3>\n<p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>\n<p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>\n<h3> 谨慎使用 MySQL 分区表</h3>\n<p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>\n<p>谨慎选择分区键，跨分区查询效率可能更低；</p>\n<p>建议采用物理分表的方式管理大数据。</p>\n<h3> 经常一起使用的列放到一个表中</h3>\n<p>避免更多的关联操作。</p>\n<h3> 禁止在表中建立预留字段</h3>\n<ul>\n<li>预留字段的命名很难做到见名识义。</li>\n<li>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</li>\n<li>对预留字段类型的修改，会对表进行锁定。</li>\n</ul>\n<h3> 禁止在数据库中存储文件（比如图片）这类大的二进制数据</h3>\n<p>在数据库中存储文件会严重影响数据库性能，消耗过多存储空间。</p>\n<p>文件（比如图片）这类大的二进制数据通常存储于文件服务器，数据库只存储文件地址信息。</p>\n<h3> 不要被数据库范式所束缚</h3>\n<p>一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。</p>\n<h3> 禁止在线上做数据库压力测试</h3>\n<h3> 禁止从开发环境,测试环境直接连接生产环境数据库</h3>\n<p>安全隐患极大，要对生产环境抱有敬畏之心！</p>\n<h2> 数据库字段设计规范</h2>\n<h3> 优先选择符合存储需要的最小的数据类型</h3>\n<p>存储字节越小，占用也就空间越小，性能也越好。</p>\n<p><strong>a.某些字符串可以转换成数字类型存储比如可以将 IP 地址转换成整型数据。</strong></p>\n<p>数字是连续的，性能更好，占用空间也更小。</p>\n<p>MySQL 提供了两个方法来处理 ip 地址</p>\n<ul>\n<li><code>INET_ATON()</code> ： 把 ip 转为无符号整型 (4-8 位)</li>\n<li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li>\n</ul>\n<p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p>\n<p><strong>b.对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储。</strong></p>\n<p>无符号相对于有符号可以多出一倍的存储空间</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>c.小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。</strong></p>\n<h3> 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h3>\n<p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。</strong></p>\n<p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>\n<p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 <code>select *</code>而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>\n<p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p>\n<p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p>\n<h3> 避免使用 ENUM 类型</h3>\n<ul>\n<li>修改 ENUM 值需要使用 ALTER 语句；</li>\n<li>ENUM 类型的 ORDER BY 操作效率低，需要额外操作；</li>\n<li>ENUM 数据类型存在一些限制比如建议不要使用数值作为 ENUM 的枚举值。</li>\n</ul>\n<p>相关阅读：<a href=\"https://www.zhihu.com/question/404422255/answer/1661698499\" target=\"_blank\" rel=\"noopener noreferrer\">是否推荐使用 MySQL 的 enum 类型？ - 架构文摘 - 知乎</a> 。</p>\n<h3> 尽可能把所有列定义为 NOT NULL</h3>\n<p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p>\n<ul>\n<li>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li>\n<li>进行比较和计算时要对 NULL 值做特别的处理。</li>\n</ul>\n<p>相关阅读：<a href=\"https://opensource.actionsky.com/20190710-mysql/\" target=\"_blank\" rel=\"noopener noreferrer\">技术分享 | MySQL 默认值选型（是空，还是 NULL）</a> 。</p>\n<h3> 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h3>\n<p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p>\n<p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p>\n<p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p>\n<p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p>\n<ul>\n<li>缺点 1：无法用日期函数进行计算和比较</li>\n<li>缺点 2：用字符串存储日期要占用更多的空间</li>\n</ul>\n<h3> 同财务相关的金额类数据必须使用 decimal 类型</h3>\n<ul>\n<li><strong>非精准浮点</strong> ：float,double</li>\n<li><strong>精准浮点</strong> ：decimal</li>\n</ul>\n<p>decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据</p>\n<p>不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p>\n<h3> 单表不要包含过多字段</h3>\n<p>如果一个表包含过多字段的话，可以考虑将其分解成多个表，必要时增加中间表进行关联。</p>\n<h2> 索引设计规范</h2>\n<h3> 限制每张表上的索引数量,建议单张表索引不超过 5 个</h3>\n<p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>\n<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>\n<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>\n<h3> 禁止使用全文索引</h3>\n<p>全文索引不适用于 OLTP 场景。</p>\n<h3> 禁止给表中的每一列都建立单独的索引</h3>\n<p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p>\n<h3> 每个 InnoDB 表必须有个主键</h3>\n<p>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>\n<p>InnoDB 是按照主键索引的顺序来组织表的</p>\n<ul>\n<li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li>\n<li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li>\n<li>主键建议使用自增 ID 值</li>\n</ul>\n<h3> 常见索引列建议</h3>\n<ul>\n<li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li>\n<li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li>\n<li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li>\n<li>多表 join 的关联列</li>\n</ul>\n<h3> 如何选择索引列的顺序</h3>\n<p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>\n<ul>\n<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li>\n<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li>\n<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>\n</ul>\n<h3> 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h3>\n<ul>\n<li>重复索引示例：primary key(id)、index(id)、unique index(id)</li>\n<li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li>\n</ul>\n<h3> 对于频繁的查询优先考虑使用覆盖索引</h3>\n<blockquote>\n<p>覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p>\n</blockquote>\n<p><strong>覆盖索引的好处：</strong></p>\n<ul>\n<li><strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>\n<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li>\n</ul>\n<hr>\n<h3> 索引 SET 规范</h3>\n<p><strong>尽量避免使用外键约束</strong></p>\n<ul>\n<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li>\n<li>外键可用于保证数据的参照完整性，但建议在业务端实现</li>\n<li>外键会影响父表和子表的写操作从而降低性能</li>\n</ul>\n<h2> 数据库 SQL 开发规范</h2>\n<h3> 优化对性能影响较大的 SQL 语句</h3>\n<p>要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句；</p>\n<h3> 充分利用表上已经存在的索引</h3>\n<p>避免使用双%号的查询条件。如：<code>a like '%123%'</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p>\n<p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p>\n<p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p>\n<h3> 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h3>\n<ul>\n<li><code>SELECT *</code> 消耗更多的 CPU 和 IO 以网络带宽资源</li>\n<li><code>SELECT *</code> 无法使用覆盖索引</li>\n<li><code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响</li>\n</ul>\n<h3> 禁止使用不含字段列表的 INSERT 语句</h3>\n<p>如：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>应使用：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 建议使用预编译语句进行数据库操作</h3>\n<ul>\n<li>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</li>\n<li>只传参数，比传递 SQL 语句更高效。</li>\n<li>相同语句可以一次解析，多次使用，提高处理效率。</li>\n</ul>\n<h3> 避免数据类型的隐式转换</h3>\n<p>隐式转换会导致索引失效如:</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 避免使用子查询，可以把子查询优化为 join 操作</h3>\n<p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p>\n<p><strong>子查询性能差的原因：</strong> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p>\n<h3> 避免使用 JOIN 关联太多的表</h3>\n<p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p>\n<p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p>\n<p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p>\n<p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p>\n<h3> 减少同数据库的交互次数</h3>\n<p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p>\n<h3> 对应同一列进行 or 判断时，使用 in 代替 or</h3>\n<p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>\n<h3> 禁止使用 order by rand() 进行随机排序</h3>\n<p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>\n<p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p>\n<h3> WHERE 从句中禁止对列进行函数转换和计算</h3>\n<p>对列进行函数转换或计算时会导致无法使用索引</p>\n<p><strong>不推荐：</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>推荐：</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> 在明显不会有重复值时使用 UNION ALL 而不是 UNION</h3>\n<ul>\n<li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li>\n<li>UNION ALL 不会再对结果集进行去重操作</li>\n</ul>\n<h3> 拆分复杂的大 SQL 为多个小 SQL</h3>\n<ul>\n<li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li>\n<li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li>\n<li>SQL 拆分后可以通过并行执行来提高处理效率</li>\n</ul>\n<h3> 程序连接不同的数据库使用不同的账号，禁止跨库查询</h3>\n<ul>\n<li>为数据库迁移和分库分表留出余地</li>\n<li>降低业务耦合度</li>\n<li>避免权限过大而产生的安全风险</li>\n</ul>\n<h2> 数据库操作行为规范</h2>\n<h3> 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h3>\n<p><strong>大批量操作可能会造成严重的主从延迟</strong></p>\n<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>\n<p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p>\n<p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>\n<p><strong>避免产生大事务操作</strong></p>\n<p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>\n<p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>\n<h3> 对于大表使用 pt-online-schema-change 修改表结构</h3>\n<ul>\n<li>避免大表修改产生的主从延迟</li>\n<li>避免在对表字段进行修改时进行锁表</li>\n</ul>\n<p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p>\n<p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p>\n<h3> 禁止为程序使用的账号赋予 super 权限</h3>\n<ul>\n<li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li>\n<li>super 权限只能留给 DBA 处理问题的账号使用</li>\n</ul>\n<h3> 对于程序连接数据库账号,遵循权限最小原则</h3>\n<ul>\n<li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li>\n<li>程序使用的账号原则上不准有 drop 权限</li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:31.083Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "mysql 事务隔离级别",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/mysql-transaction.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/mysql-transaction.html",
      "summary": "参考 MySQL 事务 何谓事务？ 我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题： 数据库中途突然因为某些原因挂掉了。 客户端突然因为网络原因连接不上数据库了。 并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。 ......",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n</div>\n<h2> MySQL 事务</h2>\n<h3> 何谓事务？</h3>\n<p>我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：</p>\n<ul>\n<li>数据库中途突然因为某些原因挂掉了。</li>\n<li>客户端突然因为网络原因连接不上数据库了。</li>\n<li>并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。</li>\n<li>......</li>\n</ul>\n<p>上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。</p>\n<p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>\n<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p>\n<ol>\n<li>将小明的余额减少 1000 元</li>\n<li>将小红的余额增加 1000 元。</li>\n</ol>\n<p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p>\n<h3> 何谓数据库事务？</h3>\n<p>大多数情况下，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p>\n<p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p>\n<p><strong>那数据库事务有什么作用呢？</strong></p>\n<p>简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p>\n<p></p>\n<ol>\n<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>\n<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>\n<li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ol>\n<p>🌈 这里要额外补充一点：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong> 想必大家也和我一样，被 ACID 这个概念被误导了很久! 我也是看周志明老师的公开课<a href=\"https://time.geekbang.org/opencourse/intro/100064201\" target=\"_blank\" rel=\"noopener noreferrer\">《周志明的软件架构课》</a>才搞清楚的（多看好书！！！）。</p>\n<p></p>\n<h3> 并发事务带来了哪些问题?</h3>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<h4> 脏读（Dirty read）</h4>\n<p><u>一个事务读取了另一个事务未提交的数据</u></p>\n<p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>\n<p>例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</p>\n<p></p>\n<h4> 丢失修改（Lost to modify）</h4>\n<p><u>两个事务修改了相同的数据</u></p>\n<p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>\n<p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p>\n<p></p>\n<h4> 不可重复读（Unrepeatable read）</h4>\n<p><u>一个事务多次读取同一个数据，却返回不同的结果</u></p>\n<p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>\n<p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p>\n<p></p>\n<h4> 幻读（Phantom read）</h4>\n<p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>\n<p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p>\n<p></p>\n<h3> 不可重复读和幻读有什么区别？</h3>\n<ul>\n<li><u>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</u></li>\n<li><u>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</u></li>\n</ul>\n<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p>\n<p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p>\n<h3> 并发事务的控制方式有哪些？</h3>\n<p><code>MySQL </code>中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。<u>锁可以看作是悲观控制的模式</u>，多版本并发控制（<code>MVCC，Multiversion concurrency control</code>）可以看作是<u>乐观控制的模式</u>。</p>\n<p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，<code>MySQL</code> 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p>\n<ul>\n<li><u>共享锁（S 锁）：又称读锁</u> ，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>\n<li><u>排他锁（X 锁）：又称写锁/独占锁</u>，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li>\n</ul>\n<p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁(table-level locking)</strong> 和 <strong>行级锁(row-level locking)</strong> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</p>\n<p><strong>MVCC</strong> 是多版本并发控制方法，即<u>对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本</u>。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p>\n<p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p>\n<ul>\n<li><code>undo log : undo log </code>用于记录某行数据的多个版本的数据。</li>\n<li><code>read view</code> 和 隐藏字段 : 用来判断当前版本数据的可见性。</li>\n</ul>\n<p>关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：<a href=\"https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html\" target=\"_blank\" rel=\"noopener noreferrer\">InnoDB 存储引擎对 MVCC 的实现</a> 。</p>\n<h3> SQL 标准定义了哪些事务隔离级别?</h3>\n<p>SQL 标准定义了四个隔离级别：</p>\n<ul>\n<li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>\n<li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>\n<li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>\n<li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>\n</ul>\n<hr>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">隔离级别</th>\n<th style=\"text-align:center\">脏读</th>\n<th style=\"text-align:center\">不可重复读</th>\n<th style=\"text-align:center\">幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">READ-UNCOMMITTED</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">READ-COMMITTED</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">REPEATABLE-READ</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SERIALIZABLE</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n</tr>\n</tbody>\n</table>\n<h3> MySQL 的隔离级别是基于锁实现的吗？</h3>\n<p>MySQL 的<u>隔离级别基于锁和 MVCC 机制共同实现的</u>。</p>\n<p><code>SERIALIZABLE</code> 隔离级别是通过锁来实现的，</p>\n<p><code>READ-COMMITTED</code> 和 <code>REPEATABLE-READ </code>隔离级别是基于 MVCC 实现的。不过，</p>\n<p><code>SERIALIZABLE</code> 之外的其他隔离级别可能也需要用到锁机制，就比如 <code>REPEATABLE-READ</code> 在当前读情况下需要使用加锁读来保证不会出现幻读。</p>\n<h3> MySQL 的默认隔离级别是什么?</h3>\n<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：<a href=\"https://javaguide.cn/database/mysql/transaction-isolation-level.html\" target=\"_blank\" rel=\"noopener noreferrer\">MySQL 事务隔离级别详解</a>。</p>\n",
      "date_modified": "2023-08-03T23:47:31.087Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "常见面试题",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/db/mysql/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98.html",
      "summary": "参考 mysql 使用inet_aton和inet_ntoa处理ip地址数据 分析MySQL数据类型的长度",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://blog.csdn.net/fdipzone/article/details/49532127\" target=\"_blank\" rel=\"noopener noreferrer\">mysql 使用inet_aton和inet_ntoa处理ip地址数据</a></p>\n<p><a href=\"https://developer.aliyun.com/article/552852\" target=\"_blank\" rel=\"noopener noreferrer\">分析MySQL数据类型的长度</a></p>\n</div>\n<h2> MySQL 基础</h2>\n<h3> 什么是关系型数据库？</h3>\n<p>顾名思义，关系型数据库（<code>RDBMS，Relational Database Management System</code>）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（<code>一对一、一对多、多对多</code>）。</p>\n<p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p>\n<p>大部分关系型数据库都使用 <code>SQL</code> 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(<code>ACID</code>)。</p>\n<p><strong>有哪些常见的关系型数据库呢？</strong></p>\n<p><code>MySQL、PostgreSQL、Oracle、SQL Server、SQLite</code>（微信本地的聊天记录的存储就是用的 SQLite） ......。</p>\n<h3> MySQL 有什么优点？</h3>\n<p>这个问题本质上是在问 MySQL 如此流行的原因。</p>\n<p>MySQL 主要具有下面这些优点：</p>\n<ol>\n<li>成熟稳定，功能完善。</li>\n<li>开源免费。</li>\n<li>文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li>\n<li>开箱即用，操作简单，维护成本低。</li>\n<li>兼容性好，支持常见的操作系统，支持多种开发语言。</li>\n<li>社区活跃，生态完善。</li>\n<li>事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li>\n<li>支持分库分表、读写分离、高可用。</li>\n</ol>\n<h2> MySQL 基础架构</h2>\n<blockquote>\n<p>建议配合 <a href=\"/interview/db/mysql/emphasis/mysql-execute.html\" target=\"blank\">SQL的执行过程</a> 这篇文章来理解 MySQL 基础架构。另外，“一个 SQL 语句在 MySQL 中的执行流程”也是面试中比较常问的一个问题。</p>\n</blockquote>\n<p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p>\n<p></p>\n<p>从上图可以看出， MySQL 主要由下面几部分构成：</p>\n<ul>\n<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>\n<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>\n<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>\n<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>\n<li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li>\n<li><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>\n</ul>\n<h2> MySQL 存储引擎</h2>\n<p>MySQL 核心在于存储引擎，想要深入学习 MySQL，必定要深入研究 MySQL 存储引擎。</p>\n<h3> MySQL 支持哪些存储引擎？默认使用哪个？</h3>\n<p>MySQL 支持多种存储引擎，你可以通过 <code>show engines</code> 命令来查看 MySQL 支持的所有存储引擎。</p>\n<p></p>\n<p>从上图我们可以查看出， MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p>\n<p>我这里使用的 MySQL 版本是 8.x，不同的 MySQL 版本之间可能会有差别。</p>\n<p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>\n<p>你可以通过 <code>select version()</code> 命令查看你的 MySQL 版本。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>你也可以通过 <code>show variables like '%storage_engine%'</code> 命令直接查看 MySQL 当前默认的存储引擎。</p>\n<p></p>\n<h3> MySQL 存储引擎架构了解吗？</h3>\n<p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p>\n<p>并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。</p>\n<h3> MyISAM 和 InnoDB 有什么区别？</h3>\n<p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p>\n<p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p>\n<p>MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>\n<p>言归正传！咱们下面还是来简单对比一下两者：</p>\n<p><strong>1.是否支持行级锁</strong></p>\n<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>\n<p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p>\n<p><strong>2.是否支持事务</strong></p>\n<p>MyISAM 不提供事务支持。</p>\n<p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，<u>InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）</u>。</p>\n<p><strong>3.是否支持外键</strong></p>\n<p>MyISAM 不支持，而 InnoDB 支持。</p>\n<p><u>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗</u>。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，<u>在业务代码中进行约束即可！</u></p>\n<p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p>\n<p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p>\n<p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p>\n<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>\n<p>MyISAM 不支持，而 InnoDB 支持。</p>\n<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>\n<p><strong>5.是否支持 MVCC</strong></p>\n<p>MyISAM 不支持，而 InnoDB 支持。</p>\n<p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p>\n<p><strong>6.索引实现不一样。</strong></p>\n<p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p>\n<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p>\n<p>详细区别：<a href=\"/interview/db/mysql/emphasis/mysql-index.html\" target=\"blank\">MySQL索引详解</a>。</p>\n<p><strong>7.性能有差别。</strong></p>\n<p>InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。</p>\n<p><strong>总结</strong> ：</p>\n<ul>\n<li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li>\n<li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li>\n<li>MyISAM 不支持外键，而 InnoDB 支持。</li>\n<li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li>\n<li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li>\n<li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li>\n<li>InnoDB 的性能比 MyISAM 更强大。</li>\n</ul>\n<h3> MyISAM 和 InnoDB 如何选择？</h3>\n<p>大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）。</p>\n<p>《MySQL 高性能》上面有一句话这样写到:</p>\n<blockquote>\n<p>不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p>\n</blockquote>\n<p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p>\n<p>因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。</p>\n<h2> MySQL 索引</h2>\n<p>MySQL 索引相关的问题比较多，对于面试和工作都比较重要，于是，我单独抽了一篇文章专门来总结 MySQL 索引相关的知识点和问题： <a href=\"/interview/db/mysql/emphasis/mysql-index.html\" target=\"blank\">MySQL索引详解</a> 。</p>\n<h2> MySQL 查询缓存</h2>\n<p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p>\n<p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p>\n<div class=\"language-properties line-numbers-mode\" data-ext=\"properties\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>MySQL 执行以下命令也可以开启查询缓存</p>\n<div class=\"language-properties line-numbers-mode\" data-ext=\"properties\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。</p>\n<p><strong>查询缓存不命中的情况：</strong></p>\n<ol>\n<li>任何两个查询在任何字符上的不同都会导致缓存不命中。</li>\n<li>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li>\n<li>缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</li>\n</ol>\n<p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，<strong>还可以通过 <code>sql_cache</code> 和 <code>sql_no_cache</code> 来控制某个查询语句是否需要缓存：</strong></p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h2> MySQL 日志</h2>\n<ul>\n<li>MySQL 中常见的日志有哪些？</li>\n<li>慢查询日志有什么用？</li>\n<li>binlog 主要记录了什么？</li>\n<li>redo log 如何保证事务的持久性？</li>\n<li>页修改之后为什么不直接刷盘呢？</li>\n<li>binlog 和 redolog 有什么区别？</li>\n<li>undo log 如何保证事务的原子性？</li>\n<li>......</li>\n</ul>\n<h2> MySQL 性能优化</h2>\n<p>关于 MySQL 性能优化的建议总结，请看这篇文章：<a href=\"/interview/db/mysql/mysql-optimization.html\" target=\"blank\">MySQL高性能优化</a> 。</p>\n<h3> 能用 MySQL 直接存储文件（比如图片）吗？</h3>\n<p>可以是可以，直接存储文件对应的二进制数据即可。不过，还是建议不要在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。</p>\n<h3> MySQL 如何存储 IP 地址？</h3>\n<p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。</p>\n<p>MySQL 提供了两个方法来处理 ip 地址</p>\n<ul>\n<li><code>INET_ATON()</code> ： 把 ip 转为无符号整型 (4-8 位)</li>\n<li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li>\n</ul>\n<p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p>\n<p>数据库中保存ip地址，字段一般会定义为：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>因为ip地址<code>(255.255.255.255)</code>的最大长度是<code>15</code>，使用<code>15</code>位<code>char</code>已足够。</p>\n<p><code>inet_aton</code> 把<code>ip</code>转为无符号整型(<code>4-8位</code>)</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> mysql 数据类型及长度</h2>\n<p>mysql有几种数据类型可以限制类型的\"长度\"，有\n<code>CHAR(Length)</code>、<code>VARCHAR(Length)</code>、</p>\n<p><code>TINYINT(Length)</code>、<code>SMALLINT(Length)</code>、<code>MEDIUMINT(Length)</code>、<code>INT(Length)</code>、<code>BIGINT(Length)</code>、</p>\n<p><code>FLOAT(Length, Decimals)</code>、<code>DOUBLE(Length, Decimals)</code>和<code>DECIMAL(Length, Decimals)</code>。</p>\n<p>然而，这些<u>数据类型的长度，并不是都指数据的大小</u>。具体说就是：</p>\n<p>（1）<code>CHAR、VARCAHR</code>的长度是指<code>字符的长度</code>，例如<code>CHAR[3]</code>则只能放字符串\"123\"，如果插入数据\"1234\"，则从高位截取，变为\"123\"。 VARCAHR同理。</p>\n<p>（2）<code>TINYINT、SMALLINT、MEDIUMINT、INT</code>和<code>BIGINT</code>的长度，其实和数据的大小无关！Length指的是显示宽度，</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>id的显示宽度为3，不足的左边补0，数据长度超过的则原样输出。如果没有zerofill，则看不出显示宽度，没有前导零。</p>\n<p>3）<code>FLOAT、DOUBLE</code>和<code>DECIMAL</code>的长度指的是<code>全部数位（包括小数点后面的）</code>，例如<code>DECIMAL(4,1)</code>指的是<code>全部位数为4</code>，<code>小数点后1位</code>，如果插入<code>1234</code>，则查询的数据是<code>999.9</code>。过程如下</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p></p>\n<p></p>\n",
      "date_modified": "2023-08-03T23:47:31.093Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "分布式一致性协议",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/distributed/base/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/distributed/base/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.html",
      "summary": "参考 https://segmentfault.com/a/1190000014918849 Nacos集群的CP架构，CAP原则与BASE原则的应用 https://juejin.cn/post/7150662426436829191",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://segmentfault.com/a/1190000014918849\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000014918849</a></p>\n<p><a href=\"https://blog.51cto.com/u_15281317/3008688\" target=\"_blank\" rel=\"noopener noreferrer\">Nacos集群的CP架构，CAP原则与BASE原则的应用</a></p>\n<p><a href=\"https://juejin.cn/post/7150662426436829191\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/7150662426436829191</a></p>\n</div>\n<h2> Raft</h2>\n<h2> Distro</h2>\n",
      "date_modified": "2023-08-03T23:47:31.094Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "分布式理论",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/distributed/base/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/distributed/base/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA.html",
      "summary": "参考 https://segmentfault.com/a/1190000014918849 Nacos集群的CP架构，CAP原则与BASE原则的应用 https://juejin.cn/post/7150662426436829191",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://segmentfault.com/a/1190000014918849\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000014918849</a></p>\n<p><a href=\"https://blog.51cto.com/u_15281317/3008688\" target=\"_blank\" rel=\"noopener noreferrer\">Nacos集群的CP架构，CAP原则与BASE原则的应用</a></p>\n<p><a href=\"https://juejin.cn/post/7150662426436829191\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/7150662426436829191</a></p>\n</div>\n<h2> CAP 理论</h2>\n<p>CAP 理论是分布式系统中最核心的基础理论。</p>\n<ul>\n<li>一致性 (Consistency): 一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。所有节点访问同一份最新的数据。</li>\n</ul>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">一致性的理解</p>\n<p>一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，其他节点上的数据也应该得到更新，并且所有用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性（或严格的一致性，最终一致性）。</p>\n</div>\n<ul>\n<li>可用性 (Availability): 对数据更新具备高可用性，请求能够及时处理，不会一直等待，即使出现节点失效。</li>\n</ul>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">可用性的理解</p>\n<p>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。“有效的时间内”是指，对于用户的一个操作请求，系统必须能够在指定的时间（即响应时间）内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。</p>\n<p>“返回结果”是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确的反映出对请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。</p>\n</div>\n<ul>\n<li>分区容错性 (Partition tolerance): 能容忍网络分区，在网络断开的情况下，被分隔的节点仍能正常对外提供服务。</li>\n</ul>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">分区容错性的理解</p>\n<p>分区容错性约束了一个分布式系统需要具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>\n<p>网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络等）中，由于一些特殊的原因导致这些子网络之间出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。</p>\n</div>\n<h2> 一致性的分类</h2>\n<p>一致性是指从系统外部读取系统内部的数据时，在一定约束条件下相同，即数据变动在系统内部各节点应该是同步的。根据一致性的强弱程度不同，可以将一致性的分类为如下几种：</p>\n<ul>\n<li>\n<p>强一致性：（strong consistency）。任何时刻，任何用户都能读取到最近一次成功更新的数据。</p>\n</li>\n<li>\n<p>单调一致性：（monotonic consistency）。任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说，可获取的数据顺序必是单调递增的。</p>\n</li>\n<li>\n<p>会话一致性：（session consistency）。任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在本次会话中就不会再读到比这值更旧的值，会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障。</p>\n</li>\n<li>\n<p>最终一致性：（eventual consistency）。用户只能读到某次更新后的值，但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障。</p>\n</li>\n<li>\n<p>弱一致性：（weak consistency）。用户无法在确定时间内读到最新更新的值。</p>\n</li>\n</ul>\n<p>在分布式环境中，一致性是指数据在多个副本之间是否能够保持数据一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。例如</p>\n<p>C、A、P 只能同时满足两个目标，而由于在分布式系统中，\nP 是必须要保留的，所以要在 C 和 A 间进行取舍。假如要保证服务的可用性，就选择 AP 模型，而要保证一致性的话，就选择 CP 模型。</p>\n<h3> 如何理解CAP理论</h3>\n<ul>\n<li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>\n<li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。</li>\n<li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>\n</ul>\n<p></p>\n<h2> CAP 案例</h2>\n<h3> zoookeeper</h3>\n<p>ZooKeeper从以下几点保证了数据的一致性</p>\n<ul>\n<li>\n<p>顺序一致性：来自任意特定客户端的更新都会按其发送顺序被提交保持一致。也就是说，如果一个客户端将Znode z的值更新为a，在之后的操作中，它又将z的值更新为b，则没有客户端能够在看到z的值是b之后再看到值a（如果没有其他对z的更新）。</p>\n</li>\n<li>\n<p>原子性：每个更新要么成功，要么失败。这意味着如果一个更新失败，则不会有客户端会看到这个更新的结果。</p>\n</li>\n<li>\n<p>单一系统映像：一个客户端无论连接到哪一台服务器，它看到的都是同样的系统视图。这意味着，如果一个客户端在同一个会话中连接到一台新的服务器，它所看到的系统状态不会比 在之前服务器上所看到的更老。当一台服务器出现故障，导致它的一个客户端需要尝试连接集合体中其他的服务器时，所有滞后于故障服务器的服务器都不会接受该 连接请求，除非这些服务器赶上故障服务器。</p>\n</li>\n<li>\n<p>持久性：一个更新一旦成功，其结果就会持久存在并且不会被撤销。这表明更新不会受到服务器故障的影响。</p>\n</li>\n<li>\n<p>实时性：在特定的一段时间内，客户端看到的系统需要被保证是实时的（在十几秒的时间里）。在此时间段内，任何系统的改变将被客户端看到，或者被客户端侦测到。</p>\n</li>\n</ul>\n<p>在此ZooKeeper保证的是 <mark>CP</mark></p>\n<p>分析：可用性（A:Available）</p>\n<p>不能保证每次服务请求的可用性。任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性；但是它不能保证每次服务请求的可用性（注：也就是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果）。所以说，<u><code>ZooKeeper不能保证服务可用性</code></u>。</p>\n<p>进行leader选举时集群都是不可用。在使用ZooKeeper获取服务列表时，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。所以说，<u><code>ZooKeeper不能保证服务可用性</code></u>。</p>\n<h3> Eureka</h3>\n<p>计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时如果发现连接失败，则会自动切换至其他的节点，只要有一台Eureka还在，就能保证注册服务可用（保证可用性），只不过查到的信息可能不是最新的（不保证一致性）。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p>\n<p>1.Eureka不再从注册列表中移除因为长时间没有收到心跳而应该过期的服务\n2.Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上（即保证当前节点依然可用）\n3.当前网络稳定时，当前实例新的注册信息会被同步到其它节点中 因此，Eureka可以很好的应对因网络故障导致节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</p>\n<h3> nacos</h3>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>临时实例，选择AP架构，使用Distro协议，分布式协议的一种，阿里内部的协议，服务是放在内存中！\n持久实例，选择CP架构，使用Raft协议来实现，点击查看Raft协议详情！服务是放在磁盘中！</p>\n<p></p>\n<h3> 遵循AP原则的框架和中间件</h3>\n<p>有两种支持高可用性的模式: 故障切换（fail-over） 和复制（replication） 。遵循AP原则的框架和中间件，大体都是通过这两种模式来保证服务的高可用性。</p>\n<h2> BASE 理论</h2>\n<p>Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。\n简单来说BASE就是CAP的折中，C A P我三个都要，但不用100%保证每一次原则。</p>\n<h2> 常见面试题</h2>\n<p>什么是脑裂：\n集群（M-S的情况）通常是发生在节点通信不可达(分区)的情况下，集群会分裂成不同的小集群，小集群各自选举出多个master节点的情况。</p>\n<p>nacos和zookeeper是如何避免脑裂的？\nleader选举，要求节点的投票数量&gt;总节点数量/2，即过半数，有这个选举原则保证了集群出现分区，无论如何最多只能有一个小集群选出leader。</p>\n<p>M-S 模式的集群节点个数为何推荐是奇数个？\n首先，偶数个节点的集群一旦出现对半分区(比如4个节点分区成两个节点和两个节点的情况)，整个集群无法选举出leader，集群无法提供服务。\n其次，在容错能力相同的情况下，奇数节点比偶数节约资源。比如，5个节点挂了2个还能选出leader，而6个节点最多也只能挂2个节点才能保证选举出leader。</p>\n",
      "date_modified": "2023-08-03T23:47:31.096Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "mybatis",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/mybatis/mybatis.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/mybatis/mybatis.html",
      "summary": "参考 https://juejin.cn/post/7002503002925826055 https://juejin.cn/post/7002503002925826055",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://juejin.cn/post/7002503002925826055\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/7002503002925826055</a></p>\n<p><a href=\"https://juejin.cn/post/7002503002925826055\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/7002503002925826055</a></p>\n</div>\n<h2> <code>#{}</code>和<code>${}</code>的区别是什么？</h2>\n<p><code>${}</code>是字符串替换，<code>#{}</code>是预处理；</p>\n<p>Mybatis 在处理时，就是把{}直接替换成变量的值。而 Mybatis 在处理 <code>#{}</code>时，会对 sql 语句进行预处理，将 sql 中的 <code>#{}</code>替换为?号，调用 PreparedStatement 的 set 方法来赋值；</p>\n<p>使用 <code>#{}</code>可以有效的防止 SQL 注入，提高系统安全性。</p>\n<h2> Mybatis 执行批量插入，能返回数据库主键列表吗？</h2>\n<p>1️⃣ 对于支持生成自增主键的数据库：增加 useGenerateKeys 和 keyProperty ，<code>&lt;insert&gt;</code>标签属性。</p>\n<p>2️⃣ 不支持生成自增主键的数据库：使用<code>&lt;selectKey&gt;</code>。</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>Mybatis 的版本，官方在这个 3.3.1 版本中加入了批量新增返回主键 id 的功能 。</p>\n</div>\n<h2> 缓存</h2>\n<p>MyBatis 内置了一个强大的事务性查询缓存机制，通过它能够十分方便的配置和定制。默认情况下，MyBatis 默认定义了两级缓存，而且为了提高扩展性，定义了缓存接口 Cache，我们能十分方便的实现 Cache 接口来自定义二级缓存。</p>\n<ul>\n<li>一级缓存：也叫 本地缓存，默认情况下开启的缓存（SqlSession 级别的缓存）；</li>\n<li>二级缓存：基于 namespace 级别的缓存，需要我们手动进行开启和配置；</li>\n</ul>\n<h3> 一级缓存</h3>\n<p>一级缓存也叫 本地缓存，在与数据库同一次会话期间查询到的数据放在本地缓存，当要再次获取相同数据时，直接从缓存获取即可，不用再次和数据库交互。</p>\n<p></p>\n<p>每个 SqlSession 中都有一个 Executor，每个 Executor 中又有一个 LocalCache，当我们进行查询操作时，MyBatis 根据当前执行的语句生成 MapperdStatement，然后在 Local Cache 中进行查询，如果存在（命中），直接返回给用户。若缓存中不存在（未命中），则和数据库交互查询数据，将结果写入 Local Cache，同时返回给用户。</p>\n<h3> 如何使用一级缓存</h3>\n<p>一级缓存即 SqlSession 级别的缓存，和我们之前的 CURD 操作差不多；默认开启</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 一级缓存失效的情况</h3>\n<p>一级缓存是默认一直开启的，我们是关闭不了的。但是有时候一级缓存会出现失效的情况，主要可能是如下几种原因导致；</p>\n<p>1️⃣ 每个 SqlSession 中缓存独立\n当我们使用不同的 SqlSession 时，有多少个 SqlSession 就需要向数据库发起多少次查询请求。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2️⃣ 当前缓存中不存在该数据时</p>\n<p>当位于同一个 SqlSession，但查询条件不同时，也会导致缓存失效；</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>3️⃣ 其他 CURD 操作对当前数据造成影响</p>\n<p>假如在同一 SqlSession 中，在两次查询之间进行了其他的增删改等操作，当第二次查询进行时，就会重新执行 SQL 语句，导致缓存失效</p>\n<p>4️⃣ 手动清除</p>\n<p>当 SqlSession 相同时，如果我们手动清除了缓存，那么也会导致缓存失效的情况出现。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二级缓存</h2>\n<p>也叫 全局缓存，基于 namespace 的缓存，一个 namespace 对应一个二级缓存。</p>\n<p></p>\n<p>一级缓存的最大共享范围是一个 SqlSession 内部，若多个 SqlSession 之间要共享缓存，则需要用二级缓存。二级缓存一旦开启，将会有多个 CachingExecutor 来装饰 Executor，进入一级缓存的查询流程之前，先在 CachingExecutor 中进行二级缓存的查询，如上图。此时数据的查询流程是：</p>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">缓存顺序</p>\n<p>二级缓存 -&gt; 一级缓存 -&gt; 数据库</p>\n</div>\n<h3> 使用二级缓存</h3>\n<p>要使用二级缓存，通常需要有如下步骤：</p>\n<p>1️⃣ 首先在 MyBatis 配置文件（一般是 mybatis-config.xml）中开启二级缓存；</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2️⃣ 然后到对应的 xxxMapper.xml 中配置二级缓存；</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置之后，xxxMapper.xml 文件中的 select 语句将会被缓存，而 insert、update、delete 则会刷新缓存。此外还可以设置自定义属性值来修改默认属性；</p>\n<p></p>\n<h2> fetchSize</h2>\n<p>这两天做到一个需求，需要一次性将一张数据表里的所有资源数据中的位置信息录入到redis中，表中的数据有几百万起步，采用的是java定时任务，循环每次查出一万条数据存入redis，测试时发现插入效率非常慢，经过排查发现是通过mybatis查询数据的耗时超过了总耗时的99%，我这台机器上是每查询一万条数据返回耗时87s左右。\n解决方法：\n在mapper.xml中的<code>&lt;select&gt;</code>中加入fetchSize参数，设置的大一些，如下：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>设置完后一次查询一万条返回由原来的87秒变成了毫秒级别</p>\n<p>通过JDBC取数据时，默认是10条数据取一次，即fetch size为10（根据oracle的文档，默认的fetchSize是10），如果增大这个数字可以减少客户端与oracle的往返，减少响应时间，网上有建议这个数字不要超过100，要不然对中间件内存消耗大。</p>\n<p>总结：\n在使用mybatis一次查询大量数据时确实可以通过怎大 fatchSize 的值来大大提高查询效率，使用也非常简单，具体 fatchSize 设为多少要根据自己具体的业务需要和机器的配置来综合判定。</p>\n<p>todo// mybatis plus 对大数据量查询的支持</p>\n",
      "date_modified": "2023-08-03T23:47:31.106Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "Aop",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/spring/aop.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/spring/aop.html",
      "summary": "参考 参考 https://www.cnblogs.com/lifullmoon/p/14654795.html 什么是 AOP？ AOP（Aspect-oriented Programming）面向切面编程，是一种开发理念，是 OOP 面向对象编程的补充。我们知道，Java 就是一门面向对象编程的语言，在 OOP 中最小的单元就是“Class 对象”，但是在 AOP 中最小的单元是“切面”。一个“切面”可以包含很多种类型和对象，对它们进行模块化管理，例如事务管理",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p>参考 <a href=\"https://www.cnblogs.com/lifullmoon/p/14654795.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.cnblogs.com/lifullmoon/p/14654795.html</a></p>\n</div>\n<h2> 什么是 AOP？</h2>\n<p>AOP（Aspect-oriented Programming）面向切面编程，是一种开发理念，是 OOP 面向对象编程的补充。我们知道，Java 就是一门面向对象编程的语言，在 OOP 中最小的单元就是“Class 对象”，但是在 AOP 中最小的单元是“切面”。一个“切面”可以包含很多种类型和对象，对它们进行模块化管理，例如事务管理</p>\n<h2> 为什么要引入 AOP？</h2>\n<p>Java OOP 存在哪些局限性？</p>\n\n<p>通过 AOP 我们可以把一些非业务逻辑的代码（比如安全检查、监控等代码）从业务中抽取出来，以非入侵的方式与原方法进行协同。这样可以使得原方法更专注于业务逻辑，代码接口会更加清晰，便于维护。</p>\n<h2> 简述 AOP 的使用场景？</h2>\n<p>日志场景</p>\n\n<p>统计场景</p>\n\n<p>安防场景</p>\n\n<p>性能场景</p>\n\n<p>可以说在我们的日常开发环境中都是离不开 AOP 的。</p>\n<p>简述 AOP 中几个比较重要的概念</p>\n<h2> 在 AOP 中有以下几个概念：</h2>\n<ul>\n<li>\n<p>AspectJ：切面，只是一个概念，没有具体的接口或类与之对应，是 Join point，Advice 和 Pointcut 的一个统称。</p>\n</li>\n<li>\n<p>Join point：连接点，指程序执行过程中的一个点，例如<u>方法调用、异常处理</u>等。在 Spring AOP 中，仅支持方法级别的连接点。</p>\n</li>\n<li>\n<p>Advice：通知，即我们定义的一个切面中的横切逻辑，有<u>“around”，“before”和“after”</u>三种类型。在很多的 AOP 实现框架中，Advice 通常作为一个拦截器，也可以包含许多个拦截器作为一条链路围绕着 Join point 进行处理。</p>\n</li>\n<li>\n<p>Pointcut：切点，用于匹配连接点，一个 AspectJ 中包含哪些 Join point 需要由 Pointcut 进行筛选。</p>\n</li>\n<li>\n<p>Introduction：引介，让一个切面可以声明被通知的对象实现任何他们没有真正实现的额外的接口。例如可以让一个代理对象代理两个目标类。</p>\n</li>\n<li>\n<p>Weaving：织入，在有了连接点、切点、通知以及切面，如何将它们应用到程序中呢？没错，就是织入，在切点的引导下，将通知逻辑插入到目标方法上，使得我们的通知逻辑在方法调用时得以执行。</p>\n</li>\n<li>\n<p>AOP proxy：AOP 代理，指在 AOP 实现框架中实现切面协议的对象。在 Spring AOP 中有两种代理，分别是 JDK 动态代理和 CGLIB 动态代理。</p>\n</li>\n<li>\n<p>Target object：目标对象，就是被代理的对象。</p>\n</li>\n</ul>\n<h2> AOP 框架</h2>\n<p>主流 AOP 框架：</p>\n\n<p>Spring AOP 是基于 JDK 动态代理和 Cglib 提升实现的，两种代理方式都属于运行时的一个方式，所以它没有编译时的一个处理，那么因此 Spring 是通过 Java 代码实现的。AspectJ 自己有一个编译器，在编译时期可以修改 .class 文件，在运行时也会进行处理。</p>\n<p>Spring AOP 有别于其他大多数 AOP 实现框架，目的不是提供最完整的 AOP 实现（尽管 Spring AOP 相当强大）；相反，其目的是在 AOP 实现和 Spring IoC 之间提供紧密的集成，以提供企业级核心特性。</p>\n<p>Spring AOP 从未打算与 AspectJ 竞争以提供全面的 AOP 解决方案，我们认为 Spring AOP 等基于代理实现的框架和 AspectJ 等成熟的框架都是有价值的，并且它们是互补的，而不是竞争关系。Spring 将 Spring AOP 和 IoC 与 AspectJ 无缝集成，以实现 AOP 的所有功能都可以在一个 Spring 应用中。这种集成不会影响 Spring AOP API 或 AOP Alliance API，保持向后兼容。</p>\n<h2> AOP 代理</h2>\n<p>代理模式是一种结构性设计模式，通过代理类为其他对象提供一种代理以控制对这个对象的访问。AOP 代理是 AOP 框架中 AOP 的实现，主要分为静态代理和动态代理，如下：</p>\n\n<h2> JDK 动态代理？</h2>\n<p>基于接口代理，通过反射机制生成一个实现代理接口的类，在调用具体方法时会调用 InvocationHandler 来处理。</p>\n<p>需要借助 JDK 的 java.lang.reflect.Proxy 来创建代理对象，调用 Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 方法创建一个代理对象，方法的三个入参分别是：</p>\n\n<p>新生成的代理对象的 Class 对象会继承 Proxy，且实现所有的入参 interfaces 中的接口，在实现的方法中实际是调用入参 InvocationHandler 的 invoke(..) 方法。</p>\n\n<h2> CGLIB 动态代理？</h2>\n<p>JDK 动态代理的目标对象必须是一个接口，在我们日常生活中，无法避免开发人员不写接口直接写类，或者根本不需要接口，直接用类进行表达。这个时候我们就需要通过一些字节码提升的手段，来帮助做这个事情，在运行时，非编译时，来创建一个新的 Class 对象，这种方式称之为字节码提升。在 Spring 内部有两个字节码提升的框架，ASM（过于底层，直接操作字节码）和 CGLIB（相对于前者更加简便）。</p>\n<p>CGLIB 动态代理则是基于类代理（字节码提升），通过 ASM（Java 字节码的操作和分析框架）将被代理类的 class 文件加载进来，修改其字节码生成一个子类。</p>\n<p>需要借助于 CGLIB 的 org.springframework.cglib.proxy.Enhancer 类来创建代理对象，设置以下几个属性：</p>\n\n<p>新生成的代理对象的 Class 对象会继承 superClass 被代理的类，在重写的方法中会调用 callback 回调接口（方法拦截器）进行处理。</p>\n\n<h2> JDK 动态代理和 CGLIB 动态代理有什么不同？</h2>\n<p>两者都是在 JVM 运行时期新创建一个 Class 对象，实例化一个代理对象，对目标类（或接口）进行代理。JDK 动态代理只能基于接口进行代理，生成的代理类实现了这些接口；而 CGLIB 动态代理则是基于类进行代理的，生成的代理类继承目标类，但是不能代理被 final 修饰的类，也不能重写 final 或者 private 修饰的方法。</p>\n<p>CGLIB 动态代理比 JDK 动态代理复杂许多，性能也相对比较差。</p>\n<h2> Spring AOP 和 AspectJ 有什么关联</h2>\n<p>Spring AOP 和 AspectJ 都是 AOP 的实现框架，AspectJ 是 AOP 的完整实现，Spring AOP 则是部分实现。AspectJ 有一个很好的编程模型，包含了注解的方式，也包含了特殊语法。Spring 认为 AspectJ 的实现在 AOP 体系里面是完整的，不需要在做自己的一些实现。</p>\n<p>Spring AOP 整合 AspectJ 注解与 Spring IoC 容器，比 AspectJ 的使用更加简单，也支持 API 和 XML 的方式进行使用。不过 Spring AOP 仅支持方法级别的 Pointcut 拦截。</p>\n\n<h2> Spring AOP 中有哪些 Advice 类型？</h2>\n\n<p>执行顺序（Spring 5.2.7 之前的版本）：Around “前处理” &gt; Before &gt; 方法执行 &gt; Around “后处理” &gt; After &gt; AfterReturning|AfterThrowing</p>\n<p>执行顺序（Spring 5.2.7 开始）：Around “前处理” &gt; Before &gt; 方法执行 &gt; AfterReturning|AfterThrowing &gt; After &gt; Around “后处理”</p>\n<h2> Spring AOP 中 Advisor 接口是什么？</h2>\n<p>Advisor 是 Advice 的一个容器接口，与 Advice 是一对一的关系，它的子接口 PointcutAdvisor 是 Pointcut 和 Advice 的容器接口，将 Pointcut 过滤 Joinpoint 的能力和 Advice 进行整合，这样一来就将两者进行关联起来了。</p>\n<p>Pointcut 提供 ClassFilter 和 MethedMatcher，分别支持筛选类和方法，通过 PointcutAdvisor 和 Advice 进行整合，可以说是形成了一个“切面”。</p>\n<h2> 简述 Spring AOP 自动代理的实现</h2>\n<p>在我们有了 Join point（连接点）、Pointcut（切点）、Advice（通知）以及 AspectJ（切面）后，我们应该如何将他们“织入”我们的应用呢？在 Sping AOP 中提供了自动代理的实现，底层借助 JDK 动态代理和 CGLIB 动态代理创建对象。</p>\n<p>回顾 <code>Spring IoC</code> 中 Bean 的加载过程，在整个过程中，Bean 的实例化前和初始化后等生命周期阶段都提供了扩展点，会调用相应的 <code>BeanPostProcessor</code> 处理器对 Bean 进行处理。当我们开启了 AspectJ 自动代理（例如通过<code>@EnableAspectJAutoProxy</code>注解），则会往 IoC 容器中注册一个 <code>AbstractAutoProxyCreator</code> 自动代理对象，该对象实现了几种 <code>BeanPostProcessor</code>，例如在每个 Bean 初始化后会被调用，解析出当前 Spring 上下文中所有的 Advisor（会缓存），如果这个 Bean 需要进行代理，则会通过 JDK 动态代理或者 <code>CGLIB</code> 动态代理创建一个代理对象并返回，所以得到的这个 Bean 实际上是一个代理对象。这样一来，开发人员只需要配置好 <code>AspectJ</code> 相关信息，<code>Spring</code> 则会进行自动代理，和 <code>Spring IoC</code> 完美地整合在一起。</p>\n<h2> Spring @EnableAspectJAutoProxy 的原理？</h2>\n<p>使用了 <code>@EnableAspectJAutoProxy</code> 注解则会开启 Spring AOP 自动代理，该注解上面有一个 <code>@Import(AspectJAutoProxyRegistrar.class)</code> 注解，<code>AspectJAutoProxyRegistrar</code> 实现了 <code>ImportBeanDefinitionRegistrar</code> 这个接口，在实现的方法中会注册一个 <code>AnnotationAwareAspectJAutoProxyCreator</code> 自动代理对象（如果没有注册的话），且将其优先级设置为最高，同时解析 <code>@EnableAspectJAutoProxy</code> 注解的配置并进行设置。这个自动代理对象是一个 <code>BeanPostProcessor</code> 处理器，在 Spring 加载一个 Bean 的过程中，如果它需要被代理，那么会创建一个代理对象（JDK 动态代理或者 CGLIB 动态代理）。</p>\n<p>除了注解的方式，也可以通过 <code>&lt;aop:aspectj-autoproxy /&gt;</code> 标签开启 Spring AOP 自动代理，原理和注解相同，同样是注册一个自动代理对象。</p>\n",
      "date_modified": "2023-08-03T23:47:31.109Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "生命周期",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/spring/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/spring/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",
      "summary": "参考 https://segmentfault.com/a/1190000040365130 https://juejin.cn/post/7075168883744718856",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://segmentfault.com/a/1190000040365130\" target=\"_blank\" rel=\"noopener noreferrer\">https://segmentfault.com/a/1190000040365130</a></p>\n<p><a href=\"https://juejin.cn/post/7075168883744718856\" target=\"_blank\" rel=\"noopener noreferrer\">https://juejin.cn/post/7075168883744718856</a></p>\n</div>\n<p><code>Spring Bean</code> 的生命周期主要指的是 <code>singleton bean</code>，对于 <code>prototype</code> 的 <code>bean</code> ,<code>Spring</code>\n在创建好交给使用者之后则不会再管理后续的生命周期。</p>\n<h2> Spring 中的 bean 的作用域有哪些?</h2>\n<ul>\n<li><code>singleton</code> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>\n<li><code>prototype</code> : 每次请求都会创建一个新的 bean 实例。</li>\n<li><code>request </code>: 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>\n<li><code>session</code> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>\n<li><code>global-session</code>： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。\n<code>Portlet</code> 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>\n</ul>\n<p>对于普通的 Java 对象来说，它们的生命周期就是：</p>\n<ul>\n<li>实例化</li>\n<li>该对象不再被使用时通过垃圾回收机制进行回收</li>\n</ul>\n<p>而对于 Spring Bean 的生命周期来说：</p>\n<ul>\n<li>实例化 <code>Instantiation</code></li>\n<li>属性赋值 <code>Populate</code></li>\n<li>初始化 <code>Initialization</code></li>\n<li>销毁 <code>Destruction</code></li>\n</ul>\n<h3> Bean 创建流程入口</h3>\n<p>AbstractApplicationContext#refresh() 方法的 finishBeanFactoryInitialization(beanFactory)</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>至于销毁，是在容器关闭时调用的，详见 <code>ConfigurableApplicationContext#close()</code></p>\n<p>是不是很清爽了？至于 <code>BeanPostProcessor、BeanFactoryPostProcessor</code> 以及其他的类,只不过是对主流程四个步骤的一系列扩展点而已。</p>\n<h2> Spring Bean 的生命周期的扩展点</h2>\n<p><code>Spring Bean</code> 的生命周期的扩展点超级多，不可能全部列出来，只说核心的扩展点。\n这也就是为什么 <code>Spring</code> 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，\n用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p>\n<h3> Bean 自身的方法</h3>\n<p>比如<code>构造函数</code>、<code>getter/setter</code> 以及 <code>init-method</code> 和 <code>destory-method</code> 所指定的方法等，\n也就对应着上文说的<code>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</code>四个阶段。</p>\n<h3> 容器级的方法（BeanPostProcessor 一系列接口）</h3>\n<p>主要是后处理器方法，比如下图的 <code>InstantiationAwareBeanPostProcessor</code>、<code>BeanPostProcessor</code> 接口方法。这些接口的实现类是独立于 <code>Bean</code> 的，并且会注册到 <code>Spring</code> 容器中。在 <code>Spring</code> 容器创建任何 <code>Bean</code> 的时候，这些后处理器都会发生作用。</p>\n<p></p>\n<h3> InstantiationAwareBeanPostProcessor 源码分析</h3>\n<p><code>InstantiationAwareBeanPostProcessor </code>是继承了 <code>BeanPostProcessor</code></p>\n<p></p>\n<h3> 工厂后处理器方法（BeanFactoryProcessor 一系列接口）</h3>\n<p>包括 <code>AspectJWeavingEnabler</code> 、<code>CustomAutowireConfigurer</code> 、<code>ConfigurationClassPostProcessor</code> 等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能。</p>\n<p>我们知道 <code>Spring IoC</code> 容器初始化的关键环节就在\n<code>org.springframework.context.support.AbstractApplicationContext#refresh </code>方法中 ，容器创建的主体流程都在这个方法里面，这个方法是真的重要！！！</p>\n<p>对于工厂后处理器方法这里看 <code>invokeBeanFactoryPostProcessors(beanFactory)</code>; 方法，这个方法处理的是 <code>BeanFactoryPostProcessor</code> 接口的 Bean。调用方法如下：</p>\n<p></p>\n<h2> Bean 级生命周期方法</h2>\n<p>可以理解为 <code>Bean</code> 类直接实现接口的方法，比如 <code>BeanNameAware、BeanFactoryAware、ApplicationContextAware、InitializingBean、DisposableBean</code> 等方法，这些方法只对当前 <code>Bean</code> 生效。</p>\n<h3> Aware 类型的接口</h3>\n<p><code>Aware</code> 类型的接口的作用就是让我们能够拿到 <code>Spring</code> 容器中的一些资源。基本都能够见名知意，<code>Aware</code> 之前的名字就是可以拿到什么资源，例如 <code>BeanNameAware</code> 可以拿到 BeanName，以此类推。</p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>调用时机需要注意：所有的 Aware 方法都是在<u>初始化阶段之前调用</u>的。</p>\n</div>\n<p><code>Aware</code> 接口众多，这里同样通过分类的方式帮助大家记忆。<code>Aware</code> 接口具体可以分为两组，\n至于为什么这么分，详见下面的源码分析。如下排列顺序同样也是 Aware 接口的执行顺序，能够见名知意的接口不再解释。</p>\n<p><code>Aware Group1</code></p>\n<ul>\n<li><code>BeanNameAware</code></li>\n<li><code>BeanClassLoaderAware</code></li>\n<li><code>BeanFactoryAware</code></li>\n</ul>\n<p><code>Aware Group2</code></p>\n<ul>\n<li><code>EnvironmentAware</code></li>\n<li><code>EmbeddedValueResolverAware</code>\n这个知道的人可能不多，实现该接口能够获取 <code>Spring EL </code>解析器，用户的自定义注解需要支持 <code>SPEL</code> 表达式的时候可以使用，非常方便。</li>\n<li><code>ApplicationContextAware(ResourceLoaderAware/ApplicationEventPublisherAware/MessageSourceAware)</code>\n这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的 <code>ApplicationContext</code> 对象，因为 ApplicationContext 是一个复合接口，如下：</li>\n</ul>\n<p></p>\n<p>调用时机</p>\n<p></p>\n<p>可以看到并不是所有的 <code>Aware</code> 接口都使用同样的方式调用。<code>Bean××Aware</code> 都是在代码中直接调用的，\n而 <code>ApplicationContext</code> 相关的 <code>Aware</code> 都是通过 <code>BeanPostProcessor#postProcessBeforeInitialization()</code> 实现的。\n感兴趣的可以自己看一下 <code>ApplicationContextAwareProcessor</code> 这个类的源码，就是判断当前创建的 <code>Bean</code> 是否实现了相关的 <code>Aware</code> 方法，如果实现了会调用回调方法将资源传递给 <code>Bean</code>。</p>\n<p><code>BeanPostProcessor</code> 的调用时机也能在这里体现，包围住 <code>invokeInitMethods</code> 方法，也就说明了在初始化阶段的前后执行。</p>\n<p>关于 <code>Aware</code> 接口的执行顺序，其实只需要记住第一组在第二组执行之前就行了。</p>\n<h2> 生命周期接口</h2>\n<p>至于剩下的两个生命周期接口就很简单了，实例化和属性赋值都是 <code>Spring</code> 帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段。</p>\n<p>1️⃣ <code>InitializingBean</code> 对应生命周期的初始化阶段，在上面源码的 <code>invokeInitMethods(beanName, wrappedBean, mbd);</code>方法中调用。</p>\n<p>有一点需要注意，因为 <code>Aware</code> 方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用 <code>Aware</code> 接口获取的资源，\n这也是我们自定义扩展 <code>Spring</code> 的常用方式。\n除了实现 <code>InitializingBean</code> 接口之外还能通过注解或者 <code>xml</code> 配置的方式指定初始化方法，\n至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</p>\n<p>2️⃣ <code>DisposableBean</code> 类似于 <code>InitializingBean</code>，对应生命周期的销毁阶段，以 <code>ConfigurableApplicationContext#close()</code>方法作为入口，实现是通过循环取所有实现了 <code>DisposableBean</code> 接口的 <code>Bean</code> 然后调用其 <code>destroy() </code>方法。</p>\n<h2> Spring Bean 生命周期流程图</h2>\n<p></p>\n<h2> 常用接口说明</h2>\n<p>1️⃣ <code>BeanNameAware</code></p>\n<p>该接口只有一个方法 <code>setBeanName(String name)</code>，用来获取 <code>bean</code> 的 <code>id</code> 或者 <code>name。</code></p>\n<p>2️⃣ <code>BeanFactoryAware</code></p>\n<p>该接口只有一个方法 <code>setBeanFactory(BeanFactory beanFactory)</code>，用来获取当前环境中的 <code>BeanFactory。</code></p>\n<p>3️⃣ <code>ApplicationContextAware</code></p>\n<p>该接口只有一个方法 <code>setApplicationContext(ApplicationContext applicationContext)</code>，用来获取当前环境中的 <code>ApplicationContext。</code></p>\n<p>4️⃣ <code>InitializingBean</code></p>\n<p>该接口只有一个方法 <code>afterPropertiesSet()</code>，在属性注入完成后调用。</p>\n<p>5️⃣ <code>DisposableBean</code></p>\n<p>该接口只有一个方法<code> destroy()</code>，在容器销毁的时候调用，在用户指定的 <code>destroy-method</code> 之前调用。</p>\n<p>6️⃣ <code>BeanPostProcessor</code></p>\n<p>该接口有两个方法：</p>\n\n<p>通过方法签名我们可以知道，我们可以通过 beanName 来筛选出我们需要进行个性化定制的 bean。</p>\n<p>7️⃣ <code>InstantiationAwareBeanPostProcessor</code></p>\n<p>该类是 <code>BeanPostProcessor</code> 的子接口，常用的有如下三个方法：</p>\n\n",
      "date_modified": "2023-08-03T23:47:31.115Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "事务",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/spring/%E4%BA%8B%E5%8A%A1.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/spring/%E4%BA%8B%E5%8A%A1.html",
      "summary": "参考提示 \"Spring事务失效的12个场景我劝碰到过，太巧了！\" spring事务传播机制",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考提示</p>\n<p><a href=\"https://z.itpub.net/article/detail/18A4D9564A61EC7AF8EAA66FCA251444\" target=\"_blank\" rel=\"noopener noreferrer\">\"Spring事务失效的12个场景我劝碰到过，太巧了！\"</a></p>\n<p><a href=\"https://www.cnblogs.com/vipstone/p/16735893.html\" target=\"_blank\" rel=\"noopener noreferrer\">spring事务传播机制</a></p>\n</div>\n<h2> 传播机制，有哪些？</h2>\n<p>Spring 事务传播机制可使用\n<code>@Transactional(propagation=Propagation.REQUIRED)</code> 来定义，Spring 事务传播机制的级别包含以下 7 种：</p>\n<ul>\n<li>Propagation.REQUIRED：默认的事务传播级别，它表示如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>\n<li>Propagation.SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>\n<li>Propagation.MANDATORY：（mandatory：强制性）如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>\n<li>Propagation.REQUIRES_NEW：表示创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，\nPropagation.REQUIRES_NEW 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li>\n<li>Propagation.NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>\n<li>Propagation.NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li>\n<li>Propagation.NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 PROPAGATION_REQUIRED。</li>\n</ul>\n<p></p>\n<h2> spring 事务失效</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p></p>\n<h3> 访问权限问题</h3>\n<p>众所周知，java的访问权限主要有四种：<code>private、default、protected、public</code>，它们的权限从左到右，依次变大。\n但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们可以看到add方法的访问权限被定义成了private，这样会导致事务失效，spring要求被代理方法必须是public的。\n说白了，在 <br>\n<code>AbstractFallbackTransactionAttributeSource</code> 类的 <code>computeTransactionAttribute</code> 方法中有个判断，如果目标方法不是public，则<code>TransactionAttribute</code> 返回 null，即不支持事务。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是<code> public</code>，而是 <code>private、default</code>或 <code>protected</code> 的话，<code>spring</code> 则不会提供事务功能。</p>\n<h3> 方法用 <code>final</code> 修饰</h3>\n<p>有时候，某个方法不想被子类重新，这时可以将该方法定义成 <code>final</code> 的。普通方法这样定义是没问题的，但如果将事务方法定义成 <code>final</code> ，例如：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们可以看到add方法被定义成了 <code>final</code> 的，这样会导致事务失效。</p>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">为什么？</p>\n<p>如果你看过spring事务的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。</p>\n</div>\n<p>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p>\n</div>\n<h3> 方法内部调用</h3>\n<p>有时候我们需要在某个 <code>Service</code> 类的某个方法中，调用另外一个事务方法，比如：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们看到在事务方法<code>add</code>中，直接调用事务方法 <code>updateStatus</code>。从前面介绍的内容可以知道，<code>updateStatus</code>方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了<code>this</code>对象的方法，所以<code>updateStatus</code>方法不会生成事务。\n由此可见，在同一个类中的方法直接内部调用，会导致事务失效。\n那么问题来了，如果有些场景，确实想在同一个类的某个方法中，调用它自己的另外一个方法，该怎么办呢？</p>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">新加一个 Service 方法</p>\n</div>\n<p>这个方法非常简单，只需要新加一个Service方法，把@Transactional注解加到新 <code>Service</code> 方法上，把需要事务执行的代码移到新方法中。具体代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"hint-container info\">\n<p class=\"hint-container-title\">在该Service类中注入自己</p>\n</div>\n<p>如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？\n答案：不会。\n其实spring ioc内部的三级缓存保证了它，不会出现循环依赖问题。但有些坑，如果你想进一步了解循环依赖问题，可以看看我之前文章《spring：我是如何解决循环依赖的？》。</p>\n<h3> 通过AopContent类</h3>\n<p>在该Service类中使用AopContext.currentProxy()获取代理对象\n上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 未被spring管理</h3>\n<p>在我们平时开发过程中，有个细节很容易被忽略。即使用spring事务的前提是：对象要被spring管理，需要创建bean实例。\n通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。\n当然创建bean实例的方法还有很多，有兴趣的小伙伴可以看看我之前写的另一篇文章《@Autowired的这些骚操作，你都知道吗？》</p>\n<h3> 多线程调用</h3>\n<p>在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。\n这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。\n如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。</p>\n<h3> 表不支持事务</h3>\n<p>周所周知，在mysql5之前，默认的数据库引擎是myisam。\n它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。\n有些老项目中，可能还在用它。\n在创建表的时候，只需要把ENGINE参数设置成MyISAM即可</p>\n<h3> 未开启事务</h3>\n<p>如果你使用的是springboot项目，那么你很幸运。因为springboot通过DataSourceTransactionManagerAutoConfiguration类，已经默默的帮你开启了事务。\n你所要做的事情很简单，只需要配置spring.datasource相关参数即可。\n但如果你使用的还是传统的spring项目，则需要在applicationContext.xml文件中，手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>默默的说一句，如果在pointcut标签中的切入点匹配规则，配错了的话，有些类的事务也不会生效。</p>\n<h2> 事务不回滚</h2>\n<h3> 错误的传播特性</h3>\n<p>其实，我们在使用 <code>@Transactional</code> 注解时，是可以指定 <code>propagation</code> 参数的。\n该参数的作用是指定事务的传播特性，<code>spring</code> 目前支持7种传播特性：</p>\n<ul>\n<li><code>REQUIRED</code> 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。</li>\n<li><code>SUPPORTS</code> 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。</li>\n<li><code>MANDATORY</code> 如果当前上下文中存在事务，否则抛出异常。</li>\n<li><code>REQUIRES_NEW</code> 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。</li>\n<li><code>NOT_SUPPORTED</code> 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。</li>\n<li><code>NEVER</code> 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。</li>\n<li><code>NESTED</code> 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。</li>\n</ul>\n<p>如果我们在手动设置 <code>propagation</code> 参数的时候，把传播特性设置错了，比如：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。\n目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。</p>\n<h3> 自己吞了异常</h3>\n<p>事务不会回滚，常见的问题是：开发者在代码中手动try...catch了异常。比如：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种情况下spring事务当然不会回滚，因为开发者自己捕获了异常，又没有手动抛出，换句话说就是把异常吞掉了。\n如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p>\n<h3> 手动抛了别的异常</h3>\n<p>即使开发者没有手动捕获异常，但如果抛的异常不正确，spring事务也不会回滚。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。\n因为spring事务，默认情况下只会回滚RuntimeException（运行时异常）和Error（错误），对于普通的Exception（非运行时异常），它不会回滚。</p>\n<h3> 自定义了回滚异常</h3>\n<p>在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置rollbackFor参数，来完成这个功能。</p>\n<p>但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了 <code>SqlException、DuplicateKeyException</code> 等异常。而 <code>BusinessException</code> 是我们自定义的异常，报错的异常不属于 <code>BusinessException</code>，所以事务也不会回滚。</p>\n<p>即使 <code>rollbackFor</code> 有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。\n这是为什么呢？\n因为如果使用默认值，一旦程序抛出了 <code>Exception</code>，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：<code>Exception或Throwable</code>。</p>\n<h3> 嵌套事务回滚多了</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这种情况使用了嵌套的内部事务，原本是希望调用 <code>roleService.doOtherThing</code> 方法时，如果出现了异常，只回滚 <code>doOtherThing</code> 方法里的内容，不回滚 <code>userMapper</code>.<code>insertUser</code> 里的内容，即回滚保存点。。但事实是，insertUser也回滚了。</p>\n<p>why?\n因为 <code>doOtherThing</code> 方法出现了异常，没有手动捕获，会继续往上抛，到外层 <code>add</code> 方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。\n怎么样才能只回滚保存点呢？</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以将内部嵌套事务放在 <code>try/catch</code> 中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。</p>\n<h2> 其他</h2>\n<h3> 大事务问题</h3>\n<p>在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。\n通常情况下，我们会在方法上@Transactional注解，填加事务功能，比如：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但 <code>@Transactional</code> 注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。\n上面的这个例子中，在UserService类中，其实只有这两行才需要事务：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在RoleService类中，只有这一行需要事务：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>现在的这种写法，会导致所有的 <code>query</code> 方法也被包含在同一个事务当中。\n如果 <code>query</code> 方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。</p>\n<p></p>\n<h3> 编程式事务</h3>\n<p>上面聊的这些内容都是基于 <code> @Transactional</code> 注解的，主要说的是它的事务问题，我们把这种事务叫做：声明式事务。\n其实，<code>spring</code> 还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，我们把这种事务叫做：编程式事务。例如：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在<code>spring</code>中为了支持编程式事务，专门提供了一个类：<code>TransactionTemplate</code>，在它的<code>execute</code>方法中，就实现了事务的功能。\n相较于<code>@Transactional</code>注解声明式事务，我更建议大家使用，基于<code>TransactionTemplate</code>的编程式事务。主要原因如下：</p>\n<ul>\n<li>避免由于 <code>spring aop</code> 问题，导致事务失效的问题。</li>\n<li>能够更小粒度的控制事务的范围，更直观。</li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:31.136Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "常用注解及接口",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/spring/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%8F%8A%E6%8E%A5%E5%8F%A3.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/spring/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%8F%8A%E6%8E%A5%E5%8F%A3.html",
      "summary": "提示 参考 \"Spring事务失效的12个场景我劝碰到过，太巧了！\"",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>参考 <a href=\"https://z.itpub.net/article/detail/18A4D9564A61EC7AF8EAA66FCA251444\" target=\"_blank\" rel=\"noopener noreferrer\">\"Spring事务失效的12个场景我劝碰到过，太巧了！\"</a></p>\n</div>\n",
      "date_modified": "2023-08-03T23:47:31.137Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "循环依赖",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/framework/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.html",
      "summary": "提示 参考 \"spring：我是如何解决循环依赖的？\" 说清楚Spring如何解决循环依赖？ 如何解决循环依赖问题",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<p>参考 <a href=\"https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;mid=2247490271&amp;idx=1&amp;sn=e4476b631c48882392bd4cd06d579ae9&amp;source=41#wechat_redirect\" target=\"_blank\" rel=\"noopener noreferrer\">\"spring：我是如何解决循环依赖的？\"</a></p>\n<p><a href=\"https://www.modb.pro/db/215134\" target=\"_blank\" rel=\"noopener noreferrer\">说清楚Spring如何解决循环依赖？</a></p>\n<p><a href=\"https://juejin.cn/post/6895753832815394824\" target=\"_blank\" rel=\"noopener noreferrer\">如何解决循环依赖问题</a></p>\n</div>\n<h2> 循环依赖问题在Spring中主要有三种情况：</h2>\n<ul>\n<li>通过构造方法进行依赖注入时产生的循环依赖问题。</li>\n<li>通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。</li>\n<li>通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。</li>\n</ul>\n<p>注意：在Spring中，<u>只有【第三种方式】的循环依赖问题被解决了</u>，其他两种方式在遇到循环依赖问题时都会产生异常。</p>\n<p>第一种构造方法注入的情况下，在new对象的时候就会堵塞住了，其实也就是”先有鸡还是先有蛋“的历史难题。</p>\n<p>第二种setter方法&amp;&amp;多例的情况下，每一次<code>getBean()</code>时，都会产生一个新的<code>Bean</code>，如此反复下去就会有无穷无尽的Bean产生了，\n最终就会导致<code>OOM</code>问题的出现。</p>\n<h2> getBean 过程</h2>\n<p></p>\n<h2> 原因代码</h2>\n<p>先看看当时出问题的代码片段：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这两段代码中定义了两个Service类：TestService1和TestService2，在TestService1中注入了TestService2的实例，同时在TestService2中注入了TestService1的实例，这里构成了循环依赖。</p>\n<p>只不过，这不是普通的循环依赖，因为TestService1的test1方法上加了一个@Async注解。</p>\n<p>大家猜猜程序启动后运行结果会怎样？</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>报错了。。。原因是出现了循环依赖。</p>\n<p>「不科学呀，spring不是号称能解决循环依赖问题吗，怎么还会出现？」\n如果把上面的代码稍微调整一下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>把TestService1的test1方法上的@Async注解去掉，TestService1和TestService2都需要注入对方的实例，同样构成了循环依赖。</p>\n<p>但是重新启动项目，发现它能够正常运行。这又是为什么？</p>\n<p>带着这两个问题，让我们一起开始spring循环依赖的探秘之旅。</p>\n<h2> 什么是循环依赖？</h2>\n<p>循环依赖：说白是一个或多个对象实例之间存在直接或间接的依赖关系，这种依赖关系构成了构成一个环形调用。</p>\n<p>第一种情况：自己依赖自己的直接依赖</p>\n<p></p>\n<p>第二种情况：两个对象之间的直接依赖</p>\n<p></p>\n<p>第三种情况：多个对象之间的间接依赖</p>\n<p></p>\n<p>前面两种情况的直接循环依赖比较直观，非常好识别，但是第三种间接循环依赖的情况有时候因为业务代码调用层级很深，不容易识别出来。</p>\n<h2> 循环依赖的N种场景</h2>\n<p>spring中出现循环依赖主要有以下场景：</p>\n<p></p>\n<h3> 单例的setter注入</h3>\n<p>这种注入方式应该是spring用的最多的，代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这是一个经典的循环依赖，但是它能正常运行，得益于spring的内部机制，让我们根本无法感知它有问题，因为spring默默帮我们解决了。</p>\n<p>spring内部有三级缓存：</p>\n<ul>\n<li>singletonObjects 一级缓存，用于保存实例化、注入、初始化完成的bean实例</li>\n<li>earlySingletonObjects 二级缓存，用于保存实例化完成的bean实例</li>\n<li>singletonFactories 三级缓存，用于保存bean创建工厂，以便于后面扩展有机会创建代理对象。</li>\n</ul>\n<p>下面用一张图告诉你，spring是如何解决循环依赖的：</p>\n<p></p>\n<p>细心的朋友可能会发现在这种场景中第二级缓存作用不大。</p>\n<p>那么问题来了，为什么要用第二级缓存呢？</p>\n<p>试想一下，如果出现以下这种情况，我们要如何处理？</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>TestService1依赖于TestService2和TestService3，而TestService2依赖于TestService1，同时TestService3也依赖于TestService1。</p>\n<p>按照上图的流程可以把TestService1注入到TestService2，并且TestService1的实例是从第三级缓存中获取的。</p>\n<p>假设不用第二级缓存，TestService1注入到TestService3的流程如图：</p>\n<p></p>\n<p>TestService1注入到TestService3又需要从第三级缓存中获取实例，而第三级缓存里保存的并非真正的实例对象，而是ObjectFactory对象。说白了，两次从三级缓存中获取都是ObjectFactory对象，而通过它创建的实例对象每次可能都不一样的。</p>\n<p>这样不是有问题？</p>\n<p>为了解决这个问题，spring引入的第二级缓存。上面图1其实TestService1对象的实例已经被添加到第二级缓存中了，而在TestService1注入到TestService3时，只用从第二级缓存中获取该对象即可。</p>\n<p></p>\n<p>还有个问题，第三级缓存中为什么要添加ObjectFactory对象，直接保存实例对象不行吗？</p>\n<p>答：不行，因为假如你想对添加到三级缓存中的实例对象进行增强，直接用实例对象是行不通的。</p>\n<p>针对这种场景spring是怎么做的呢？</p>\n<p>答案就在AbstractAutowireCapableBeanFactory类doCreateBean方法的这段代码中：</p>\n<p></p>\n<p>它定义了一个匿名内部类，通过getEarlyBeanReference方法获取代理对象，其实底层是通过AbstractAutoProxyCreator类的getEarlyBeanReference生成代理对象。</p>\n<h3> 多例的setter注入</h3>\n<p>这种注入方法偶然会有，特别是在多线程的场景下，具体代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>很多人说这种情况spring容器启动会报错，其实是不对的，我非常负责任的告诉你程序能够正常启动。</p>\n<p>为什么呢？</p>\n<p>其实在AbstractApplicationContext类的refresh方法中告诉了我们答案，它会调用finishBeanFactoryInitialization方法，该方法的作用是为了spring容器启动的时候提前初始化一些bean。该方法的内部又调用了preInstantiateSingletons方法</p>\n<p></p>\n<p>标红的地方明显能够看出：非抽象、单例 并且非懒加载的类才能被提前初始bean。</p>\n<p>而多例即SCOPE_PROTOTYPE类型的类，非单例，不会被提前初始化bean，所以程序能够正常启动。</p>\n<p>如何让他提前初始化bean呢？</p>\n<p>只需要再定义一个单例的类，在它里面注入TestService1</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>重新启动程序，执行结果：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>果然出现了循环依赖。</p>\n<p>注意：这种循环依赖问题是无法解决的，因为它没有用缓存，每次都会生成一个新对象。</p>\n<h3> 构造器注入</h3>\n<p>这种注入方式现在其实用的已经非常少了，但是我们还是有必要了解一下，看看如下代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行结果</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>出现了循环依赖，为什么呢？</p>\n<p></p>\n<p>从图中的流程看出构造器注入没能添加到三级缓存，也没有使用缓存，所以也无法解决循环依赖问题。</p>\n<h3> 单例的代理对象setter注入</h3>\n<p>这种注入方式其实也比较常用，比如平时使用：@Async注解的场景，会通过AOP自动生成代理对象。</p>\n<p>我那位同事的问题也是这种情况。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从前面得知程序启动会报错，出现了循环依赖：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为什么会循环依赖呢？</p>\n<p>答案就在下面这张图中：</p>\n<p></p>\n<p>说白了，bean初始化完成之后，后面还有一步去检查：第二级缓存 和 原始对象 是否相等。由于它对前面流程来说无关紧要，所以前面的流程图中省略了，但是在这里是关键点，我们重点说说：</p>\n<p></p>\n<p>那位同事的问题正好是走到这段代码，发现第二级缓存 和 原始对象不相等，所以抛出了循环依赖的异常。</p>\n<p>如果这时候把TestService1改个名字，改成：TestService6，其他的都不变。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>再重新启动一下程序，神奇般的好了。</p>\n<p>what？ 这又是为什么？</p>\n<p>这就要从spring的bean加载顺序说起了，默认情况下，spring是按照文件完整路径递归查找的，按路径+文件名排序，排在前面的先加载。所以TestService1比TestService2先加载，而改了文件名称之后，TestService2比TestService6先加载。</p>\n<p>为什么TestService2比TestService6先加载就没问题呢？</p>\n<p>答案在下面这张图中：</p>\n<p></p>\n<p>这种情况testService6中其实第二级缓存是空的，不需要跟原始对象判断，所以不会抛出循环依赖。</p>\n<h3> DependsOn循环依赖</h3>\n<p>还有一种有些特殊的场景，比如我们需要在实例化Bean A之前，先实例化Bean B，这个时候就可以使用@DependsOn注解。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>程序启动之后，执行结果：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个例子中本来如果TestService1和TestService2都没有加@DependsOn注解是没问题的，反而加了这个注解会出现循环依赖问题。</p>\n<p>这又是为什么？</p>\n<p>答案在AbstractBeanFactory类的doGetBean方法的这段代码中：</p>\n<p></p>\n<p>它会检查dependsOn的实例有没有循环依赖，如果有循环依赖则抛异常。</p>\n<h2> 出现循环依赖如何解决？</h2>\n<p>项目中如果出现循环依赖问题，说明是spring默认无法解决的循环依赖，要看项目的打印日志，属于哪种循环依赖。目前包含下面几种情况：</p>\n<p></p>\n<h3> 生成代理对象产生的循环依赖</h3>\n<p>这类循环依赖问题解决方法很多，主要有：</p>\n<ul>\n<li>使用@Lazy注解，延迟加载</li>\n<li>使用@DependsOn注解，指定加载先后关系</li>\n<li>修改文件名称，改变循环依赖类的加载顺序</li>\n</ul>\n<h3> 使用@DependsOn产生的循环依赖</h3>\n<p>这类循环依赖问题要找到@DependsOn注解循环依赖的地方，迫使它不循环依赖就可以解决问题。</p>\n<h3> 多例循环依赖</h3>\n<p>这类循环依赖问题可以通过把bean改成单例的解决。</p>\n<h3> 构造器循环依赖</h3>\n<p>这类循环依赖问题可以通过使用@Lazy注解解决。</p>\n",
      "date_modified": "2023-08-03T23:47:31.146Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "面试题总结上",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/basic/basic-01.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/basic/basic-01.html",
      "summary": "基础概念与常识 Java 语言有哪些特点? 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 可靠性； 安全性； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）； 编译与解释并存；",
      "content_html": "<h2> 基础概念与常识</h2>\n<h3> Java 语言有哪些特点?</h3>\n<ol>\n<li>简单易学；</li>\n<li>面向对象（封装，继承，多态）；</li>\n<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>\n<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>\n<li>可靠性；</li>\n<li>安全性；</li>\n<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>\n<li>编译与解释并存；</li>\n</ol>\n<h3> JVM vs JDK vs JRE</h3>\n<h4> JVM</h4>\n<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>\n<p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</p>\n<p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM</p>\n<h4> JDK 和 JRE</h4>\n<p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>\n<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>\n<h3> 什么是字节码?采用字节码的好处是什么?</h3>\n<p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>\n<p><strong>Java 程序从源代码到运行的过程如下图所示：</strong></p>\n<p></p>\n<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>\n<blockquote>\n<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。</p>\n</blockquote>\n<h3> 为什么说 Java 语言“编译与解释并存”？</h3>\n<p>其实这个问题我们讲字节码的时候已经提到过，因为比较重要，所以我们这里再提一下。</p>\n<p>我们可以将高级编程语言按照程序的执行方式分为两种：</p>\n<ul>\n<li><strong>编译型</strong> ：<a href=\"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80\" target=\"_blank\" rel=\"noopener noreferrer\">编译型语言</a> 会通过<a href=\"https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8\" target=\"_blank\" rel=\"noopener noreferrer\">编译器</a>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>\n<li><strong>解释型</strong> ：<a href=\"https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80\" target=\"_blank\" rel=\"noopener noreferrer\">解释型语言</a>会通过<a href=\"https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8\" target=\"_blank\" rel=\"noopener noreferrer\">解释器</a>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>\n</ul>\n<p></p>\n<p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p>\n<p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 <u>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行</u>。</p>\n<h3> Java 和 C++ 的区别?</h3>\n<p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。</p>\n<p>虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p>\n<ul>\n<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>\n<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>\n<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>\n<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>\n<li>......</li>\n</ul>\n<h3> continue、break 和 return 的区别是什么？</h3>\n<p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p>\n<ol>\n<li><code>continue</code> ：指跳出当前的这一次循环，继续下一次循环。</li>\n<li><code>break</code> ：指跳出整个循环体，继续执行循环下面的语句。</li>\n</ol>\n<p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p>\n<ol>\n<li><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li>\n<li><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</li>\n</ol>\n<p>思考一下：下列语句的运行结果是什么？</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>运行结果：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 重载和重写有什么区别？</h3>\n<blockquote>\n<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>\n<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>\n</blockquote>\n<p><strong>重载</strong></p>\n<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>\n<p>《Java 核心技术》这本书是这样介绍重载的：</p>\n<blockquote>\n<p>如果多个方法(比如 <code>StringBuilder</code> 的构造方法)有相同的名字、不同的参数， 便产生了重载。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。</p>\n<p>Java 允许重载任何方法， 而不只是构造器方法。</p>\n</blockquote>\n<p>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</p>\n<p><strong>重写</strong></p>\n<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>\n<ol>\n<li><u>方法名、参数列表必须相同</u>，<u>子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类</u>，<u>访问修饰符范围大于等于父类。</u></li>\n<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>\n<li><u>构造方法无法被重写</u></li>\n</ol>\n<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">区别点</th>\n<th style=\"text-align:left\">重载方法</th>\n<th style=\"text-align:left\">重写方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">发生范围</td>\n<td style=\"text-align:left\">同一个类</td>\n<td style=\"text-align:left\">子类</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">参数列表</td>\n<td style=\"text-align:left\">必须修改</td>\n<td style=\"text-align:left\">一定不能修改</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">返回类型</td>\n<td style=\"text-align:left\">可修改</td>\n<td style=\"text-align:left\">子类方法返回值类型应比父类方法返回值类型更小或相等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">异常</td>\n<td style=\"text-align:left\">可修改</td>\n<td style=\"text-align:left\">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">访问修饰符</td>\n<td style=\"text-align:left\">可修改</td>\n<td style=\"text-align:left\">一定不能做更严格的限制（可以降低限制）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">发生阶段</td>\n<td style=\"text-align:left\">编译期</td>\n<td style=\"text-align:left\">运行期</td>\n</tr>\n</tbody>\n</table>\n<p><strong>方法的重写要遵循“两同两小一大”</strong></p>\n<ul>\n<li>“两同”即方法名相同、形参列表相同；</li>\n<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>\n<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>\n</ul>\n<p>⭐️ 关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的<u>返回类型是 void 和基本数据类型</u>，则<u>返回值重写时不可修改</u>。但是如果方法的<u>返回值是引用类型</u>，重写时是可以返回该<u>引用类型的子类的</u>。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 基本数据类型</h2>\n<h3> Java 中的几种基本数据类型了解么？</h3>\n<p>Java 中有 8 种基本数据类型，分别为：</p>\n<ul>\n<li>6 种数字类型：\n<ul>\n<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>\n<li>2 种浮点型：<code>float</code>、<code>double</code></li>\n</ul>\n</li>\n<li>1 种字符类型：<code>char</code></li>\n<li>1 种布尔型：<code>boolean</code>。</li>\n</ul>\n<p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">基本类型</th>\n<th style=\"text-align:left\">位数</th>\n<th style=\"text-align:left\">字节</th>\n<th style=\"text-align:left\">默认值</th>\n<th>取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>byte</code></td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">0</td>\n<td>-128 ~ 127</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>short</code></td>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">0</td>\n<td>-32768 ~ 32767</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int</code></td>\n<td style=\"text-align:left\">32</td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">0</td>\n<td>-2147483648 ~ 2147483647</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>long</code></td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">0L</td>\n<td>-9223372036854775808 ~ 9223372036854775807</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>char</code></td>\n<td style=\"text-align:left\">16</td>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">'u0000'</td>\n<td>0 ~ 65535</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>float</code></td>\n<td style=\"text-align:left\">32</td>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">0f</td>\n<td>1.4E-45 ~ 3.4028235E38</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>double</code></td>\n<td style=\"text-align:left\">64</td>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">0d</td>\n<td>4.9E-324 ~ 1.7976931348623157E308</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>boolean</code></td>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">false</td>\n<td>true、false</td>\n</tr>\n</tbody>\n</table>\n<p>对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>\n<p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li>\n<li><code>char a = 'h'</code>char :单引号，<code>String a = \"hello\"</code> :双引号。</li>\n</ol>\n<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p>\n<h3> 基本类型和包装类型的区别？</h3>\n<ul>\n<li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li>\n<li>包装类型可用于泛型，而基本类型不可以。</li>\n<li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li>\n<li>相比于对象类型， 基本数据类型占用的空间非常小。</li>\n</ul>\n<p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p>\n<p>⚠️ 注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 包装类型的缓存机制了解么？</h3>\n<p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>\n<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code></p>\n<p>这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，</p>\n<p><code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，</p>\n<p><code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>\n<p><strong>Integer 缓存源码：</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>Character</code> 缓存源码:</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong><code>Boolean</code> 缓存源码：</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>\n<p><u>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</u></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面我们来看一下问题。下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p>\n<p>因此，答案是 <code>false</code> 。你答对了吗？</p>\n<p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>\n<p></p>\n<h3> 自动装箱与拆箱了解吗？原理是什么？</h3>\n<p><strong>什么是自动拆装箱？</strong></p>\n<ul>\n<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>\n<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>\n</ul>\n<p>举例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面这两行代码对应的字节码为：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>\n<p>因此，</p>\n<ul>\n<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>\n<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>\n</ul>\n<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 为什么浮点数运算的时候会有精度丢失的风险？</h3>\n<p>浮点数运算精度丢失代码演示：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为什么会出现这个问题呢？</p>\n<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>\n<p>就比如说十进制下的 0.2 就没办法精确转换成二进制小数：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于浮点数的更多内容，建议看一下<a href=\"http://kaito-kidd.com/2018/08/08/computer-system-float-point/\" target=\"_blank\" rel=\"noopener noreferrer\">计算机系统基础（四）浮点数</a>这篇文章。</p>\n<h3> 如何解决浮点数运算的精度丢失问题？</h3>\n<p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于 <code>BigDecimal</code> 的详细介绍,：<a href=\"/interview/java/basic/emphasis/bigdecimal.html\" target=\"blank\">BigDecimal 详解</a>。</p>\n<h3> 超过 long 整型的数据应该如何表示？</h3>\n<p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p>\n<p>在 Java 中，64 位 long 整型是最大的整数类型。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p>\n<p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p>\n",
      "date_modified": "2023-08-03T23:47:31.167Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "面试题总结中",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/basic/basic-02.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/basic/basic-02.html",
      "summary": "面向对象基础 面向对象和面向过程的区别 两者的主要区别在于解决问题的方式不同： 面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。 面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。 另外，面向对象开发的程序一般更易维护、易复用、易扩展。 对象的相等和引用相等的区别 对象的相等一般比较的是内存中存放的内容是否相等。 引用相等一般比较的是他们指向的内存地址是否相等。",
      "content_html": "<h2> 面向对象基础</h2>\n<h3> 面向对象和面向过程的区别</h3>\n<p>两者的主要区别在于解决问题的方式不同：</p>\n<ul>\n<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>\n<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>\n</ul>\n<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>\n<h3> 对象的相等和引用相等的区别</h3>\n<ul>\n<li><u>对象</u>的相等一般比较的是内存中存放的<u>内容是否相等</u>。</li>\n<li><u>引用</u>相等一般比较的是他们指向的<u>内存地址是否相等</u>。</li>\n</ul>\n<h3> 类的构造方法的作用是什么?</h3>\n<p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p>\n<h3> 如果一个类没有声明构造方法，该程序能正确执行吗?</h3>\n<p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p>\n<h3> 构造方法有哪些特点？是否可被 override?</h3>\n<p>构造方法特点如下：</p>\n<ul>\n<li>名字与类名相同。</li>\n<li>没有返回值，但不能用 void 声明构造函数。</li>\n<li>生成类的对象时自动执行，无需调用。</li>\n</ul>\n<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>\n<h2> 面向对象三大特征</h2>\n<h3> 封装</h3>\n<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 继承</h3>\n<p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>\n<p><strong>关于继承如下 3 点请记住：</strong></p>\n<ol>\n<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>\n<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>\n<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>\n</ol>\n<h3> 多态</h3>\n<p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为<u>父类的引用指向子类的实例</u>。</p>\n<p><strong>多态的特点:</strong></p>\n<ul>\n<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>\n<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>\n<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>\n<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>\n</ul>\n<h3> 接口和抽象类有什么共同点和区别？</h3>\n<p><strong>共同点</strong> ：</p>\n<ul>\n<li>都不能被实例化。</li>\n<li>都可以包含抽象方法。</li>\n<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>\n</ul>\n<p><strong>区别</strong> ：</p>\n<ul>\n<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li>\n<li>一个类只能继承一个类，但是可以实现多个接口。</li>\n<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>\n</ul>\n<h3> 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3>\n<p>关于深拷贝和浅拷贝区别，我这里先给结论：</p>\n<ul>\n<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>\n<li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>\n</ul>\n<p>上面的结论没有完全理解的话也没关系，我们来看一个具体的案例！</p>\n<p><strong>浅拷贝</strong></p>\n<p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。</p>\n<p><code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>测试 ：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p>\n<p><strong>深拷贝</strong></p>\n<p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>测试 ：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从输出结构就可以看出，虽然 <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p>\n<p><strong>那什么是引用拷贝呢？</strong> 简单来说，引用拷贝就是两个不同的引用指向同一个对象。</p>\n<p></p>\n<h2> Java 常见类</h2>\n<h3> Object</h3>\n<h4> Object 类的常见方法有哪些？</h4>\n<p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> == 和 equals() 的区别</h3>\n<p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>\n<ul>\n<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>\n<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>\n</ul>\n<blockquote>\n<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>\n</blockquote>\n<p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p>\n<p><code>Object</code> 类 <code>equals()</code> 方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>equals()</code> 方法存在两种使用情况：</p>\n<ul>\n<li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>\n<li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>\n</ul>\n<p>举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 <code>==</code> 换成 <code>equals()</code> ）：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p>\n<p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>\n<p><code>String</code>类<code>equals()</code>方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> hashCode() 有什么用？</h3>\n<p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>\n<p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p>\n<h3> 为什么要有 hashCode？</h3>\n<p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode</code>？</p>\n<p>下面这段内容摘自我的 Java 启蒙书《Head First Java》:</p>\n<blockquote>\n<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>\n</blockquote>\n<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>\n<p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p>\n<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>\n<p>总结下来就是 ：</p>\n<ul>\n<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>\n<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>\n<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>\n</ul>\n<h3> 为什么重写 equals() 时必须重写 hashCode() 方法？</h3>\n<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>\n<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>\n<p><strong>总结</strong> ：</p>\n<ul>\n<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>\n<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li>\n</ul>\n<h2> String</h2>\n<h3> String、StringBuffer、StringBuilder 的区别？</h3>\n<p><strong>可变性</strong></p>\n<p><code>String</code> 是不可变的（后面会详细分析原因）。</p>\n<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>线程安全性</strong></p>\n<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>\n<p><strong>性能</strong></p>\n<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n<p><strong>对于三者使用的总结：</strong></p>\n<ol>\n<li>操作少量的数据: 适用 <code>String</code></li>\n<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>\n<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>\n</ol>\n<h3> String 为什么是不可变的?</h3>\n<p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，<s>所以<code>String</code> 对象是不可变的。</s></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>🐛 修正 ： 我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p>\n<p><code>String</code> 真正不可变有下面几点原因：</p>\n<ol>\n<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>\n<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>\n</ol>\n<p>相关阅读：<a href=\"https://www.zhihu.com/question/20618891/answer/114125846\" target=\"_blank\" rel=\"noopener noreferrer\">如何理解 String 类型值的不可变？ - 知乎提问</a></p>\n<p>补充：在 Java 9 之后，<code>String</code> 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</strong></p>\n<p>新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p>\n<p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p>\n</blockquote>\n<h3> 字符串拼接用“+” 还是 StringBuilder?</h3>\n<p>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象。</p>\n<p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> String#equals() 和 Object#equals() 有何区别？</h3>\n<p><u><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</u></p>\n<h3> 字符串常量池的作用了解吗？</h3>\n<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> String s1 = new String(\"abc\");这句话创建了几个字符串对象？</h3>\n<p>会创建 1 或 2 个字符串对象。</p>\n<p>1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。</p>\n<p>示例代码（JDK 1.8）：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p>\n<p>示例代码（JDK 1.8）：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> intern 方法有什么作用?</h3>\n<p><code>String.intern()</code> 是一个 <code>native</code>（本地）方法，其作用是将<u>指定的字符串对象的引用保存在字符串常量池中</u>，可以简单分为两种情况：</p>\n<ul>\n<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>\n<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</li>\n</ul>\n<p>示例代码（JDK 1.8） :</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> String 类型的变量和常量做“+”运算时发生了什么？</h4>\n<p>先来看字符串不加 <code>final</code> 关键字拼接的情况（JDK1.8）：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。</p>\n</blockquote>\n<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p>\n<p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。</p>\n<p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>\n<p>对于 <code>String str3 = \"str\" + \"ing\";</code> 编译器会给你优化成 <code>String str3 = \"string\";</code> 。</p>\n<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>\n<ul>\n<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li>\n<li><code>final</code> 修饰的基本数据类型和字符串变量</li>\n<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>\n</ul>\n<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>\n<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p>\n<p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p>\n<p>示例代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>\n<p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。</p>\n<p>示例代码（<code>str2</code> 在运行时才能确定其值）：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:31.190Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "面试题总结下",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/basic/basic-03.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/basic/basic-03.html",
      "summary": "异常 Java 异常类层次结构图概览 ： RuntimeException 、 Exception 、Throwable 伪代码 public class RuntimeException extends Exception ...extends Throwable{ ... }",
      "content_html": "<h2> 异常</h2>\n<p><strong>Java 异常类层次结构图概览</strong> ：</p>\n<p></p>\n<p>RuntimeException 、 Exception 、Throwable  伪代码</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> Exception 和 Error 有什么区别？</h3>\n<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>\n<ul>\n<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>\n<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，<s>我们没办法通过 <code>catch</code> 来进行捕获</s>不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>\n</ul>\n<h3> Checked Exception 和 Unchecked Exception 有什么区别？</h3>\n<p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。\n除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>...。</p>\n<p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>\n<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>\n<ul>\n<li><code>NullPointerException</code>(空指针错误)</li>\n<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>\n<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li>\n<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>\n<li><code>ClassCastException</code>（类型转换错误）</li>\n<li><code>ArithmeticException</code>（算术错误）</li>\n<li><code>SecurityException</code> （安全错误比如权限不够）</li>\n<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>\n<li>......</li>\n</ul>\n<h3> Throwable 类常用方法有哪些？</h3>\n<ul>\n<li><code>String getMessage()</code>: 返回异常发生时的简要描述</li>\n<li><code>String toString()</code>: 返回异常发生时的详细信息</li>\n<li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>\n<li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>\n</ul>\n<h3> try-catch-finally 如何使用？</h3>\n<ul>\n<li><code>try</code>块 ： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>\n<li><code>catch</code>块 ： 用于处理 try 捕获到的异常。</li>\n<li><code>finally</code> 块 ： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>\n</ul>\n<p>代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.10.2.5\" target=\"_blank\" rel=\"noopener noreferrer\">jvm 官方文档</a>中有明确提到：</p>\n<blockquote>\n<p>If the <code>try</code> clause executes a <em>return</em>, the compiled code does the following:</p>\n<ol>\n<li>Saves the return value (if any) in a local variable.</li>\n<li>Executes a <em>jsr</em> to the code for the <code>finally</code> clause.</li>\n<li>Upon return from the <code>finally</code> clause, returns the value saved in the local variable.</li>\n</ol>\n</blockquote>\n<p>代码示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> finally 中的代码一定会执行吗？</h3>\n<p>不一定的！在某些情况下，finally 中的代码不会被执行。</p>\n<p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p>\n<ol>\n<li>程序所在的线程死亡。</li>\n<li>关闭 CPU。</li>\n</ol>\n<p>🧗🏻 进阶一下：从字节码角度分析<code>try catch finally</code>这个语法糖背后的实现原理。</p>\n<h3> 如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h3>\n<ol>\n<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>\n<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>\n</ol>\n<p>《Effective Java》中明确指出：</p>\n<blockquote>\n<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>\n</blockquote>\n<p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>\n<p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 异常使用有哪些需要注意的地方？</h3>\n<ul>\n<li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li>\n<li>抛出的异常信息一定要有意义。</li>\n<li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li>\n<li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li>\n<li>......</li>\n</ul>\n<h2> 泛型</h2>\n<h3> 什么是泛型？有什么作用？</h3>\n<p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p>\n<p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p>\n<h3> 泛型的使用方式有哪几种？</h3>\n<p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>\n<p><strong>1.泛型类</strong>：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如何实例化泛型类：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><strong>2.泛型接口</strong> ：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现泛型接口，不指定类型：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现泛型接口，指定类型：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>3.泛型方法</strong> ：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>注意: <code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p>\n</blockquote>\n<h3> 项目中哪里用到了泛型？</h3>\n<ul>\n<li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li>\n<li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</li>\n<li>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</li>\n<li>......</li>\n</ul>\n<h2> 反射</h2>\n<p>关于反射的详细解读，请看这篇文章 <a href=\"/interview/java/basic/reflection.html\" target=\"blank\">Java 反射机制详解</a> 。</p>\n<h3> 何谓反射？</h3>\n<p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>\n<h3> 反射的优缺点？</h3>\n<p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p>\n<p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>\n<p>相关阅读：<a href=\"https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow\" target=\"_blank\" rel=\"noopener noreferrer\">Java Reflection: Why is it so slow?</a> 。</p>\n<h3> 反射的应用场景？</h3>\n<p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p>\n<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>\n<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>\n<p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>\n<p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>\n<h2> 注解</h2>\n<h3> 何谓注解？</h3>\n<p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>\n<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p>\n<h3> 注解的解析方法有哪几种？</h3>\n<p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>\n<ul>\n<li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>\n<li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li>\n</ul>\n<h2> SPI</h2>\n<p>关于 SPI 的详细解读，请看这篇文章 <a href=\"/interview/java/basic/spi.html\" target=\"blank\">Java SPI 机制详解</a> 。</p>\n<h3> 何谓 SPI?</h3>\n<p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>\n<p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>\n<p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p>\n<h3> SPI 和 API 有什么区别？</h3>\n<p><strong>那 SPI 和 API 有啥区别？</strong></p>\n<p>说到 SPI 就不得不说一下 API 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：</p>\n<p></p>\n<p>一般模块之间都是通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p>\n<p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p>\n<p>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p>\n<p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。</p>\n<h3> SPI 的优缺点？</h3>\n<p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p>\n<ul>\n<li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li>\n<li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li>\n</ul>\n<h2> 序列化和反序列化</h2>\n<p>关于序列化和反序列化的详细解读，请看这篇文章 <a href=\"/interview/java/basic/emphasis/serialization.html\" target=\"blank\">Java序列化详解</a> ，里面涉及到的知识点和面试题更全面。</p>\n<h3> 什么是序列化?什么是反序列化?</h3>\n<p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>\n<p>简单来说：</p>\n<ul>\n<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>\n<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>\n</ul>\n<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>\n<p>下面是序列化和反序列化常见应用场景：</p>\n<ul>\n<li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>\n<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>\n<li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>\n<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>\n</ul>\n<p>维基百科是如是介绍序列化的：</p>\n<blockquote>\n<p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p>\n</blockquote>\n<p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p>\n<p></p>\n<p><strong>序列化协议对应于 TCP/IP 4 层模型的哪一层？</strong></p>\n<p>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？</p>\n<ol>\n<li>应用层</li>\n<li>传输层</li>\n<li>网络层</li>\n<li>网络接口层</li>\n</ol>\n<p></p>\n<p>如上图所示，<code>OSI</code> 七层协议模型中，<u>表示层</u>做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p>\n<p>因为，<code>OSI</code> 七层协议模型中的<u>应用层、表示层和会话层</u>对应的都是 <code>TCP/IP</code> 四层模型中的应用层，所以<code>序列化协议</code>属于 <u><code>TCP/IP</code> 协议应用层</u>的一部分。</p>\n<h3> 如果有些字段不想进行序列化怎么办？</h3>\n<p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>\n<p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p>\n<p>关于 <code>transient</code> 还有几点注意：</p>\n<ul>\n<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>\n<li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>\n<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li>\n</ul>\n<h3> 常见序列化协议有哪些？</h3>\n<p><code>JDK</code> 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 <code>Hessian</code>、<code>Kryo</code>、<code>Protobuf</code>、<code>ProtoStuff</code>，这些都是基于二进制的序列化协议。</p>\n<p>像 <code>JSON</code> 和 <code>XML</code> 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p>\n<h3> 为什么不推荐使用 JDK 自带的序列化？</h3>\n<p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p>\n<ul>\n<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>\n<li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>\n<li><strong>存在安全问题</strong> ：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：<a href=\"https://cryin.github.io/blog/secure-development-java-deserialization-vulnerability/\" target=\"_blank\" rel=\"noopener noreferrer\">应用安全：JAVA反序列化漏洞之殇</a> 。</li>\n</ul>\n",
      "date_modified": "2023-08-03T23:47:31.208Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "反射",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/basic/reflection.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/basic/reflection.html",
      "summary": "参考 Java 基础 - 反射机制详解 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://pdai.tech/md/java/basic/java-basic-x-reflection.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java 基础 - 反射机制详解</a></p>\n</div>\n<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制</p>\n<h2> 反射基础</h2>\n<p><code>RTTI</code>（<code>Run-Time Type Identification</code>）运行时类型识别。在《<code>Thinking in Java</code>》一书第十四章中有提到，其作用是在运行时识别一个对象的类型和类的信息。主要有两种方式：一种是“传统的”<code>RTTI</code>，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。反射就是把java类中的各种成分映射成一个个的Java对象例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p>\n<h3> Class类</h3>\n<p><code>Class</code>类，<code>Class</code>类也是一个实实在在的类，存在于<code>JDK</code>的<code>java.lang</code>包中。\n<code>Class</code>类的实例表示java应用运行时的类(<code>class and enum</code>)或接口(<code>interface and annotation</code>)（每个java类运行时都在JVM里表现为一个<code>class</code>对象，可通过<code>类名.class</code>、<code>类型.getClass()</code>、<code>Class.forName</code>(\"类名\")等方法获取<code>class</code>对象）。\n数组同样也被映射为<code>class</code> 对象的一个类，所有具有相同元素类型和维数的数组都共享该 <code>Class</code> 对象。基本类型 <code>boolean，byte，char，short，int，long，float，double 和关键字</code>void<code>同样表现为 </code>class` 对象。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 反射的使用</h2>\n<p>在<code>Java</code>中，<code>Class</code>类与<code>java.lang.reflect</code>类库一起对反射技术进行了全力的支持。在反射包中，我们常用的类主要有</p>\n<p><code>Constructor</code>类表示的是<code>Class</code> 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、</p>\n<p><code>Field</code>表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含<code>private</code>)、</p>\n<p><code>Method</code>表示<code>Class</code>对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含<code>private</code>)</p>\n<h3> Class对象的获取</h3>\n<p>在类加载的时候，jvm会创建一个class对象class对象是可以说是反射中最常用的，\n获取class对象的方式的主要有三种根据类名：</p>\n<ul>\n<li>\n<p>类名.class根据对象：</p>\n</li>\n<li>\n<p>对象.getClass()</p>\n</li>\n<li>\n<p>根据全限定类名：Class.forName(全限定类名)</p>\n</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> class 常用方法</h3>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>forName()</td>\n<td>获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。为了产生Class引用，forName()立即就进行了初始化。</td>\n</tr>\n<tr>\n<td>Object-getClass()</td>\n<td>获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。</td>\n</tr>\n<tr>\n<td>getName()</td>\n<td>取全限定的类名(包括包名)，即类的完整名字。</td>\n</tr>\n<tr>\n<td>getSimpleName()</td>\n<td>获取类名(不包括包名)</td>\n</tr>\n<tr>\n<td>getCanonicalName()</td>\n<td>获取全限定的类名(包括包名)</td>\n</tr>\n<tr>\n<td>isInterface()</td>\n<td>判断Class对象是否是表示一个接口</td>\n</tr>\n<tr>\n<td>getInterfaces()</td>\n<td>返回Class对象数组，表示Class对象所引用的类所实现的所有接口。</td>\n</tr>\n<tr>\n<td>getSupercalss()</td>\n<td>返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。</td>\n</tr>\n<tr>\n<td>newInstance()</td>\n<td>返回一个Object对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。</td>\n</tr>\n<tr>\n<td>getFields()</td>\n<td>获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors。</td>\n</tr>\n<tr>\n<td>getDeclaredFields</td>\n<td>获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。</td>\n</tr>\n</tbody>\n</table>\n<h3> getName、getCanonicalName与getSimpleName的区别：</h3>\n<p><code>getSimpleName</code>：只获取类名getName：类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如Class.forName。</p>\n<p><code>getCanonicalName</code>：返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和<code>getName</code>一样，\n但是在内部类、数组等类型的表示形式就不同了。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Constructor类及其用法</h2>\n<p>获取Constructor对象是通过Class类中的方法获取的，Class类与Constructor相关的主要方法如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法返回值</th>\n<th>方法名称</th>\n<th>方法说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>static Class&lt;?&gt;</td>\n<td>forName(String className)</td>\n<td>返回与带有给定字符串名的类或接口相关联的 Class 对象。</td>\n</tr>\n<tr>\n<td>Constructor</td>\n<td>getConstructor(Class&lt;?&gt;... parameterTypes)</td>\n<td>返回指定参数类型、具有public访问权限的构造函数对象</td>\n</tr>\n<tr>\n<td>Constructor&lt;?&gt;[]</td>\n<td>getConstructors()</td>\n<td>返回所有具有public访问权限的构造函数的Constructor对象数组</td>\n</tr>\n<tr>\n<td>Constructor</td>\n<td>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</td>\n<td>返回指定参数类型、所有声明的（包括private）构造函数对象</td>\n</tr>\n<tr>\n<td>Constructor&lt;?&gt;[]</td>\n<td>getDeclaredConstructors()</td>\n<td>返回所有声明的（包括private）构造函数对象</td>\n</tr>\n<tr>\n<td>T</td>\n<td>newInstance()</td>\n<td>调用无参构造器创建此 Class 对象所表示的类的一个新实例。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>返回</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关于Constructor类本身一些常用方法如下(仅部分，其他可查API)</p>\n<table>\n<thead>\n<tr>\n<th>方法返回值</th>\n<th>方法名称</th>\n<th>方法说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Class</td>\n<td>getDeclaringClass()</td>\n<td>返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）</td>\n</tr>\n<tr>\n<td>Type[]</td>\n<td>getGenericParameterTypes()按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。</td>\n<td></td>\n</tr>\n<tr>\n<td>String</td>\n<td>getName()</td>\n<td>以字符串形式返回此构造方法的名称。</td>\n</tr>\n<tr>\n<td>Class&lt;?&gt;[]</td>\n<td>getParameterTypes()</td>\n<td>按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型</td>\n</tr>\n<tr>\n<td>T</td>\n<td>newInstance(Object... initargs)</td>\n<td>使用此 Constructor对象表示的构造函数来创建新实例</td>\n</tr>\n<tr>\n<td>String</td>\n<td>toGenericString()</td>\n<td>返回描述此 Constructor 的字符串，其中包括类型参数。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Field类及其用法</h2>\n<p>Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p>\n<table>\n<thead>\n<tr>\n<th>方法返回值</th>\n<th>方法名称</th>\n<th>方法说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Field</td>\n<td>getDeclaredField(String name)</td>\n<td>获取指定name名称的(包含private修饰的)字段，不包括继承的字段</td>\n</tr>\n<tr>\n<td>Field[]</td>\n<td>getDeclaredFields()</td>\n<td>获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>getField(String name)</td>\n<td>获取指定name名称、具有public修饰的字段，包含继承字段</td>\n</tr>\n<tr>\n<td>Field[]</td>\n<td>getFields()</td>\n<td>获取修饰符为public的字段，包含继承字段</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述方法需要注意的是，如果我们不期望获取其父类的字段，\n则需使用<code>Class</code>类的<code>getDeclaredField/getDeclaredFields</code>方法来获取字段即可，\n倘若需要连带获取到父类的字段，那么请使用<code>Class</code>类的<code>getField/getFields</code>，\n但是也只能获取到<code>public</code>修饰的的字段，无法获取父类的私有字段。\n下面将通过Field类本身的方法对指定类属性赋值，代码演示如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Method类及其用法</h2>\n<p>Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。</p>\n<table>\n<thead>\n<tr>\n<th>方法返回值</th>\n<th>方法名称</th>\n<th>方法说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Method</td>\n<td>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</td>\n<td>返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td>\n</tr>\n<tr>\n<td>Method[]</td>\n<td>getDeclaredMethods()</td>\n<td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>getMethod(String name, Class&lt;?&gt;... parameterTypes)</td>\n<td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td>\n</tr>\n<tr>\n<td>Method[]</td>\n<td>getMethods()</td>\n<td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td>\n</tr>\n</tbody>\n</table>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在通过<code>getMethods</code>方法获取<code>Method</code>对象时，会把父类的方法也获取到，如上的输出结果，\n把Object类的方法都打印出来了。而<code>getDeclaredMethod/getDeclaredMethods</code>方法都只能获取当前类的方法。\n我们在使用时根据情况选择即可。下面将演示通过Method对象调用指定类的方法：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>返回</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上述代码中调用方法，使用了<code>Method</code>类的<code>invoke(Object obj,Object... args)</code>第一个参数代表调用的对象，\n第二个参数传递的调用方法的参数。这样就完成了类方法的动态调用。</p>\n<table>\n<thead>\n<tr>\n<th>方法返回值 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>\n<th>方法名称</th>\n<th>方法说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Object</td>\n<td>invoke(Object obj, Object... args)</td>\n<td>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td>\n</tr>\n<tr>\n<td>Class&lt;?&gt;</td>\n<td>getReturnType()</td>\n<td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型</td>\n</tr>\n<tr>\n<td>Type</td>\n<td>getGenericReturnType()</td>\n<td>返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。</td>\n</tr>\n<tr>\n<td>Class&lt;?&gt;[]</td>\n<td>getParameterTypes()</td>\n<td>按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组</td>\n</tr>\n<tr>\n<td>Type[]</td>\n<td>getGenericParameterTypes()</td>\n<td>按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型</td>\n</tr>\n<tr>\n<td>String</td>\n<td>getName()</td>\n<td>以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称booleanisVarArgs()判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。</td>\n</tr>\n<tr>\n<td>String</td>\n<td>toGenericString()</td>\n<td>返回描述此 Method 的字符串，包括类型参数。</td>\n</tr>\n</tbody>\n</table>\n<p><code>getReturnType方法/getGenericReturnType</code>方法都是获取<code>Method</code>对象表示的方法的返回类型，只不过前者返回的<code>Class</code>类型后者返回的<code>Type</code>(前面已分析过)，<code>Type</code>就是一个接口而已，在Java8中新增一个默认的方法实现，返回的就参数类型信息</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>而<code>getParameterTypes/getGenericParameterTypes</code>也是同样的道理，都是获取<code>Method</code>对象所表示的方法的参数类型，其他方法与前面的<code>Field</code>和<code>Constructor</code>是类似的。</p>\n",
      "date_modified": "2023-08-03T23:47:31.243Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "spi",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/basic/spi.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/basic/spi.html",
      "summary": "参考 https://pdai.tech/md/java/advanced/java-advanced-spi.html 什么是spi SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://pdai.tech/md/java/advanced/java-advanced-spi.html\" target=\"_blank\" rel=\"noopener noreferrer\">https://pdai.tech/md/java/advanced/java-advanced-spi.html</a></p>\n</div>\n<h2> 什么是spi</h2>\n<p>SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心</p>\n<p>SPI整体机制图如下：</p>\n<p></p>\n<p>当服务的提供者提供了一种接口的实现之后，需要在<code>classpath</code>下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个<code>jar</code>包（一般都是以<code>jar</code>包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p>\n<h2> SPI机制的缺陷</h2>\n<p>通过上面的解析，可以发现，我们使用SPI机制的缺陷：</p>\n<p>不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</p>\n<p>获取某个实现类的方式不够灵活，只能通过 <code>Iterator</code> 形式获取，不能根据某个参数来获取对应的实现类。</p>\n<p>多个并发多线程使用 <code>ServiceLoader</code> 类的实例是不安全的。</p>\n",
      "date_modified": "2023-08-03T23:47:31.244Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "锁相关",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/concurrency/lock.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/concurrency/lock.html",
      "summary": "synchronized 关键字 synchronized 是什么？有什么用？ synchronized 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性， 可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。",
      "content_html": "<h2> synchronized 关键字</h2>\n<h3> synchronized 是什么？有什么用？</h3>\n<p><code>synchronized</code> 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，\n可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>\n<p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的\n<code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>\n<p>不过，在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如<u>自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</u>\n等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在\n实际项目中使用的，像<code>JDK</code>源码、很多开源框架都大量使用了 <code>synchronized</code> 。</p>\n<h3> 如何使用 synchronized?</h3>\n<p><code>synchronized</code> 关键字的使用方式主要有下面 3 种：</p>\n<ol>\n<li>修饰实例方法</li>\n<li>修饰静态方法</li>\n<li>修饰代码块</li>\n</ol>\n<p><strong>1、修饰实例方法</strong> （锁当前对象实例）</p>\n<p>给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>2、修饰静态方法</strong> （锁当前类）</p>\n<p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p>\n<p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>静态 <code>synchronized</code> 方法和非静态 <code>synchronized</code> 方法之间的调用互斥么？不互斥！如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p>\n<p><strong>3、修饰代码块</strong> （锁指定对象/类）</p>\n<p>对括号里指定的对象/类加锁：</p>\n<ul>\n<li><code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li>\n<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>总结：</strong></p>\n<ul>\n<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li>\n<li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁；</li>\n<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能。</li>\n</ul>\n<h3> 构造方法可以用 synchronized 修饰么？</h3>\n<p>先说结论：<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p>\n<p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>\n<h3> synchronized 底层原理了解吗？</h3>\n<p>synchronized 关键字底层原理属于 JVM 层面的东西。</p>\n<h4> synchronized 同步语句块的情况</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过 JDK 自带的 <code>javap</code> 命令查看 <code>SynchronizedDemo</code> 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p>\n<p></p>\n<p>从上面我们可以看出：<strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>\n<p>上面的字节码中包含一个 <code>monitorenter</code> 指令以及两个 <code>monitorexit</code> 指令，这是为了保证锁在同步代码块代码正常执行以及出现异常的这两种情况下都能被正确释放。</p>\n<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>\n<blockquote>\n<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>\n<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>\n</blockquote>\n<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>\n<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>\n<p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>\n<h4> synchronized 修饰方法的的情况</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p></p>\n<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>\n<p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，<code>JVM</code> 会尝试获取当前 <code>class </code>的锁。</p>\n<h4> 总结</h4>\n<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>\n<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>\n<p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p>\n<h3> JDK1.6 之后的 synchronized 底层做了哪些优化？</h3>\n<p>JDK1.6 对锁的实现引入了大量的优化，如<u>偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化</u>等技术来减少锁操作的开销。</p>\n<p>锁主要存在四种状态，依次是：<u>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</u>，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>\n<p>关于这几种优化的详细信息可以查看下面这篇文章：<a href=\"https://www.cnblogs.com/wuqinglong/p/9945618.html\" target=\"_blank\" rel=\"noopener noreferrer\">Java6 及以上版本对 synchronized 的优化</a> 。</p>\n<h3> synchronized 和 volatile 有什么区别？</h3>\n<p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>\n<ul>\n<li><code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 。但是 <code>volatile</code> 关键字<u>只能用于变量</u>而 <code>synchronized</code> 关键字可以<u>修饰方法以及代码块</u> 。</li>\n<li><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li>\n<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的<u>可见性</u>，而 <code>synchronized</code> 关键字解决的是多个线程之间访问<u>资源的同步性</u>。</li>\n</ul>\n<h2> ReentrantLock</h2>\n<h3> ReentrantLock 是什么？</h3>\n<p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p>\n<p></p>\n<p><code>ReentrantLock</code> 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从上面的内容可以看出， <code>ReentrantLock</code> 的底层就是由 AQS 来实现的。关于 AQS 的相关内容推荐阅读 <a href=\"https://javaguide.cn/java/concurrent/aqs.html\" target=\"_blank\" rel=\"noopener noreferrer\">AQS 详解</a> 这篇文章。</p>\n<h3> 公平锁和非公平锁有什么区别？</h3>\n<ul>\n<li><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li>\n<li><strong>非公平锁</strong> ：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</li>\n</ul>\n<h3> synchronized 和 ReentrantLock 有什么区别？</h3>\n<h4> 两者都是可重入锁</h4>\n<p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p>\n<p>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是可重入的。</p>\n<p>在下面的代码中，<code>method1()</code> 和 <code>method2()</code>都被 <code>synchronized</code> 关键字修饰，<code>method1()</code>调用了<code>method2()</code>。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>由于 <code>synchronized</code>锁是可重入的，同一个线程在调用<code>method1()</code> 时可以直接获得当前对象的锁，执行 <code>method2()</code> 的时候可以再次获取这个对象的锁，不会产生死锁问题。假如<code>synchronized</code>是不可重入锁的话，由于该对象的锁已被当前线程所持有且无法释放，这就导致线程在执行 <code>method2()</code>时获取锁失败，会出现死锁问题。</p>\n<h4> synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h4>\n<p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。</p>\n<p><code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>\n<h4> ReentrantLock 比 synchronized 增加了一些高级功能</h4>\n<p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p>\n<ul>\n<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>\n<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>\n<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>\n</ul>\n<p>如果你想使用上述功能，那么选择 <code>ReentrantLock</code> 是一个不错的选择。</p>\n<p>关于 <code>Condition</code>接口的补充：</p>\n<blockquote>\n<p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 <code>Lock</code> 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p>\n</blockquote>\n<h3> 可中断锁和不可中断锁有什么区别？</h3>\n<ul>\n<li><strong>可中断锁</strong> ：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li>\n<li><strong>不可中断锁</strong> ：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</li>\n</ul>\n<h2> ReentrantReadWriteLock</h2>\n<p><code>ReentrantReadWriteLock</code> 在实际项目中使用的并不多，面试中也问的比较少，简单了解即可。JDK 1.8 引入了性能更好的读写锁 <code>StampedLock</code> 。</p>\n<h3> ReentrantReadWriteLock 是什么？</h3>\n<p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> ，是一个可重入的读写锁，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>一般锁进行并发控制的规则：读读互斥、读写互斥、写写互斥。</li>\n<li>读写锁进行并发控制的规则：读读不互斥、读写互斥、写写互斥（只有读读不互斥）。</li>\n</ul>\n<p><code>ReentrantReadWriteLock</code> 其实是两把锁，一把是 <code>WriteLock</code> (写锁)，一把是 <code>ReadLock</code>（读锁） 。读锁是共享锁，写锁是独占锁。读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。</p>\n<p>和 <code>ReentrantLock</code> 一样，<code>ReentrantReadWriteLock</code> 底层也是基于 AQS 实现的。</p>\n<p></p>\n<p><code>ReentrantReadWriteLock</code> 也支持公平锁和非公平锁，默认使用非公平锁，可以通过构造器来显示的指定。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> ReentrantReadWriteLock 适合什么场景？</h3>\n<p>由于 <code>ReentrantReadWriteLock</code> 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，在读多写少的情况下，使用 <code>ReentrantReadWriteLock</code> 能够明显提升系统性能。</p>\n<h3> 共享锁和独占锁有什么区别？</h3>\n<ul>\n<li><strong>共享锁</strong> ：一把锁可以被多个线程同时获得。</li>\n<li><strong>独占锁</strong> ：一把锁只能被一个线程获得。</li>\n</ul>\n<h3> 线程持有读锁还能获取写锁吗？</h3>\n<ul>\n<li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</li>\n<li>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</li>\n</ul>\n<p>读写锁的源码分析，推荐阅读 <a href=\"https://mp.weixin.qq.com/s/h3VIUyH9L0v14MrQJiiDbw\" target=\"_blank\" rel=\"noopener noreferrer\">聊聊 Java 的几把 JVM 级锁 - 阿里巴巴中间件 </a> 这篇文章，写的很不错。</p>\n<h3> 读锁为什么不能升级为写锁？</h3>\n<p>写锁可以降级为读锁，但是读锁却不能升级为写锁。这是因为读锁升级为写锁会引起线程的争夺，毕竟写锁属于是独占锁，这样的话，会影响性能。</p>\n<p>另外，还可能会有死锁问题发生。举个例子：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。</p>\n<h2> StampedLock</h2>\n<p><code>StampedLock</code> 面试中问的比较少，不是很重要，简单了解即可。</p>\n<h3> StampedLock 是什么？</h3>\n<p><code>StampedLock</code> 是 JDK 1.8 引入的性能更好的读写锁，不可重入且不支持条件变量 <code>Conditon</code>。</p>\n<p>不同于一般的 <code>Lock</code> 类，<code>StampedLock</code> 并不是直接实现 <code>Lock</code>或 <code>ReadWriteLock</code>接口，而是基于 <strong>CLH 锁</strong> 独立实现的（AQS 也是基于这玩意）。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>StampedLock</code> 提供了三种模式的读写控制模式：读锁、写锁和乐观读。</p>\n<ul>\n<li><strong>写锁</strong>：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 <code>ReentrantReadWriteLock</code> 的写锁，不过这里的写锁是不可重入的。</li>\n<li><strong>读锁</strong> （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 <code>ReentrantReadWriteLock</code> 的读锁，不过这里的读锁是不可重入的。</li>\n<li><strong>乐观读</strong> ：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。</li>\n</ul>\n<p>另外，<code>StampedLock</code> 还支持这三种锁在一定条件下进行相互转换 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>StampedLock</code> 在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，如果返回的数据戳为 0 则表示锁获取失败。当前线程持有了锁再次获取锁还是会返回一个新的数据戳，这也是<code>StampedLock</code>不可重入的原因。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> StampedLock 的性能为什么更好？</h3>\n<p>相比于传统读写锁多出来的乐观读是<code>StampedLock</code>比 <code>ReadWriteLock</code> 性能更好的关键原因。<code>StampedLock</code> 的乐观读允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。</p>\n<h3> StampedLock 适合什么场景？</h3>\n<p>和 <code>ReentrantReadWriteLock</code> 一样，<code>StampedLock</code> 同样适合读多写少的业务场景，可以作为 <code>ReentrantReadWriteLock</code>的替代品，性能更好。</p>\n<p>不过，需要注意的是<code>StampedLock</code>不可重入，不支持条件变量 <code>Conditon</code>，对中断操作支持也不友好（使用不当容易导致 CPU 飙升）。如果你需要用到 <code>ReentrantLock</code> 的一些高级性能，就不太建议使用 <code>StampedLock</code> 了。</p>\n",
      "date_modified": "2023-08-03T23:47:31.256Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "并发编程上",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/concurrency/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8A.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/concurrency/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8A.html",
      "summary": "什么是进程？ 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。 什么是线程？ 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。",
      "content_html": "<h2> 什么是进程？</h2>\n<p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>\n<h2> 什么是线程？</h2>\n<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<em><strong>堆</strong></em>和<em><strong>方法区资源</strong></em>，但每个线程有自己的<em><strong>程序计数器</strong></em>、<em><strong>虚拟机栈</strong></em>和<em><strong>本地方法栈</strong></em>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>\n<h2> 什么JVM</h2>\n<p>JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，它是整个 java实现跨平台的最核心的部分，所有的 java 程序会首先被编译为.class 的类文件，这种类文件可以在虚拟机上执行，也就是说 class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。JVM 是 Java 平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。 JVM 通过抽象操作系统和 CPU 结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。JVM 的主要工作是解释自己的指令集（即字节码）到 CPU 的指令集或对应的系统调用，保护用户免被恶意程序骚扰.</p>\n<h3> 运行时数据区域</h3>\n<p>\n从上图可以看出：多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。总结： 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反.</p>\n<h3> 程序计数器</h3>\n<p>程序计数器主要有下面两个作用：</p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n</ol>\n<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>\n<p>所以，程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>\n<h3> 虚拟机栈和本地方法栈</h3>\n<ul>\n<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>\n<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>\n</ul>\n<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>\n<h3> 堆和方法区</h3>\n<p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>\n<h2> 并发与并行的区别</h2>\n<ul>\n<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>\n<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>\n</ul>\n<p>最关键的点是：是否是 <strong>同时</strong> 执行。</p>\n<h2> 同步和异步的区别</h2>\n<ul>\n<li><strong>同步</strong> ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>\n<li><strong>异步</strong> ：调用在发出之后，不用等待返回结果，该调用直接返回。</li>\n</ul>\n<h2> 为什么要使用多线程?</h2>\n<p>先从总体上来说：</p>\n<ul>\n<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>\n<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>\n</ul>\n<p>再深入到计算机底层来探讨：</p>\n<ul>\n<li><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</li>\n<li><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</li>\n</ul>\n<h2> 使用多线程可能带来什么问题?</h2>\n<p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。</p>\n<h2> 说说线程的生命周期和状态?</h2>\n<p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p>\n<ul>\n<li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li>\n<li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li>\n<li>BLOCKED ：阻塞状态，需要等待锁释放。</li>\n<li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li>\n<li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li>\n<li>TERMINATED：终止状态，表示该线程已经运行完毕。</li>\n</ul>\n<p></p>\n<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>\n<ul>\n<li><u>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态</u>。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</li>\n<li><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如<u>通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态</u>。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</li>\n<li>当线程进入 <u><code>synchronized</code> 方法/块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法/块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态</u>。</li>\n<li>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</li>\n</ul>\n<h2> 什么是线程上下文切换?</h2>\n<p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。</p>\n<ul>\n<li>主动让出 CPU，比如调用了 <code>sleep()</code>, <code>wait()</code> 等。</li>\n<li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。</li>\n<li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li>\n<li>被终止或结束运行</li>\n</ul>\n<p>这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 <strong>上下文切换</strong>。</p>\n<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>\n<h2> 什么是线程死锁?如何避免死锁?</h2>\n<h3> 认识线程死锁</h3>\n<p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>\n<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>\n<p></p>\n<p>死锁例子：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Output</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>\n<p>上面的例子符合产生死锁的四个必要条件：</p>\n<ol>\n<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>\n<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>\n<li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li>\n</ol>\n<h3> 如何预防和避免线程死锁?</h3>\n<p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>\n<ol>\n<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>\n<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>\n<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>\n</ol>\n<h2> sleep() 方法和 wait() 方法对比</h2>\n<p><strong>共同点</strong> ：两者都可以暂停线程的执行。</p>\n<p><strong>区别</strong> ：</p>\n<ul>\n<li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li>\n<li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li>\n<li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li>\n<li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。为什么这样设计呢？</li>\n</ul>\n<h2> yield</h2>\n<p>yield 即 \"谦让\"，也是 Thread 类的方法。它让掉当前线程 CPU的时间片，使正在运行中的线程重新变成就绪状态， 并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。</p>\n<p>yield 和 sleep 的异同</p>\n<ul>\n<li>yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。</li>\n<li>yield,sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。</li>\n<li>yield 不能被中断，而 sleep 则可以接受中断</li>\n</ul>\n<p>如果一定要用它的话，一句话解释就是：yield 方法可以很好的控制多线程，如执行某项复杂的任务时，如果担心占用资源过多，\n可以在完成某个重要的工作后使用 yield 方法让掉当前 CPU 的调度权，等下次获取到再继续执行，这样不但能完成自己的重要工作，\n也能给其他线程一些运行的机会，避免一个线程长时间占有 CPU 资源。</p>\n<ul>\n<li>yield仅能使一个线程从转到，而。</li>\n<li>yield不能保证使得当前正在运行的线程迅速转换到就绪状态。</li>\n<li>即使完成了迅速切换，系统通过线程调度机制从所有就绪线程中挑选下一个执行线程时，\n就绪的线程有可能被选中，也有可能不被选中，其调度的过程受到其他因素（如优先级）的影响</li>\n</ul>\n<h2> 为什么 wait() 方法不定义在 Thread 中？</h2>\n<p><code>wait()</code> 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（<code>Object</code>）而非当前的线程（<code>Thread</code>）。</p>\n<p>类似的问题：<strong>为什么 <code>sleep()</code> 方法定义在 <code>Thread</code> 中？</strong></p>\n<p>因为 <code>sleep()</code> 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>\n<h2> 可以直接调用 Thread 类的 run 方法吗？</h2>\n<p>这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>\n<p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>\n<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>\n<h2> java 内存模型</h2>\n<p>JMM(Java内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。要想理解透彻 JMM（Java 内存模型），我们先要从 CPU 缓存模型和指令重排序 说起！</p>\n<h3> 从 CPU 缓存模型说起</h3>\n<p><strong>为什么要弄一个 CPU 高速缓存呢？</strong> 类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 <strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</strong></p>\n<p>我们甚至可以把 <strong>内存看作外存的高速缓存</strong>，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。</p>\n<p>总结：<strong>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</strong></p>\n<h3> 指令重排序</h3>\n<p>说完了 CPU 缓存模型，我们再来看看另外一个比较重要的概念 <strong>指令重排序</strong> 。</p>\n<p>为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。</p>\n<p><strong>什么是指令重排序？</strong> 简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。</p>\n<p>常见的指令重排序有下面 2 种情况：</p>\n<ul>\n<li><strong>编译器优化重排</strong> ：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。</li>\n<li><strong>指令并行重排</strong> ：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>\n</ul>\n<p>另外，内存系统也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题。</p>\n<p>Java 源代码会经历 <strong>编译器优化重排 —&gt; 指令并行重排 —&gt; 内存系统重排</strong> 的过程，最终才变成操作系统可执行的指令序列。</p>\n<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>\n<p>编译器和处理器的指令重排序的处理方式不一样。对于编译器，通过禁止特定类型的编译器重排序的方式来禁止重排序。对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。</p>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">内存屏障</p>\n<p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 CPU 指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障变量的可见性。</p>\n</div>\n<h2> JMM(Java Memory Model)</h2>\n<h3> 什么是 JMM？为什么需要 JMM？</h3>\n<ul>\n<li>Java 语言是跨平台的</li>\n</ul>\n<p>一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</p>\n<ul>\n<li>对并发编程的支持</li>\n</ul>\n<p>JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的</p>\n<h3> JMM 是如何抽象线程和主内存之间的关系？</h3>\n<p><strong>Java 内存模型（JMM）</strong> 抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。</p>\n<p>在 JDK1.2 之前，Java 的内存模型实现总是从 <strong>主存</strong> （即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。</p>\n<p><strong>什么是主内存？什么是本地内存？</strong></p>\n<ul>\n<li><strong>主内存</strong> ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</li>\n<li><strong>本地内存</strong> ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</li>\n</ul>\n<p>Java 内存模型的抽象示意图如下</p>\n<p></p>\n<p>从上图来看，线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：</p>\n<ol>\n<li>线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。</li>\n<li>线程 2 到主存中读取对应的共享变量的值。</li>\n</ol>\n<p>也就是说，JMM 为共享变量提供了可见性的保障。</p>\n<p>不过，多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。举个例子：</p>\n<ol>\n<li>线程 1 和线程 2 分别对同一个共享变量进行操作，一个执行修改，一个执行读取。</li>\n<li>线程 2 读取到的是线程 1 修改之前的值还是修改后的值并不确定，都有可能，因为线程 1 和线程 2 都是先将共享变量从主内存拷贝到对应线程的工作内存中。</li>\n</ol>\n<p>关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作（了解即可，无需死记硬背）：</p>\n<ul>\n<li><strong>锁定（lock）</strong>: 作用于主内存中的变量，将他标记为一个线程独享变量。</li>\n<li><strong>解锁（unlock）</strong>: 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。</li>\n<li><strong>read（读取）</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li>\n<li><strong>load(载入)</strong>：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。</li>\n<li><strong>use(使用)</strong>：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li>\n<li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>\n<li><strong>store（存储）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li>\n<li><strong>write（写入）</strong>：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>\n</ul>\n<p>除了这 8 种同步操作之外，还规定了下面这些同步规则来保证这些同步操作的正确执行（了解即可，无需死记硬背）：</p>\n<ul>\n<li>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。</li>\n<li>一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</li>\n<li>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</li>\n<li>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</li>\n<li>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</li>\n<li>......</li>\n</ul>\n<h3> Java 内存区域和 JMM 有何区别？</h3>\n<p>这是一个比较常见的问题，很多初学者非常容易搞混。 <strong>Java 内存区域和内存模型是完全不一样的两个东西</strong> ：</p>\n<ul>\n<li>JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。</li>\n<li>Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>\n</ul>\n<h2> 并发编程三个重要特性</h2>\n<h3> 1️⃣ 原子性</h3>\n<p>一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。\n在 Java 中，可以借助<code>synchronized</code> 、各种 <code>Lock</code> 以及各种原子类实现原子性。\n<code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p>\n<h3> 2️⃣ 可见性</h3>\n<p>当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。\n在 Java 中，可以借助<code>synchronized</code> 、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。\n如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\n<h3> 3️⃣ 有序性</h3>\n<p>由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。\n我们上面讲重排序的时候也提到过：</p>\n<blockquote>\n<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong> ，所以在多线程下，指令重排序可能会导致一些问题。</p>\n</blockquote>\n<p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>\n",
      "date_modified": "2023-08-03T23:47:31.270Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "并发编程下",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/concurrency/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8B.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/concurrency/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8B.html",
      "summary": "volatile 关键字 如何保证变量的可见性？ 在 Java 中，volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。 volatile 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 volatile 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。",
      "content_html": "<h2> volatile 关键字</h2>\n<h3> 如何保证变量的可见性？</h3>\n<p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\n<p><code>volatile</code> 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\n<p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p>\n<h3> 如何禁止指令重排序？</h3>\n<p><strong>在 Java 中，<code>volatile</code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p>\n<p>在 Java 中，<code>Unsafe</code> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>理论上来说，你通过这个三个方法也可以实现和<code>volatile</code>禁止重排序一样的效果，只是会麻烦一些。</p>\n<p>下面我以一个常见的面试题为例讲解一下 <code>volatile</code> 关键字禁止指令重排序的效果。</p>\n<p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p>\n<p><strong>双重校验锁实现对象单例（线程安全）</strong> ：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>\n<ol>\n<li>为 <code>uniqueInstance</code> 分配内存空间</li>\n<li>初始化 <code>uniqueInstance</code></li>\n<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>\n</ol>\n<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p>\n<h3> volatile 可以保证原子性么？</h3>\n<p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p>\n<h2> 乐观锁和悲观锁</h2>\n<h3> 什么是悲观锁？</h3>\n<p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p>\n<p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p>\n<h3> 什么是乐观锁？</h3>\n<p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p>\n<p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p>\n<p>不过，大量失败重试的问题也是可以解决的，像我们前面提到的 <code>LongAdder</code>以空间换时间的方式就解决了这个问题。</p>\n<p>理论上来说：</p>\n<ul>\n<li>悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li>\n<li>乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li>\n</ul>\n<h3> 如何实现乐观锁？</h3>\n<p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p>\n<h4> 版本号机制</h4>\n<p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p>\n<p><strong>举一个简单的例子</strong> ：假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ <code>balance</code> ）为 $100 。</p>\n<ol>\n<li>操作员 A 此时将其读出（ <code>version</code>=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li>\n<li>在操作员 A 操作的过程中，操作员 B 也读入此用户信息（ <code>version</code>=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li>\n<li>操作员 A 完成了修改工作，将数据版本号（ <code>version</code>=1 ），连同帐户扣除后余额（ <code>balance</code>=$50 ），提交至数据库更新，此时由于提交数据版本等于数据库记录当前版本，数据被更新，数据库记录 <code>version</code> 更新为 2 。</li>\n<li>操作员 B 完成了操作，也将版本号（ <code>version</code>=1 ）试图向数据库提交数据（ <code>balance</code>=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 1 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须等于当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li>\n</ol>\n<p>这样就避免了操作员 B 用基于 <code>version</code>=1 的旧数据修改的结果覆盖操作员 A 的操作结果的可能。</p>\n<h4> CAS 算法</h4>\n<p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p>\n<p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p>\n<blockquote>\n<p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p>\n</blockquote>\n<p>CAS 涉及到三个操作数：</p>\n<ul>\n<li><strong>V</strong> ：要更新的变量值(Var)</li>\n<li><strong>E</strong> ：预期值(Expected)</li>\n<li><strong>N</strong> ：拟写入的新值(New)</li>\n</ul>\n<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p>\n<p><strong>举一个简单的例子</strong> ：线程 A 要修改变量 i 的值为 6，i 原值为 1（V = 1，E=1，N=6，假设不存在 ABA 问题）。</p>\n<ol>\n<li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li>\n<li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li>\n</ol>\n<p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>\n<p>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。</p>\n<p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 乐观锁存在哪些问题？</h3>\n<p>ABA 问题是乐观锁最常见的问题。</p>\n<h4> ABA 问题</h4>\n<p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>\"ABA\"问题。</strong></p>\n<p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 循环时间长开销大</h4>\n<p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>\n<p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p>\n<ol>\n<li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li>\n<li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。</li>\n</ol>\n<h4> 只能保证一个共享变量的原子操作</h4>\n<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p>\n",
      "date_modified": "2023-08-03T23:47:31.276Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "线程池",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/concurrency/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/concurrency/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html",
      "summary": "参考 线程池大小 + 线程数量到底设置多少？ 线程池的优点 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源， 还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1832455\" target=\"_blank\" rel=\"noopener noreferrer\">线程池大小 + 线程数量到底设置多少？</a></p>\n</div>\n<h2> 线程池的优点</h2>\n<ul>\n<li>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>\n<li>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，\n还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>\n</ul>\n<h2> ThreadPoolExecutor 重要参数</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 核心参数解释</h3>\n<ul>\n<li>1、corePoolSize</li>\n</ul>\n<p>​     核心池的大小。在创建了线程池之后，默认情况下，线程池中没有任何线程，而是等待有任务到来才创建线程去执行任务。默认情况下，在创建了线程池之后，线程池钟的线程数为0，当有任务到来后就会创建一个线程去执行任务</p>\n<ul>\n<li>\n<p>2、maximumPoolSize</p>\n<p>池中允许的最大线程数，这个参数表示了线程池中最多能创建的线程数量，当任务数量比 corePoolSize 大时，任务添加到workQueue，当 workQueue 满了，将继续创建线程以处理任务，maximumPoolSize 表示的就是 wordQueue 满了，线程池中最多可以创建的线程数量</p>\n</li>\n<li>\n<p>3、keepAliveTime</p>\n</li>\n</ul>\n<p>​    只有当线程池中的线程数大于corePoolSize时，这个参数才会起作用。当线程数大于 corePoolSize 时，终止前多余的空闲线程等待新任务的最长时间</p>\n<ul>\n<li>\n<p>4、unit</p>\n<p>keepAliveTime时间单位</p>\n</li>\n<li>\n<p>5、workQueue</p>\n</li>\n</ul>\n<p>​    存储还没来得及执行的任务</p>\n<ul>\n<li>6、threadFactory</li>\n</ul>\n<p>​    执行程序创建新线程时使用的工厂</p>\n<ul>\n<li>\n<p>7、handler(拒绝策略)</p>\n<p>由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序</p>\n</li>\n</ul>\n<h3> 参数之间的关系</h3>\n<p>1、池中线程数小于 corePoolSize，新任务都不排队而是直接添加新线程</p>\n<p>2、池中线程数大于等于 corePoolSize，workQueue未满，首选将新任务加入workQueue而不是添加新线程</p>\n<p>3、池中线程数大于等于 corePoolSize，workQueue已满，但是线程数小于maximumPoolSize，添加新的线程来处理被添加的任务</p>\n<p>4、池中线程数大于大于 corePoolSize，workQueue已满，并且线程数大于等于maximumPoolSize，新任务被拒绝，使用handler处理被拒绝的任务</p>\n<h3> 拒绝策略</h3>\n<p>决绝策略的父接口是 RejectedExecutionHandler，JDK本身在 ThreadPoolExecutor里给用户提供了四种拒绝策略，看一下：\n1、AbortPolicy</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2、CallerRunsPolicy</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>3、DiscardOldestPolicy</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>4、DiscardPolicy</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 任务类型</h2>\n<h3> CPU 密集型</h3>\n<p>主要靠CPU进行计算类的任务</p>\n<h3> IO 密集型</h3>\n<p>主要设计IO类型的任务，例如从mysql中查询数据、读取网络中的数据、读取硬盘上的数据</p>\n<h2> 线程数量与任务类型的关系</h2>\n<h3> 与CPU任务类型的关系</h3>\n<p>一般情况下,<em><strong>CPU核心数 == 最大同时执行线程数</strong></em>.在这种情况下(设CPU核心数为n),大量客户端会发送请求到服务器,但是服务器最多只能同时执行n个线程.</p>\n<p>设线程池工作队列长度为m,且m&gt;&gt;n,则此时会导致CPU频繁切换线程来执行(如果CPU使用的是FCFS,则不会频繁切换,如使用的是其他CPU调度算法,如时间片轮转法,最短时间优先,则可能会导致频繁的线程切换).</p>\n<p>所以这种情况下,无需设置过大的线程池工作队列,(<em><strong>工作队列长度 = CPU核心数 || CPU核心数+1)</strong></em> 即可.</p>\n<h3> 与IO任务类型的关系</h3>\n<p>1个线程对应1个方法栈,线程的生命周期与方法栈相同.</p>\n<p>比如某个线程的方法栈对应的入站顺序为:controller()-&gt;service()-&gt;DAO(),由于DAO长时间的I/O操作,导致该线程一直处于工作队列,但它又不占用CPU,则此时有1个CPU是处于空闲状态的.</p>\n<p>所以,这种情况下,应该加大线程池工作队列的长度(如果CPU调度算法使用的是FCFS,则无法切换),尽量不让CPU空闲下来,提高CPU利用率,线程数可以设置为：<em><strong>线程数 == 2n+1</strong></em> ,n为CPU核心数.</p>\n<h2> 线程池大小 + 线程数量到底设置多少？</h2>\n<p>可能很多人都看到过一个线程数设置的理论：</p>\n\n<p>不会吧，不会吧，真的有人按照这个理论规划线程数？</p>\n<p>测试环境：AMD Ryzen 5 3600, 6 - Core, 12 - Threads</p>\n<p>AMD 3600，6核心12线程（超线程），我们可以简单的认为它就是12核心CPU。那么我这个CPU就可以同时做12件事，互不打扰。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>线程数和CPU利用率的小总结</p>\n<p>上面的例子，只是辅助，为了更好的理解线程数/程序行为/CPU状态的关系，来简单总结一下：</p>\n<ul>\n<li>一个极端的线程（不停执行“计算”型操作时），就可以把单个核心的利用率跑满，多核心CPU最多只能同时执行等于核心数的“极端”线程数\n如果每个线程都这么“极端”，且同时执行的线程数超过核心数，会导致不必要的切换，造成负载过高，只会让执行更慢</li>\n<li>I/O 等暂停类操作时，CPU处于空闲状态，操作系统调度CPU执行其他线程，可以提高CPU利用率，同时执行更多的线程</li>\n<li>I/O 事件的频率频率越高，或者等待/暂停时间越长，CPU的空闲时间也就更长，利用率越低，操作系统可以调度CPU执行更多的线程</li>\n</ul>\n<p>线程数规划的公式</p>\n<p>前面的铺垫，都是为了帮助理解，现在来看看书本上的定义。《Java 并发编程实战》介绍了一个线程数计算的公式：</p>\n<p></p>\n<p></p>\n",
      "date_modified": "2023-08-03T23:47:31.282Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "io 基础",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/io/io-basis.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/io/io-basis.html",
      "summary": "参考 Java IO详解 java I/O流详解",
      "content_html": "<div class=\"hint-container info\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://www.jianshu.com/p/aea76bc0e6d1\" target=\"_blank\" rel=\"noopener noreferrer\">Java IO详解</a></p>\n<p><a href=\"https://juejin.cn/post/6844903910348603405\" target=\"_blank\" rel=\"noopener noreferrer\">java I/O流详解 </a></p>\n</div>\n<p>IO 是什么？其实就是Java中的一种输入和输出功能，也可以理解为对文件的写入和读出的操作，只不过Java中对这种操作叫做对流的操作。而流不只是对文件进行读写，还可以对内存，网络，程度操作。</p>\n<h2> 字节与字符</h2>\n<p>在Java中有输入、输出两种IO流，每种输入、输出流又分为字节流和字符流两大类。</p>\n<p>关于字节，每个字节<code>(byte)</code>有 <code>8bit</code> 组成。\n关于字符，我们可能知道代表一个汉字或者英文字母。</p>\n<p>字节与字符之间的关系\nJava采用<code>unicode</code>编码，通讲，<code>2个字节</code>来表示<code>一个字符</code>。\n在<code>0~127</code>整数之间的<code>字符映射</code>，<code>unicode</code>向下兼容<code>ASCII</code>，也就是1个字节表示一个字符。\n一个中文或英文字符的<code>unicode</code>编码都占<code>2个字节</code>。</p>\n<h2> File</h2>\n<p>文件和文件夹的操作都可以用File来完成。</p>\n<p>文件的获取</p>\n<p></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 文件创建及删除</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 判断方法</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 获取参数方法</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中 <code>FilenameFileter</code> 是一个文件过滤器。找到所有png图片。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> IO 流</h2>\n<p>Java的IO流是实现<code>输入/输出</code>的基础，它可以方便地实现数据的<code>输入/输出</code>操作，在Java中把不同的<code>输入/输出</code>源抽象表述为\"流\"。</p>\n<p>流是一组有顺序的字节集合，是对数据传输的总称或抽象。</p>\n<p>流有输入和输出，输入时是流从数据源流向程序。输出时是流从程序传向数据源，而数据源可以是内存，文件，网络或程序等。</p>\n<h3> 分类</h3>\n\n<h3> 4中基本方式和实例</h3>\n<p></p>\n<ul>\n<li>inputStream</li>\n<li>outputStream</li>\n<li>Reader</li>\n<li>Write</li>\n</ul>\n<p>四大抽象基类，其中<code>inputStream</code>，<code>outputStream</code> 是<code>字节流</code>的基类，\n<code>Reader</code>，<code>Write</code>是<code>字符流</code>的基类。不能创建实例，但是为所有实现类提供了基础的模板。</p>\n<h3> inputStream</h3>\n<p></p>\n<h3> outputStream</h3>\n<p></p>\n<h3> reader</h3>\n<p></p>\n<h3> write</h3>\n<p></p>\n<h3> 总结：</h3>\n<p>从上面的方法中我可以看出。inputStream和reader，outputStream与write的函数都很相似，并且每次进行了IO操作，要记得close，因为IO资源并不属于内存资源，并不会被GC回收。所以需要显示的 手动的回收资源。对于输出操作，close还会自动flush。</p>\n<h2> RandomAccessFile 的使用与简介</h2>\n<p>我们在对文件的操作过程中，除了使用<code>字节流和字符流</code>的方式之外，我们还可以使用 <code>RandomAcessFile</code> 这个工具类来实现。</p>\n<p><code>RandomAccessFile</code>可以实现对文件的<code>读 和 写</code>，但是他并不是继承于以上4中基本虚拟类。</p>\n<p>而且在对文件的操作中，<code>RandomAccessFile</code> 有一个巨大的优势，他可以支持文件的随机访问，\n程序快可以直接跳转到文件的任意地方来读写数据。所以如果需要访问文件的部分内容，而不是把文件从头读到尾，\n使用<code>RandomAccessFile</code>将是更好的选择。</p>\n<p><code>RandomAccessFile</code>的方法虽然多，但它有一个最大的局限，就是只能<code>读写文件</code>，不能读写其他IO节点。</p>\n<p><code>RandomAccessFile</code>的一个重要使用场景就是网络请求中的多线程下载及断点续传。\n构造方法以及参数</p>\n<p></p>\n<p>mode中，有4中启动的方式</p>\n<ul>\n<li>\"r\" 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。</li>\n<li>\"rw\" 打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。</li>\n<li>\"rws\" 打开以便读取和写入，对于 \"rw\"，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。</li>\n<li>\"rwd\" 打开以便读取和写入，对于 \"rw\"，还要求对文件内容的每个更新都同步写入到底层存储设备。</li>\n</ul>\n<h3> RandomAccessFile使用</h3>\n<p>读取文件内容</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>写入文件内容</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意：<code>RandomAccessFile</code> 虽然可以设置了偏移的方法，但他不能实现中间插入的效果，\n如果你需要实现文本中间插入的话，要先将后面的文件内容拷贝，然后写入，最后在写入的写一行，将拷贝的东西复制回来。</p>\n<h2> 对象的序列化与反序列化</h2>\n<p>什么是序列化和反序列化呢？这是针对对象来说的，因为我们在写入文件的时候，常常因为要保存的是一个对象，也就是一个obj，但是里面的变量又很多，我们不可能挨个申明，一个个写入，这时候，我们就可以使用对象的序列化与反序列化。</p>\n<p>序列化就是对象到保存文件的过程。\n反序列化就是从保存的文件，转换为对象的过程。</p>\n<p>我们使用ObjectOutputStream和ObjectInputStream 实现对象的序列化和反序列化</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 节点流</h2>\n<p>节点流--直接连接数据源的流</p>\n<p></p>\n<h3> 常见的节点流</h3>\n<p></p>\n<p>File 文件流。对文件进行读、写操作 ：\n<code>FileReader、FileWriter、FileInputStream、FileOutputStream</code>。</p>\n<p>从/向内存数组读写数据: <code>CharArrayReader</code> 与 <code>CharArrayWriter</code>、<code>ByteArrayInputStream</code>与<code>ByteArrayOutputStream</code>。</p>\n<p>从/向内存字符串读写数据 <code>StringReader、StringWriter、StringBufferInputStream</code>。</p>\n<p><code>Pipe</code>管道流。 实现管道的输入和输出（进程间通信）: <code>PipedReader</code>与<code>PipedWriter</code>、<code>PipedInputStream</code>与<code>PipedOutputStream</code>。</p>\n<h2> 处理流--连接已存在的流</h2>\n<p></p>\n<h3> 常见的处理流</h3>\n<p></p>\n<ul>\n<li><code>Buffering</code>缓冲流：在读入或写出时，对数据进行缓存，以减少I/O的次数：<code>BufferedReader</code>与<code>BufferedWriter、BufferedInputStream</code>与<code>BufferedOutputStream</code>。</li>\n<li><code>Filtering</code> 滤流：在数据进行读或写时进行过滤：<code>FilterReader与FilterWriter、FilterInputStream与FilterOutputStream</code>。\n<code>Converting between Bytes and Characters </code>转换流：按照一定的编码/解码标准将字节流转换为字符流，或进行反向转换（<code>Stream</code>到<code>Reader</code>）：<code>InputStreamReader、OutputStreamWriter</code>。</li>\n<li><code>Object Serialization</code> 对象流 ：<code>ObjectInputStream、ObjectOutputStream</code>。</li>\n<li><code>DataConversion</code>数据流： 按基本数据类型读、写（处理的数据是Java的基本类型（如布尔型，字节，整数和浮点数））：<code>DataInputStream、DataOutputStream</code> 。</li>\n<li><code>Counting</code>计数流： 在读入数据时对行记数 ：<code>LineNumberReader、LineNumberInputStream</code>。</li>\n<li><code>Peeking Ahead</code>预读流： 通过缓存机制，进行预读 ：<code>PushbackReader、PushbackInputStream</code>。</li>\n<li><code>Printing</code>打印流： 包含方便的打印方法 ：<code>PrintWriter、PrintStream</code>。</li>\n</ul>\n<h2> 代码示例</h2>\n<h3> FileInputStream &amp; FileOutputStream</h3>\n<p><code>FileInputStream &amp; FileOutputStream</code> 可以从文件系统中 <code>读取/写入</code> 诸如图像数据之类的原始字节流。\n以下是 使用 <code>FileInputStream &amp; FileOutputStream</code> 实现文件拷贝的案例</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> DataInputStream &amp; DataOutputStream</h3>\n<p><code>DataInputStream &amp; DataOutputStream</code>，是处理流，改构造方法接收一个已存在的输入输出流，\n允许程序从读取方便快捷 操作java的基本数据类型。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> BufferedInputStream &amp; BufferedOutputStream</h3>\n<p>BufferedInputStream &amp; BufferedOutputStream 为另一个输入输出流流添加一些功能，即缓冲区的作用。在创建 BufferedInputStream &amp; BufferedOutputStream 时，会创建一个内部缓冲区数组。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> PrintStream</h3>\n<p>PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> ByteArrayInputStream &amp; ByteArrayInputStream</h3>\n<p><code>ByteArrayInputStream &amp; ByteArrayInputStream</code> 包含一个内部缓冲区(实际上就是把数据写入内存，然后再读取)，\n该缓冲区包含从流中读取的字节。内部计数器跟踪 read 方法要提供的下一个字节,</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> InputStreamReader &amp; OutputStreamWriter</h3>\n<p>java 在jdk1.1种提供了，针对字符处理的 方便类,字符流，将原来的字节流，增加了 字符编码表 编码处理功能\n字节流到字符流的转换流，<code>read（）</code>和<code>writer（）</code>方法会一次输入输出多个字节，以包装字符转换有效，\n<code>字节流 + 编码表 = InputStreamReader &amp; OutputStreamWriter</code></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> FileReader &amp; FileWriter</h3>\n<p>在只针对将字符写入文件的时候，因为 每次使用 转换流，对字节流进行包装，写法太麻烦，所以jdk 提供了 字节转换流子类FileReader &amp; FileWriter，方便的进行字符文件的IO操作</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> BufferedReader &amp; BufferedWriter</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> StringReader &amp; StringWriter</h3>\n<p>方便快捷的将字符串写入内存，或从内存读取</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_modified": "2023-08-03T23:47:31.308Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "io model",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/io/io-model.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/io/io-model.html",
      "content_html": "",
      "date_modified": "2023-08-03T23:47:31.309Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "内存区域详解(重点)",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/jvm/%E5%86%85%E5%AD%98%E5%8C%BA.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/jvm/%E5%86%85%E5%AD%98%E5%8C%BA.html",
      "summary": "如果没有特殊说明，都是针对的是 HotSpot 虚拟机。 本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。 常见面试题 ： 介绍下 Java 内存区域（运行时数据区） Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么） 对象的访问定位的两种方式（句柄和直接指针两种方式） 前言 对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。",
      "content_html": "<blockquote>\n<p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p>\n<p>本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。</p>\n<p>常见面试题 ：</p>\n<ul>\n<li>介绍下 Java 内存区域（运行时数据区）</li>\n<li>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</li>\n<li>对象的访问定位的两种方式（句柄和直接指针两种方式）</li>\n</ul>\n</blockquote>\n<h2> 前言</h2>\n<p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>\n<h2> 为什么要内存划分</h2>\n<h2> 运行时数据区域</h2>\n<p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。</p>\n<p><strong>JDK 1.8 之前</strong> ：</p>\n<p></p>\n<p><strong>JDK 1.8 之后</strong> ：</p>\n<p></p>\n<p><strong>线程私有的：</strong></p>\n<ul>\n<li>程序计数器</li>\n<li>虚拟机栈</li>\n<li>本地方法栈</li>\n</ul>\n<p><strong>线程共享的：</strong></p>\n<ul>\n<li>堆</li>\n<li>方法区</li>\n<li>直接内存 (非运行时数据区的一部分)</li>\n</ul>\n<p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p>\n<h3> 程序计数器</h3>\n<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，<u>分支、循环、跳转、异常处理、线程恢复</u>等功能都需要依赖这个计数器来完成。</p>\n<p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>\n<p>从上面的介绍中我们知道了程序计数器主要有两个作用：</p>\n<ul>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：<u>顺序执行、选择、循环、异常处理</u>。</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n</ul>\n<p>⚠️ 注意 ：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>\n<h3> Java 虚拟机栈</h3>\n<p>与程序计数器一样，Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p>\n<p>栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。</p>\n<p>方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p>\n<p>栈由一个个栈帧组成，而每个栈帧中都拥有：<u>局部变量表、操作数栈、动态链接、方法返回地址</u>。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p>\n<p></p>\n<p><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>\n<p></p>\n<p><strong>操作数栈</strong> 主要作为<u>方法调用的中转站</u>使用，用于存放方法执行过程中产生的<u>中间计算结果</u>。另外，计算过程中产生的临时变量也会放在操作数栈中。</p>\n<p><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。<code>Class </code>文件的常量池里保存有大量的<code>符号引用</code>比如<code>方法引用的符号引用</code>。当一个方法要调用其他方法，需要将常量池中指向方法的<u>符号引用转化为其在内存地址中的直接引用</u>。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong> 。</p>\n<p></p>\n<p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p>\n<p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p>\n<p>除了 <code>StackOverFlowError</code> 错误之外，栈还可能会出现<code>OutOfMemoryError</code>错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p>\n<p>简单总结一下程序运行中栈可能会出现两种错误：</p>\n<ul>\n<li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li>\n<li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li>\n</ul>\n<p></p>\n<h3> 本地方法栈</h3>\n<p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>\n<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>\n<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p>\n<h3> 堆</h3>\n<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>\n<p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>\n<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>\n<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>\n<ol>\n<li>新生代内存(Young Generation)</li>\n<li>老生代(Old Generation)</li>\n<li>永久代(Permanent Generation)</li>\n</ol>\n<p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p>\n<p></p>\n<p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong> （我会在方法区这部分内容详细介绍到）。</p>\n<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>\n<blockquote>\n<p>修正：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p>\n<p><strong>动态年龄计算的代码如下</strong></p>\n<div class=\"language-c++ line-numbers-mode\" data-ext=\"c++\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></blockquote>\n<p>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p>\n<ol>\n<li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>\n<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值，详见：<a href=\"https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size\" target=\"_blank\" rel=\"noopener noreferrer\">Default Java 8 max heap size</a>)</li>\n<li>......</li>\n</ol>\n<h3> 方法区</h3>\n<p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p>\n<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，方法区到底要如何实现那就是虚拟机自己要考虑的事情了。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。</p>\n<p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>\n<p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，<em><strong>接口可以看作是方法区</strong></em>，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p>\n<p></p>\n<p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p>\n<p>下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5</p>\n<p></p>\n<p>1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>\n<blockquote>\n<p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>\n</blockquote>\n<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>\n<p>2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>\n<p>3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>\n<p><strong>方法区常用参数有哪些？</strong></p>\n<p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>\n<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。下面是一些常用参数：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>\n<h3> 运行时常量池</h3>\n<p>Class 文件中除了有<u>类的版本、字段、方法、接口</u>等描述信息外，还有用于存放编译期生成的各种<code>字面量（Literal）</code>和<code>符号引用（Symbolic Reference）</code>的 <strong>常量池表(Constant Pool Table)</strong> 。</p>\n<p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。<code>字面量包括整数、浮点数和字符串字面量</code>。常见的<code>符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号</code>。</p>\n<p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p>\n<p></p>\n<p>常量池表会在类加载后存放到方法区的运行时常量池中。</p>\n<p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p>\n<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p>\n<h3> 字符串常量池</h3>\n<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p>\n<p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p>\n<p>\n</p>\n<p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p>\n<p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>\n<p>相关问题：<a href=\"https://www.zhihu.com/question/57109429/answer/151717241\" target=\"_blank\" rel=\"noopener noreferrer\">JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX - 知乎</a></p>\n<p>最后再来分享一段周志明老师在<a href=\"https://github.com/fenixsoft/jvm_book\" target=\"_blank\" rel=\"noopener noreferrer\">《深入理解 Java 虚拟机（第 3 版）》样例代码&amp;勘误</a> Github 仓库的 <a href=\"https://github.com/fenixsoft/jvm_book/issues/112\" target=\"_blank\" rel=\"noopener noreferrer\">issue#112</a> 中说过的话：</p>\n<blockquote>\n<p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p>\n</blockquote>\n<h3> 直接内存</h3>\n<p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</p>\n<p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p>\n<p>JDK1.4 中新加入的 <strong>NIO（Non-Blocking I/O，也被称为New I/O）</strong>，引入了一种基于<strong>通道（Channel）<strong>与</strong>缓存区（Buffer）<strong>的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为</strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>\n<p>直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>\n<p>类似的概念还有 <strong>堆外内存</strong> 。在一些文章中将直接内存等价于堆外内，个人觉得不是特别准确。</p>\n<p>堆外内存就是把内存对象分配在堆（新生代+老年代+永久代）以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</p>\n<h2> HotSpot 虚拟机对象探秘</h2>\n<p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>\n<h3> 对象的创建(重点)</h3>\n<p>Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。</p>\n<h4> Step1:类加载检查</h4>\n<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>\n<h4> Step2:分配内存</h4>\n<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>\n<p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p>\n<ul>\n<li>指针碰撞 ：\n<ul>\n<li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li>\n<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>\n<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>\n</ul>\n</li>\n<li>空闲列表 ：\n<ul>\n<li>适用场合 ： 堆内存不规整的情况下。</li>\n<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>\n<li>使用该分配方式的 GC 收集器：CMS</li>\n</ul>\n</li>\n</ul>\n<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是\"标记-清除\"，还是\"标记-整理\"（也称作\"标记-压缩\"），值得注意的是，复制算法内存也是规整的。</p>\n<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>\n<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>\n<ul>\n<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>\n<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>\n</ul>\n<h4> Step3:初始化零值</h4>\n<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>\n<h4> Step4:设置对象头</h4>\n<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>\n<h4> Step5:执行 init 方法</h4>\n<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>\n<h3> 对象的内存布局</h3>\n<p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<u><strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong></u>。</p>\n<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>\n<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>\n<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>\n<h3> 对象的访问定位</h3>\n<p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p>\n<h4> 句柄</h4>\n<p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p>\n<p></p>\n<h4> 直接指针</h4>\n<p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p>\n<p></p>\n<p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>\n<p>HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。</p>\n",
      "date_modified": "2023-08-03T23:47:31.321Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "垃圾回收详解(重点)",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html",
      "summary": "如果没有特殊说明，都是针对的是 HotSpot 虚拟机。 本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。 常见面试题 ： 如何判断对象是否死亡（两种方法）。 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。 如何判断一个常量是废弃常量 如何判断一个类是无用的类 垃圾收集有哪些算法，各自的特点？ HotSpot 为什么要分为新生代和老年代？ 常见的垃圾回收器有哪些？ 介绍一下 CMS,G1 收集器。 Minor Gc 和 Full GC 有什么不同呢？",
      "content_html": "<blockquote>\n<p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p>\n<p>本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。</p>\n<p>常见面试题 ：</p>\n<ul>\n<li>如何判断对象是否死亡（两种方法）。</li>\n<li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li>\n<li>如何判断一个常量是废弃常量</li>\n<li>如何判断一个类是无用的类</li>\n<li>垃圾收集有哪些算法，各自的特点？</li>\n<li>HotSpot 为什么要分为新生代和老年代？</li>\n<li>常见的垃圾回收器有哪些？</li>\n<li>介绍一下 CMS,G1 收集器。</li>\n<li>Minor Gc 和 Full GC 有什么不同呢？</li>\n</ul>\n</blockquote>\n<h2> 前言</h2>\n<p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>\n<h2> 堆空间的基本结构</h2>\n<p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>\n<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p>\n<p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p>\n<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>\n<ol>\n<li>新生代内存(Young Generation)</li>\n<li>老生代(Old Generation)</li>\n<li>永久代(Permanent Generation)</li>\n</ol>\n<p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p>\n<p></p>\n<p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong> 。</p>\n<p>关于堆空间结构更详细的介绍，可以回过头看看 <a href=\"/interview/java/jvm/%E5%86%85%E5%AD%98%E5%8C%BA.html\" target=\"blank\">Java 内存区域详解</a> 这篇文章。</p>\n<h2> 内存分配和回收原则</h2>\n<h3> 对象优先在 Eden 区分配</h3>\n<p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。下面我们来进行实际测试以下。</p>\n<p>测试代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 大对象直接进入老年代</h3>\n<p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>\n<p>大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>\n<h3> 长期存活的对象将进入老年代</h3>\n<p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p>\n<p>大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p>\n<p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>\n<blockquote>\n<p>修正：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p>\n<p>jdk8 官方文档引用 ：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html 。</p>\n</blockquote>\n<h3> 主要进行 gc 的区域</h3>\n<p>周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道：</p>\n<p>上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答：</p>\n<p></p>\n<p><strong>总结：</strong></p>\n<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>\n<p>部分收集 (Partial GC)：</p>\n<ul>\n<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li>\n<li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>\n<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>\n</ul>\n<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>\n<h3> 空间分配担保</h3>\n<p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p>\n<p>《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：</p>\n<blockquote>\n<p>JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p>\n<p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p>\n</blockquote>\n<h2> 死亡对象判断方法</h2>\n<p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p>\n<h3> 引用计数法</h3>\n<p>给对象中添加一个引用计数器：</p>\n<ul>\n<li>每当有一个地方引用它，计数器就加 1；</li>\n<li>当引用失效，计数器就减 1；</li>\n<li>任何时候计数器为 0 的对象就是不可能再被使用的。</li>\n</ul>\n<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p>\n<p>所谓对象之间的相互引用问题，如下面代码所示：除了对象 <code>objA</code> 和 <code>objB</code> 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 可达性分析算法</h3>\n<p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>\n<p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。</p>\n<p></p>\n<p><strong>哪些对象可以作为 GC Roots 呢？</strong></p>\n<ul>\n<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>\n<li>本地方法栈(Native 方法)中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>所有被同步锁持有的对象</li>\n</ul>\n<p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p>\n<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>\n<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>\n<blockquote>\n<p><code>Object</code> 类中的 <code>finalize</code> 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 <code>finalize</code> 方法会被逐渐弃用移除。忘掉它的存在吧！</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://openjdk.java.net/jeps/421\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 421: Deprecate Finalization for Removal</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/LW-paZAMD08DP_3-XCUxmg\" target=\"_blank\" rel=\"noopener noreferrer\">是时候忘掉 finalize 方法了</a></li>\n</ul>\n</blockquote>\n<h3> 引用类型总结</h3>\n<p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p>\n<p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p>\n<p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为<u>强引用、软引用、弱引用、虚引用</u>四种（引用强度逐渐减弱）</p>\n<p><strong>1．强引用（StrongReference）</strong></p>\n<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>\n<p><strong>2．软引用（SoftReference）</strong></p>\n<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果<u>内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存</u>。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>\n<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p><strong>3．弱引用（WeakReference）</strong></p>\n<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，<u>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</u>。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<p><strong>4．虚引用（PhantomReference）</strong></p>\n<p>\"虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>\n<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>\n<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>\n<h3> 如何判断一个常量是废弃常量？</h3>\n<p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p>\n<p><s><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></s></p>\n<blockquote>\n<p><strong>🐛 修正（参见：<a href=\"https://blog.csdn.net/q5706503/article/details/84640762\" target=\"_blank\" rel=\"noopener noreferrer\">reference</a>）</strong> ：</p>\n<ol>\n<li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li>\n<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li>\n<li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li>\n</ol>\n</blockquote>\n<p>假如在字符串常量池中存在字符串 \"abc\"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 \"abc\" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，\"abc\" 就会被系统清理出常量池了。</p>\n<h3> 如何判断一个类是无用的类</h3>\n<p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p>\n<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>\n<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>\n<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>\n<h2> 垃圾收集算法</h2>\n<h3> 标记-清除算法</h3>\n<p>该算法分为“标记”和“清除”阶段：首先<u>标记出所有不需要回收的对象</u>，在标记完成后统一<u>回收掉所有没有被标记的对象</u>。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>\n<ol>\n<li><strong>效率问题</strong></li>\n<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li>\n</ol>\n<p></p>\n<h3> 标记-复制算法</h3>\n<p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小<u>相同的两块</u>，每次使用其中的一块。当这一块的内存使用完后，就将还<u>存活的对象复制到另一块去</u>，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>\n<p></p>\n<h3> 标记-整理算法</h3>\n<p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所<u>有存活的对象向一端移动</u>，然后直接清理掉端边界以外的内存。</p>\n<p></p>\n<h3> 分代收集算法</h3>\n<p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>\n<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>\n<p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p>\n<p>根据上面的对分代收集算法的介绍回答。</p>\n<h2> 垃圾收集器</h2>\n<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>\n<p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p>\n<h3> Serial 收集器</h3>\n<p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>\"Stop The World\"</strong> ），直到它收集结束。</p>\n<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>\n<p></p>\n<p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>\n<p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p>\n<h3> ParNew 收集器</h3>\n<p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p>\n<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>\n<p></p>\n<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>\n<p><strong>并行和并发概念补充：</strong></p>\n<ul>\n<li>\n<p><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p>\n</li>\n<li>\n<p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p>\n</li>\n</ul>\n<h3> Parallel Scavenge 收集器</h3>\n<p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>Parallel Scavenge 收集器关注点是<u>吞吐量（高效率的利用 CPU）</u>。CMS 等垃圾收集器的关注点更多的是<u>用户线程的停顿时间</u>（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>\n<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>\n<p><strong>这是 JDK1.8 默认收集器</strong></p>\n<p>使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p>\n<h3> Serial Old 收集器</h3>\n<p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>\n<h3> Parallel Old 收集器</h3>\n<p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>\n<h3> CMS 收集器</h3>\n<p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p>\n<p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>\n<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>\n<ul>\n<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>\n<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>\n<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>\n<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>\n</ul>\n<p></p>\n<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>\n<ul>\n<li><strong>对 CPU 资源敏感；</strong></li>\n<li><strong>无法处理浮动垃圾；</strong></li>\n<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>\n</ul>\n<h3> G1 收集器</h3>\n<p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>\n<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p>\n<ul>\n<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>\n<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>\n<li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li>\n<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li>\n</ul>\n<p>参考\n<a href=\"https://blog.csdn.net/qq_41931364/article/details/107040928\" target=\"_blank\" rel=\"noopener noreferrer\">\"垃圾收集器G1和ZGC详解\"</a></p>\n<blockquote>\n<p>开启参数：-XX:+UseG1GC\nG1是面向服务器的一款垃圾收集器，主要针对于多核处理器的大内存机器，可以满足gc的停顿时间且保证吞吐量，一般8g以上推荐使用G1，G1抛弃了之前堆中严格的分代内存划分，如下图：</p>\n</blockquote>\n\n<blockquote>\n<p>G1对堆模型的处理转换成了如下图方式，将整个堆内存划分成一个个小的独立区域（Region），JVM最多可以有2048个Region，也可以用参数-XX:G1HeapRegionSize指定&gt;Region的大小，一般不推荐指定，虽然G1依然有分代内存划分，但抛弃了连续的分代，他们可以是一些不连续的Region集合，正因为这样，每一个Region区域的功能会发生变化，&gt;比如一个Region之前按是年轻代，在做完垃圾回收之后又变成了老年代。</p>\n</blockquote>\n\n<h3> 分代特性</h3>\n<p>年轻代：默认占整个堆的5%，可以通过设置-XX:G1NewSizePercent参数调整年轻代的初始占比，在运行过程中，JVM会动态的调整年轻代的占比，但最多不会超过整个堆的60%，最大占比也可以通过-XX:G1MaxNewSizePercent进行调整，年轻代的Eden区和Survivor区比例也是8:1:1。\nHumongous：专门放大对象的区域，当一个对象的大小超过了一个Region区域的50%，则为大对象，直接放到Humongous区，在MixedGC或Full gc的时候会回收。</p>\n<h3> g1 回收过程</h3>\n<blockquote>\n<p>由下图可以看出在初始标记，最终标记以及筛选回收都会STW，而且它没有并发重置。\n</p>\n</blockquote>\n<ul>\n<li>初始标记：先STW，并记录下gc roots直接能引用的对象，速度很快，如果不做STW，gc root会非常多。</li>\n<li>并发标记：根据初始标记的结果，做整个的一个可达性分析，找出所有的被引用的对象，这个过程耗时比较长(大约占整个收集过程的80%左右)，但是这个过程和用户线程并发执行，所以用户无感知，但是因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变(就比如在并发标记前是非垃圾，标记之后是垃圾或者并发标记前是垃圾，并发标记后变非垃圾)，详情这篇文章中的三色标记处理。</li>\n<li>最终标记：先STW，同时修复在并发标记里面出现状态变换的对象，主要用到三色标记里的原始快照算法(见下面详解)做重新标记，详情这篇文章中的三色标记。</li>\n<li>筛选回收：会根据用户所指定的STW参数-XX:MaxGCPauseMillis(最大垃圾回收停顿时间)来制定回收计划，判断这轮回收需要回收多少个，所以这个阶段不一定会将所有的垃圾都回收掉，它在回收之前对堆有一个区域的回收时间估算，如果回收1/2就达到了用户指定的最大停顿时间，那么就只会回收1/2，但是这1/2如何去选具体是哪一块区域，有一个筛选算法在下面详解，剩下的在下一次的垃圾回收去回收，这也就是为什么没有重置标记，其实筛选回收是可以与用户线程并发执行的，但是由于我们指定了最大停顿时间，所以，在保证时间的情况下为了提高吞吐量，我们进行了STW，回收完成之后将旧的地址转换成新的地址。（注意：其实这个阶段可以与用户线程并发执行，但是由于G1内部算法过于复杂，没有实现并发执行，不过到了Shenandoah就实现了并发收集，Shenandoah可以看成是G1的升级版本。）</li>\n</ul>\n<h3> g1 回收算法</h3>\n<p>G1回收<u>无论是年轻代还是老年代主要的回收算法是<code>复制算法</code></u>，它会将要<u>回收Region的存活对象挪到相邻的空的Region，然后清空之前的Region，这样就保证了内存碎片的减少</u>。</p>\n<p>G1筛选回收筛选算法</p>\n<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>\n<p>在G1收集器后台维护了一个优先列表，每次根据允许的收集时间，选择回收价值最大的Region，比如在同等大小的两个Region下，回收一个需要100ms，一个需要50ms，那么G1肯定会优先回收那个50ms的，这样就保证了在有效时间内能回收更多的堆空间，回收时间就是复制的时间，要复制的存活对象越多，回收时间就越长，回收的效益就越低，被回收的优先级就越低。</p>\n<h3> g1 回收特点</h3>\n<ul>\n<li>并行与并发：G1能充分利用CPU、多核的环境优势来缩短STW停顿时间，部分其他收集器需要STW的区域，G1也可以并发执行。</li>\n<li>分代收集：虽然G1去掉了连续内存空间分代的概念，也不需要其他收集器配合使用，但分代收集依然存在。</li>\n<li>空间整合：整体上看，G1采用了标记–整理的算法，局部看是标记–复制算法。</li>\n<li>可预测停顿时间：用户可通过-XX:MaxGCPauseMillis参数设置最大停顿时间，拥有良好的用户体验，但是这个参数不可随意设置，不能设置的太小，否则每一次minor gc时间过短，收集的垃圾太少，容易触发full gc。</li>\n</ul>\n<h3> g1 使用场景</h3>\n<blockquote>\n<p>1、50%以上的堆被存活对象占用：当大多数对象都存活的时候，说明老年代被占用的比例也会很大，这个时候就会触发full gc，full gc是很慢的，如果我们使用G1，那么G1就会触发mixed gc，而且mixed gc的GC最大停顿时间还是可控的。</p>\n</blockquote>\n<blockquote>\n<p>2、对象分配和晋升的速度变化非常大：说明了对象往老年代挪动的频率很频繁，一样的，可以减少full gc的发生。</p>\n</blockquote>\n<blockquote>\n<p>3、垃圾回收时间特别长，超过1秒：可以设置停顿时间，提升用户体验。</p>\n</blockquote>\n<blockquote>\n<p>4、8GB以上的堆内存(建议值)：内存如果在8G以下，收集的垃圾不是很多，而G1的算法相对于CMS较为复杂，还很有可能效率不如CMS，但是对于大内存，STW时间比较长，所以，在可控停顿时间这里，G1比较合适。</p>\n</blockquote>\n<blockquote>\n<p>5、停顿时间是500ms以内：停顿时间可由用户控制。</p>\n</blockquote>\n<h3> ZGC 收集器</h3>\n<p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p>\n<p>在 ZGC 中出现 Stop The World 的情况会更少！</p>\n<p>详情可以看 ： <a href=\"https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html\" target=\"_blank\" rel=\"noopener noreferrer\">《新一代垃圾回收器 ZGC 的探索与实践》</a></p>\n<blockquote>\n<p>ZGC从jdk11开始支持，目前还是一个实验性版本，ZGC可以说源自于是Azul System公司开发的C4（Concurrent Continuously Compacting Collector） 收集器，主要&gt;支持平台如下：</p>\n</blockquote>\n<h3> ZGC 目标</h3>\n<p>支持TB级别：根据官方文档来看，在Jdk11时ZGC可支持的最大内存为4TB，在jdk13可以支持16TB。\n最大停顿时间不超过10ms：之所以能控制在10ms以下，是因为它的停顿时间主要跟Root扫描有关，而跟root数量和堆的大小没有关系。\n奠定未来GC特性的基础。\n最坏的情况下吞吐量会下降15%。</p>\n<h3> ZGC 内存布局</h3>\n<p>ZGC内部是以Region的方式进行内存布局的，暂时没有设置分代，使用读屏障、颜色指针等技术来实现可并发的标记–整理算法的，且低延迟，Region分为大中小三种类型，详情如下：\n小型Region(small Region)：容量为2mb，用于放置小于256kb的对象。\n中型Region(medium Region)：容量为4mb，用于放置容量大于等于256kb但小于4mb的对象。\n大型Region(large Region)：容量不固定，大小可变，但必须是2的整数倍，且大小大于等于4mb的对象。\n注意：由于大型Region的容量大小可变，所以，它的容量有可能小于中型Region，容量最低可达4mb，因为大型Region只放4mb以上的对象(包括4mb)，且每个大型Region只存放一个大对象，所以大型对象不会被ZGC重分配(重分配是ZGC的一种处理动作，用于复制对象的收集器阶段)，第一，大对象复制的代价比较高，第二，一个Region只会分配一个大对象，所以，当成为垃圾时直接销毁即可。</p>\n<h3> ZGC回收过程</h3>\n\n<p>ZGC大体分为4个阶段，每个小阶段下面又分一些，详情如下：</p>\n<blockquote>\n<p>1、并发标记(Concurrent Mark)：\n初始标记(Mark Start)：先STW，并记录下gc roots直接引用的对象。\n并发标记(Concurrent Mark)：根据初始标记的结果，基于gc roots可达性分析算法找出所有被引用的对象，在G1中使用三色标记对对象的状态做维护，ZGC使用颜色指针做标记(颜色指针详情在博客后面的颜色指针)。\n最终标记(Mark End)：先STW，然后修复一些在并发标记过程中垃圾状态出现变化的对象。</p>\n</blockquote>\n<blockquote>\n<p>2、并发预备重分配(Concurrent Prepare for Relocate)：这个阶段ZGC会根据特定的查询条件扫描一下所有的Region并得出本次收集过程中需要清理哪些Region，将它们重新组成重分配集（Relocation Set），用范围更大的扫描成本换取省去G1中记忆集的维护成本。</p>\n</blockquote>\n<blockquote>\n<p>3、并发重分配(Concurrent Relocate)：\n初始重分配(Relocate Start)：做一些并发重分配的初始化动作。\n并发重分配(Concurrent Relocate)：这个阶段需要将并发预备重分配阶段计算出来的重分配集中的Region复制到新的Region并为每一个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系，从转发表ZGC就可以明确的知道哪些对象是否处于重分配集之中，在这个阶段时，如果有用户线程访问这个对象，这次访问将会被预置的内存屏障(读屏障)所截获，然后根据Region的转发表找出新的地址并访问，如果有更新再更新地址上的值，并使其指向新对象(这样子只有第一次访问时会变慢，后面的就可以不通过读屏障和转发表直接访问)，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力。注意：一旦一个Region中的对象全部复制完成，旧的Region就可以清理释放掉了，但是转发表不能立即释放，因为可能还有访问在使用这个转发表，因为对象的旧地址转新地址是对象在被引用之后才会进行的操作。</p>\n</blockquote>\n<blockquote>\n<p>4、并发重映射(Concurrent Remap)：重映射其实就是将旧的地址转换为新的地址，由于ZGC中对象引用存在“自愈”功能，所以这个阶段其实不做也是可以的，ZGC很巧妙的将这一阶段合并到了下一次的并发标记阶段，反正他们都是要遍历所有对象的，这样也就减少了一次遍历对象的开销，一个Region的所有对象都被修改后，那么这个Region对应的转发表就会被销毁掉。</p>\n</blockquote>\n<h3> ZGC 的读屏障</h3>\n<p>在并发重分配的时候，每进行一个对象的复制移动会对其颜色指针的Remapped标识赋值，标识这个指针被gc过，并且还会为其加一个读屏障，使得用户线程访问这个对象时可以知道这个对象的地址被改变了，程序就应该暂停一下，先更新一下地址，再进行访问值的操作，正是因为Load Barriers的存在，所以会导致配置ZGC的应用的吞吐量会变低。官方的测试数据是需要多出额外4%的开销。</p>\n<h3> ZGC 触发时机</h3>\n<blockquote>\n<p>1、定时触发：默认关闭，可通过ZCollectionInterval参数配置。</p>\n</blockquote>\n<blockquote>\n<p>2、预热触发：最多三次，在堆内存达到10%、20%、30%时触发，主要是统计GC时间，为其他GC机制使用。</p>\n</blockquote>\n<blockquote>\n<p>3、分配速率：基于正态分布统计，计算内存99.9%可能的最大分配速率，以及此速率下内存将要耗尽的时间点，在耗尽之前触发GC（耗尽时间 - 一次GC最大持续时间 - 一次GC检测周期时间）。</p>\n</blockquote>\n<blockquote>\n<p>4、主动触发：（默认开启，可通过ZProactive参数配置） 距上次GC堆内存增长10%，或超过5分钟时，对比距上次GC的间隔时间跟（49 * 一次GC的最大持续时间），超过则触发。</p>\n</blockquote>\n",
      "date_modified": "2023-08-03T23:47:31.329Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "ClassLoad详解(重点)",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html",
      "summary": "参考 请查看原创 ClassLoad详解(重点) 回顾一下类加载过程 开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。 类加载过程：加载-&gt;连接-&gt;初始化。 连接过程又可分为三步：验证-&gt;准备-&gt;解析。",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p>请查看原创<a href=\"https://javaguide.cn/java/jvm/classloader.html\" target=\"_blank\" rel=\"noopener noreferrer\"> ClassLoad详解(重点) </a></p>\n</div>\n<h2> 回顾一下类加载过程</h2>\n<p>开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。</p>\n<ul>\n<li>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。</li>\n<li>连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</li>\n</ul>\n<p></p>\n<p>加载是类加载过程的第一步，主要完成下面 3 件事情：</p>\n<ol>\n<li>通过全类名获取定义此类的二进制字节流</li>\n<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li>\n</ol>\n<h2> 类加载器</h2>\n<h3> 类加载器介绍</h3>\n<p>类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java Applet（已经被淘汰） 的需要。后来，慢慢成为 Java 程序中的一个重要组成部分，赋予了 Java 类可以被动态加载到 JVM 中并执行的能力。</p>\n<p>根据官方 API 文档的介绍：</p>\n<blockquote>\n<p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a \"class file\" of that name from a file system.</p>\n<p>Every Class object contains a reference to the ClassLoader that defined it.</p>\n<p>Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.</p>\n</blockquote>\n<p>翻译过来大概的意思是：</p>\n<blockquote>\n<p>类加载器是一个负责加载类的对象。<code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。</p>\n<p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>\n</blockquote>\n<p>从上面的介绍可以看出:</p>\n<ul>\n<li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。</li>\n<li>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。</li>\n<li>数组类不是通过 <code>ClassLoader</code> 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>简单来说，<strong>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong> 字节码可以是 Java 源程序（<code>.java</code>文件）经过 <code>javac</code> 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</p>\n<p>其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。本文只讨论其核心功能：加载类。</p>\n<h3> 类加载器加载规则</h3>\n<p>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</p>\n<p>对于已经加载的类会被放在 <code>ClassLoader</code> 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 类加载器总结</h3>\n<p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p>\n<ol>\n<li><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong>：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li>\n<li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li>\n<li><strong><code>AppClassLoader</code>(应用程序类加载器)</strong>：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li>\n</ol>\n<blockquote>\n<p>🌈 拓展一下：</p>\n<ul>\n<li><strong><code>rt.jar</code></strong>：rt 代表“RunTime”，<code>rt.jar</code>是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.* </code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</li>\n<li>Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</li>\n</ul>\n</blockquote>\n<p>除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ <code>.class</code> 文件）进行加密，加载时再利用自定义的类加载器对其解密。</p>\n<p></p>\n<p>除了 <code>BootstrapClassLoader</code> 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 <code>ClassLoader</code>抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p>\n<p>每个 <code>ClassLoader</code> 可以通过<code>getParent()</code>获取其父 <code>ClassLoader</code>，如果获取到 <code>ClassLoader</code> 为<code>null</code>的话，那么该类是通过 <code>BootstrapClassLoader</code> 加载的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>为什么 获取到 <code>ClassLoader</code> 为<code>null</code>就是 <code>BootstrapClassLoader</code> 加载的呢？</strong> 这是因为<code>BootstrapClassLoader</code> 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。</p>\n<p>下面我们来看一个获取 <code>ClassLoader</code> 的小案例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果(JDK 8 )：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>从输出结果可以看出：</p>\n<ul>\n<li>我们编写的 Java 类 <code>PrintClassLoaderTree</code> 的 <code>ClassLoader</code> 是<code>AppClassLoader</code>；</li>\n<li><code>AppClassLoader</code>的父 <code>ClassLoader</code> 是<code>ExtClassLoader</code>；</li>\n<li><code>ExtClassLoader</code>的父<code>ClassLoader</code>是<code>Bootstrap ClassLoader</code>，因此输出结果为 null。</li>\n</ul>\n<h3> 自定义类加载器</h3>\n<p>我们前面也说说了，除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>抽象类。</p>\n<p><code>ClassLoader</code> 类有两个关键的方法：</p>\n<ul>\n<li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，<code>resove</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li>\n<li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li>\n</ul>\n<p>官方 API 文档中写到：</p>\n<blockquote>\n<p>Subclasses of <code>ClassLoader</code> are encouraged to override <code>findClass(String name)</code>, rather than this method.</p>\n<p>建议 <code>ClassLoader</code>的子类重写 <code>findClass(String name)</code>方法而不是<code>loadClass(String name, boolean resolve)</code> 方法。</p>\n</blockquote>\n<p>如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p>\n<p><code>load破</code> =&gt; <code>楼破</code></p>\n<h2> 双亲委派模型</h2>\n<h3> 双亲委派模型介绍</h3>\n<p>类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。</p>\n<p>根据官网介绍：</p>\n<blockquote>\n<p>The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine's built-in class loader, called the \"bootstrap class loader\", does not itself have a parent but may serve as the parent of a ClassLoader instance.</p>\n</blockquote>\n<p>翻译过来大概的意思是：</p>\n<blockquote>\n<p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。每个 <code>ClassLoader</code> 实例都有一个相关的父类加载器。需要查找类或资源时，<code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。\n虚拟机中被称为 \"bootstrap class loader\"的内置类加载器本身没有父类加载器，但是可以作为 <code>ClassLoader</code> 实例的父类加载器。</p>\n</blockquote>\n<p>从上面的介绍可以看出：</p>\n<ul>\n<li><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</li>\n<li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</li>\n<li><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</li>\n</ul>\n<p>下图展示的各种类加载器之间的层次关系被称为类加载器的“<strong>双亲委派模型(Parents Delegation Model)</strong>”。</p>\n<p></p>\n<p>注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。</p>\n<p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 <code>MotherClassLoader</code> 和一个<code>FatherClassLoader</code> 。个人觉得翻译成单亲委派模型更好一些，不过，国内既然翻译成了双亲委派模型并流传了，按照这个来也没问题，不要被误解了就好。</p>\n<p>另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承，多用组合少用继承。</strong></p>\n<h3> 双亲委派模型的执行流程</h3>\n<p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</p>\n<p>结合上面的源码，简单总结一下双亲委派模型的执行流程：</p>\n<p>1️⃣ 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。<br>\n2️⃣ 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。<br>\n3️⃣ 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</p>\n<p>🌈 拓展一下：</p>\n<p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 <code>Class</code> 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p>\n<h3> 双亲委派模型的好处</h3>\n<p><u>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</u></p>\n<p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p>\n<h3> 打破双亲委派模型方法</h3>\n<p>自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p>\n<blockquote>\n<p>记忆方法：<code>打load</code></p>\n</blockquote>\n<p>为什么是重写 <code>loadClass()</code> 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：</p>\n<blockquote>\n<p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。</p>\n</blockquote>\n<p>我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 <code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。</p>\n<p>Tomcat 的类加载器的层次结构如下：</p>\n<p></p>\n<p>感兴趣的小伙伴可以自行研究一下 Tomcat 类加载器的层次结构，这有助于我们搞懂 Tomcat 隔离 Web 应用的原理，推荐资料是<a href=\"http://gk.link/a/10Egr\" target=\"_blank\" rel=\"noopener noreferrer\">《深入拆解 Tomcat &amp; Jetty》</a>。</p>\n",
      "date_modified": "2023-08-03T23:47:31.343Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "类加载过程详解(重点)",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3.html",
      "summary": "参考 类加载过程详解(重点) 类的生命周期 类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，前三个阶段可以统称为连接（Linking）。这 7 个阶段的顺序如下图所示：",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://javaguide.cn/java/jvm/class-loading-process.html\" target=\"_blank\" rel=\"noopener noreferrer\">类加载过程详解(重点)</a></p>\n</div>\n<h2> 类的生命周期</h2>\n<p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，前三个阶段可以统称为连接（Linking）。这 7 个阶段的顺序如下图所示：</p>\n<p></p>\n<h2> 类加载过程</h2>\n<p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？系统加载 Class 类型的文件主要三步：加载-&gt;连接-&gt;初始化。连接过程又可分为三步：验证-&gt;准备-&gt;解析。</p>\n<p></p>\n<h3> 加载</h3>\n<p>类加载过程的第一步，主要完成下面 3 件事情：</p>\n<ol>\n<li><u>通过全类名获取定义此类的二进制字节流。</u></li>\n<li><u>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</u></li>\n<li><u>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</u></li>\n</ol>\n<p>虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：\"通过全类名获取定义此类的二进制字节流\" 并没有指明具体从哪里获取（ <code>ZIP</code>、 <code>JAR</code>、<code>EAR</code>、<code>WAR</code>、网络、动态代理技术运行时动态生成、其他文件生成比如 <code>JSP</code>...）、怎样获取。</p>\n<p>加载这一步主要是 <strong>类加载器</strong> 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定（不过，我们也能打破由双亲委派模型）。</p>\n<p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>\n<p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。</p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p>\n</div>\n<h3> 验证</h3>\n<p><strong>验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</strong></p>\n<p>验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的，但很有必要，可以有效防止恶意代码的执行。任何时候，程序安全都是第一位。</p>\n<p>不过，验证阶段也不是必须要执行的阶段。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用 <code>-Xverify:none</code> 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>\n<p>验证阶段主要由四个检验阶段组成：</p>\n<ol>\n<li>文件格式验证（Class 文件格式检查）</li>\n<li>元数据验证（字节码语义检查）</li>\n<li>字节码验证（程序语义检查）</li>\n<li>符号引用验证（类的正确性检查）</li>\n</ol>\n<p></p>\n<p>文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p>\n<blockquote>\n<p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>\n</blockquote>\n<p>符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候（解析阶段会介绍符号引用和直接引用）。</p>\n<p>符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常，比如：</p>\n<ul>\n<li><code>java.lang.IllegalAccessError</code>：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。</li>\n<li><code>java.lang.NoSuchFieldError</code>：当类试图访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。</li>\n<li><code>java.lang.NoSuchMethodError</code>：当类试图访问一个指定的方法，而该方法不存在时，抛出该异常。</li>\n<li>......</li>\n</ul>\n<h3> 准备</h3>\n<p><u><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong></u>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>\n<ol>\n<li>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>\n<li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。相关阅读：<a href=\"https://github.com/fenixsoft/jvm_book/issues/75\" title=\"《深入理解Java虚拟机（第3版）》勘误#75\" target=\"_blank\" rel=\"noopener noreferrer\">《深入理解 Java 虚拟机（第 3 版）》勘误#75</a></li>\n<li>这里所设置的初始值\"通常情况\"下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li>\n</ol>\n<p><strong>基本数据类型的零值</strong>：(图片来自《深入理解 Java 虚拟机》第 3 版 7.33 )</p>\n<p></p>\n<h3> 解析</h3>\n<p><u><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong> </u>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p>\n<p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p>\n<p></p>\n<p>举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p>\n<p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>\n<h3> 初始化</h3>\n<p><strong>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong></p>\n<blockquote>\n<p>说明：<code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p>\n</blockquote>\n<p>对于<code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。</p>\n<p>对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p>\n<ol>\n<li>当遇到 <code>new</code>、 <code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这 4 条字节码指令时，比如 <code>new</code> 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。\n<ul>\n<li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li>\n<li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li>\n<li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li>\n<li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li>\n</ul>\n</li>\n<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forname(\"...\")</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</li>\n<li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li>\n<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li>\n<li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，\n就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</li>\n<li>当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>\n</ol>\n<h2> 类卸载</h2>\n<p><strong>卸载类即该类的 Class 对象被 GC。</strong></p>\n<p>卸载类需要满足 3 个要求:</p>\n<ol>\n<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li>\n<li>该类没有在其他任何地方被引用</li>\n<li>该类的类加载器的实例已被 GC</li>\n</ol>\n<p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>\n<p>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>\n",
      "date_modified": "2023-08-03T23:47:31.346Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    },
    {
      "title": "spi",
      "url": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/middleware/dubbo/spi.html",
      "id": "https://vuepress-theme-hope-docs-demo.netlify.app/interview/middleware/dubbo/spi.html",
      "summary": "参考 源码 面试重点： 来说说Dubbo SPI 机制",
      "content_html": "<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">参考</p>\n<p><a href=\"https://github.com/lojzes/spring-cloud-alibaba-study/tree/master/dubbo-study/src/main/java/com/lojzes/dubbo/study/spi\" target=\"_blank\" rel=\"noopener noreferrer\">源码</a></p>\n<p><a href=\"https://www.51cto.com/article/634720.html\" target=\"_blank\" rel=\"noopener noreferrer\">面试重点： 来说说Dubbo SPI 机制</a></p>\n</div>\n<h2> spi</h2>\n<p>SPI是什么</p>\n<p><code>SPI</code>是一种简称，全名叫 <code>Service Provider Interface</code>，Java本身提供了一套SPI机制，SPI 的<u>本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类，这样可以在运行时，动态为接口替换实现类</u>，这也是很多框架组件实现扩展功能的一种手段。</p>\n<p>而今天要说的Dubbo SPI机制和Java SPI还是有一点区别的，Dubbo 并未使用 Java 原生的 SPI 机制，而是对他进行了改进增强，进而可以很容易地对Dubbo进行功能上的扩展。</p>\n<p>1.什么是SPI(开头已经解释了)</p>\n<p>2.Dubbo SPI和Java原生的有什么区别</p>\n<p>3.两种实现应该如何写出来</p>\n<h3> java 原生 spi 实现</h3>\n<p>定义接口、实现类</p>\n<p>然后在项目 <code>META-INF/services</code> 文件夹下创建一个名称为接口的全限定名，<code>com.example.demo.spi.Car</code>。</p>\n<p>文件内容写上实现类的全限定名，如下：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>测试类</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Dubbo SPI是如何实现的</h2>\n<p>Dubbo 使用的SPI并不是Java原生的，而是重新实现了一套，其主要逻辑都在ExtensionLoader类中，逻辑也不难，后面会稍带讲一下</p>\n<p>看看使用，和Java的差不了太多，基于前面的例子来看下，<u>接口类</u>需要加上<code>@SPI</code>注解：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现类不需要改动</p>\n<p>配置文件需要放在<code>META-INF/dubbo</code>下面，配置写法有些区别，直接看代码：</p>\n<p>文件名称，为接口的全限定名称</p>\n<p>com.lojzes.alibaba.dubbo.springboot.spi.HelloSPI</p>\n<p>文件内容</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>测试类</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Dubbo SPI中常用的注解</h2>\n\n<p>总结一下两者区别：</p>\n\n<h2> Dubbo SPI源码分析</h2>\n<p>Dubbo SPI 使用上是通过 ExtensionLoader 的 getExtensionLoader 方法获取一个 ExtensionLoader 实例，然后再通过 ExtensionLoader 的 getExtension 方法获取拓展类对象。这其中，getExtensionLoader 方法用于从缓存中获取与拓展类对应的 ExtensionLoader，如果没有缓存，则创建一个新的实例，直接上代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面这一段代码主要做的事情就是先检查缓存，缓存不存在创建扩展对象</p>\n<h2> 总结</h2>\n<p>从设计思想上来看的话，SPI是对迪米特法则和开闭原则的一种实现。</p>\n<p>开闭原则：<u>对修改关闭对扩展开放</u>。这个原则在众多开源框架中都非常常见，Spring的IOC容器也是大量使用。</p>\n<p>迪米特法则：也叫最小知识原则，可以解释为，<u>不该直接依赖关系的类之间，不要依赖;有依赖关系的类之间，尽量只依赖必要的接口</u>。</p>\n<p>那Dubbo的SPI为什么不直接使用Spring的呢，这一点从众多开源框架中也许都能窥探一点端倪出来，因为本身作为开源框架是要融入其他框架或者一起</p>\n<p>运行的，不能作为依赖被依赖对象存在。</p>\n<p>再者对于Dubbo来说，直接用Spring IOC AOP的话有一些架构臃肿，完全没必要，所以自己实现一套轻量级反而是最优解</p>\n",
      "date_modified": "2023-08-03T23:47:31.351Z",
      "authors": [],
      "tags": [
        "面试"
      ]
    }
  ]
}